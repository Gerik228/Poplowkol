<script>
  var logId = $v('P66_LOG_ID'); 
  var logoutUrl = '/ords/web_rnd/log/log-logout/' + logId;
  var sent = false;

  function sendLogout() {
    if (!logId || sent) return;
    navigator.sendBeacon(logoutUrl);
    sent = true;
  }

  // 1. События ухода со страницы (всегда нужны)
  window.addEventListener('pagehide', sendLogout);
  window.addEventListener('beforeunload', sendLogout);

  // 2. Навигация APEX (в том числе кнопка "Назад")
  document.addEventListener('apexnavigationbegin', sendLogout);

  // 3. Таймаут неактивности — 5 мин
  var idleTimer;
  function resetIdleTimer() {
    clearTimeout(idleTimer);
    idleTimer = setTimeout(sendLogout, 300000); // 5 минут
  }
  ['click', 'mousemove', 'keydown', 'scroll', 'touchstart'].forEach(evt =>
    document.addEventListener(evt, resetIdleTimer, { passive: true })
  );
  resetIdleTimer();
</script>








Инструкция по логированию активности на странице Oracle APEX 23.1

1. Создание таблицы логов

CREATE TABLE web_rnd.audit_log (
  log_id       NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  user_name    VARCHAR2(100) NOT NULL,
  filter_value VARCHAR2(100),
  login_time   TIMESTAMP DEFAULT SYSTIMESTAMP,
  logout_time  TIMESTAMP,
  duration_sec NUMBER,
  CONSTRAINT chk_duration_nonneg CHECK (duration_sec >= 0)
);
CREATE INDEX idx_audit_user        ON web_rnd.audit_log(user_name);
CREATE INDEX idx_audit_filter      ON web_rnd.audit_log(filter_value);
CREATE INDEX idx_audit_login_time  ON web_rnd.audit_log(login_time);

log_id – ID записи (IDENTITY или SEQUENCE).

user_name – имя пользователя (APP_USER).

filter_value – значение элемента-фильтра (например, :P66_IFRAME_ID).

login_time – время входа (по умолчанию SYSTIMESTAMP).

logout_time – время выхода.

duration_sec – длительность в секундах (вычисляется при выходе).


2. Процесс APEX на входе (On Load: Before Header)

1. Создать скрытый элемент страницы (например, P66_LOG_ID), который будет хранить ID записи лога.


2. Добавить PL/SQL-процесс на загрузке страницы (перед заголовком) с кодом:

DECLARE
  v_log_id NUMBER;
BEGIN
  INSERT INTO web_rnd.audit_log (user_name, filter_value, login_time)
  VALUES (:APP_USER, :P66_IFRAME_ID, SYSTIMESTAMP)
  RETURNING log_id INTO v_log_id;
  :P66_LOG_ID := v_log_id;
  -- COMMIT; -- по необходимости явно зафиксировать
END;

:APP_USER – текущий пользователь APEX.

:P66_IFRAME_ID – значение фильтра перед загрузкой.

В переменную страницы P66_LOG_ID сохраняется возвращённый log_id.




3. REST-обработчик выхода (ORDS)

1. В схеме WEB_RND создать REST-модуль LOG_AUDIT с шаблоном log-logout/:log_id (метод POST).


2. В качестве Source Type выбрать PL/SQL и прописать код:

BEGIN
  UPDATE web_rnd.audit_log
     SET logout_time = SYSTIMESTAMP,
         duration_sec = EXTRACT(DAY    FROM (SYSTIMESTAMP - login_time))*86400
                      + EXTRACT(HOUR   FROM (SYSTIMESTAMP - login_time))*3600
                      + EXTRACT(MINUTE FROM (SYSTIMESTAMP - login_time))*60
                      + EXTRACT(SECOND FROM (SYSTIMESTAMP - login_time))
   WHERE log_id = :log_id
     AND logout_time IS NULL;
  COMMIT;
END;

Параметр :log_id берётся из пути log-logout/:log_id.

В запросе обновляется logout_time и вычисляется duration_sec (только если выход ещё не был записан).




4. JavaScript: фиксация выхода

1. На той же странице добавить блок JavaScript с получением log_id и URL REST-обработчика, а также настройкой обработки событий:

<script>
  var logId = $v('P66_LOG_ID'); 
  var logoutUrl = '/ords/web_rnd/log/log-logout/' + logId;
  var sent = false;
  function sendLogout() {
    if (!logId || sent) return;
    navigator.sendBeacon(logoutUrl);
    sent = true;
  }
  // События ухода со страницы: pagehide и beforeunload
  window.addEventListener('pagehide', sendLogout);
  window.addEventListener('beforeunload', sendLogout);
  // Таймаут неактивности 5 мин
  var idleTimer;
  function resetIdleTimer() {
    clearTimeout(idleTimer);
    idleTimer = setTimeout(sendLogout, 300000);
  }
  ['click','mousemove','keydown','scroll','touchstart'].forEach(evt => 
    document.addEventListener(evt, resetIdleTimer)
  );
  resetIdleTimer();
</script>

Используется navigator.sendBeacon для надёжной отправки POST-запроса при выгрузке страницы.

Обработчик pagehide (альтернатива visibilitychange) гарантирует срабатывание при закрытии вкладки или навигации.

По истечении 5 минут бездействия (сброс таймера при движении мыши, нажатии клавиш и т.д.) вызывается тот же sendLogout().




5. Защита от повторной отправки

В функции sendLogout() используется флаг sent, чтобы navigator.sendBeacon сработал только один раз.

Также можно хранить признак отправки в sessionStorage, уникальный для каждой вкладки, чтобы исключить дублирование при срабатывании нескольких событий.


6. Мультивкладочный сценарий

Каждая вкладка создаёт свою запись в audit_log со своим log_id.

Флаг sent (или sessionStorage) гарантирует, что для каждой вкладки будет выполнен ровно один запрос выхода.

Таким образом, записи от каждого одновременного входа фиксируются отдельно.


7. Примеры SELECT-запросов для анализа логов

-- Все записи логов
SELECT log_id, user_name, filter_value, login_time, logout_time, duration_sec
FROM web_rnd.audit_log;

-- Активные (незавершённые) сессии
SELECT * FROM web_rnd.audit_log
WHERE logout_time IS NULL;

-- Средняя длительность сессии по пользователям
SELECT user_name, AVG(duration_sec) AS avg_sec
FROM web_rnd.audit_log
WHERE duration_sec IS NOT NULL
GROUP BY user_name;

-- Сеансы длительностью более 5 минут
SELECT * FROM web_rnd.audit_log
WHERE duration_sec > 300;

Источники: использование navigator.sendBeacon на событиях выгрузки страницы для надёжной отправки данных.

