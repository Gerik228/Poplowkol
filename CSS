 ------------------------------------------------------------------
   Джоб: CLEAN_INACTIVE_EMPLOYEES_DEPS_JOB
   ------------------------------- */
BEGIN
  /* 1.  Если джоб уже был, аккуратно удаляем (игнорируем «нет такого») */
  BEGIN
    DBMS_SCHEDULER.drop_job('CLEAN_INACTIVE_EMPLOYEES_DEPS_JOB', force => TRUE);
  EXCEPTION
    WHEN OTHERS THEN
      IF SQLCODE <> -27475 THEN  -- ORA-27475: job does not exist
        RAISE;
      END IF;
  END;

  /* 2.  Создаём заново с нужной логикой */
  DBMS_SCHEDULER.create_job (
    job_name        => 'CLEAN_INACTIVE_EMPLOYEES_DEPS_JOB',
    job_type        => 'PLSQL_BLOCK',
    job_action      => q'[
      DECLARE
        v_rp_emp  PLS_INTEGER;  -- BI_ACC_ROLES_PAGES / сотрудники
        v_ud_emp  PLS_INTEGER;  -- BI_ACC_USERS_AND_DEPS / сотрудники
        v_rp_dep  PLS_INTEGER;  -- BI_ACC_ROLES_PAGES / подразделения
        v_ud_dep  PLS_INTEGER;  -- BI_ACC_USERS_AND_DEPS / подразделения
      BEGIN
        /* --- 1. Страницы-роли сотрудников, уволенных (type_object_id = 2) ---- */
        DELETE FROM BI_ACC_ROLES_PAGES rp
        WHERE rp.type_object_id = 2
          AND EXISTS (
                SELECT 1
                FROM   BI_PORTAL_END_DATE_EMPL_DEP pd
                WHERE  pd.object_id     = rp.object_id
                  AND  pd.dash_id       IS NULL
                  AND  pd.type_object_id = 2
              );
        v_rp_emp := SQL%ROWCOUNT;

        /* --- 2. USERS_AND_DEPS для уволенных сотрудников -------------------- */
        DELETE FROM BI_ACC_USERS_AND_DEPS ud
        WHERE ud.type_object_id = 2
          AND EXISTS (
                SELECT 1
                FROM   BI_PORTAL_END_DATE_EMPL_DEP pd
                WHERE  pd.object_id     = ud.object_id
                  AND  pd.role_id       IS NULL
                  AND  pd.type_object_id = 2
              );
        v_ud_emp := SQL%ROWCOUNT;

        /* --- 3. Страницы-роли закрытых подразделений (type_object_id = 1) ---- */
        DELETE FROM BI_ACC_ROLES_PAGES rp
        WHERE rp.type_object_id = 1
          AND EXISTS (
                SELECT 1
                FROM   BI_PORTAL_END_DATE_EMPL_DEP pd
                WHERE  pd.object_id     = rp.object_id
                  AND  pd.dash_id       IS NULL
                  AND  pd.type_object_id = 1
              );
        v_rp_dep := SQL%ROWCOUNT;

        /* --- 4. USERS_AND_DEPS для закрытых подразделений ------------------- */
        DELETE FROM BI_ACC_USERS_AND_DEPS ud
        WHERE ud.type_object_id = 1
          AND EXISTS (
                SELECT 1
                FROM   BI_PORTAL_END_DATE_EMPL_DEP pd
                WHERE  pd.object_id     = ud.object_id
                  AND  pd.role_id       IS NULL
                  AND  pd.type_object_id = 1
              );
        v_ud_dep := SQL%ROWCOUNT;

        COMMIT;   -- фиксируем изменения

        /* --- необязательно, но удобно для отладки / логов ------------------ */
        DBMS_OUTPUT.put_line(
          'Удалено: RP_emp='||v_rp_emp||
          ', UD_emp='||v_ud_emp||
          ', RP_dep='||v_rp_dep||
          ', UD_dep='||v_ud_dep
        );
      END;
    ]',
    /* первый запуск – ближайшие 08:00 сегодняшнего/завтрашнего дня */
    start_date      => TRUNC(SYSDATE) + INTERVAL '8' HOUR,
    /* далее – каждый день в 08:00 */
    repeat_interval => 'FREQ=DAILY;BYHOUR=8;BYMINUTE=0;BYSECOND=0',
    enabled         => TRUE,
    comments        => 'Очищает записи уволенных сотрудников и закрытых подразделений'
  );
END;
/

Как это работает и почему «удалит всё»

1. EXISTS вместо IN
Подзапрос возвращает любое количество строк (10 000, 100 000 — сколько угодно).
Если объект встречается несколько раз — достаточно одного совпадения, запись удалится.


2. SQL%ROWCOUNT
Сразу после DELETE мы фиксируем, сколько строк ушло. Удобно потом смотреть в логе-джоба, что реально чистится (или, наоборот, вдруг стало 0 — сигнал, что критерий больше никого не находит).


3. Команда COMMIT одна, в самом конце.
Все четыре удаления срабатывают в одной транзакции и попадают в журнал единым набором.


4. Запуск в 08:00

start_date = «сегодня 08:00» (если уже позже - запустится завтра);

repeat_interval = 'FREQ=DAILY;BYHOUR=8;BYMINUTE=0;BYSECOND=0'.





---

Проверить, что джоб создался и запустится

SELECT job_name,
       state,
       last_start_date,
       next_run_date
FROM   user_scheduler_jobs
WHERE  job_name = 'CLEAN_INACTIVE_EMPLOYEES_DEPS_JOB';

Для ручного теста:

BEGIN
  DBMS_SCHEDULER.run_job('CLEAN_INACTIVE_EMPLOYEES_DEPS_JOB');
END;
/

В логе (user_scheduler_job_run_details) увидите строки вида:

***  Unpublished Output ***
Удалено: RP_emp=152, UD_emp=152, RP_dep=17, UD_dep=17

— значит, удалилось столько-то записей, и логика действительно «берёт всё, что подходит».

