-- ============================================================================
-- =================================
-- ШАГ 1: СОЗДАЕМ СПЕЦИФИКАЦИЮ ПАКЕТА (Package Specification)
-- ВСЕ КОНСТАНТЫ ОБЪЯВЛЯЕМ ТОЛЬКО ЗДЕСЬ! (НЕ ДУБЛИРОВАТЬ В ТЕЛЕ!)
-- ============================================================================

CREATE OR REPLACE PACKAGE AD_SYNC_SERVICE.PKG_AD_SYNC AS

  -- ===========================================================================
  -- ПУБЛИЧНЫЕ КОНСТАНТЫ (ОБЪЯВЛЯЕМ ТОЛЬКО В СПЕЦИФИКАЦИИ!)
  -- ===========================================================================
  C_SUCCESS   CONSTANT VARCHAR2(10) := 'SUCCESS';
  C_ERROR     CONSTANT VARCHAR2(10) := 'ERROR';
  C_WARNING   CONSTANT VARCHAR2(10) := 'WARNING';
  C_ACTIVE    CONSTANT VARCHAR2(10) := 'ACTIVE';
  C_INACTIVE  CONSTANT VARCHAR2(10) := 'INACTIVE';

  -- ===========================================================================
  -- ПУБЛИЧНЫЕ ТИПЫ ДАННЫХ
  -- ===========================================================================
  TYPE t_config_rec IS RECORD (
    ldap_host         VARCHAR2(256),
    ldap_port         NUMBER,
    user_base_dn      VARCHAR2(512),
    group_base_dn     VARCHAR2(512),
    bind_dn           VARCHAR2(512),
    bind_password     VARCHAR2(256),
    batch_size        NUMBER,
    user_filter       VARCHAR2(256),
    group_filter      VARCHAR2(256),
    timeout_seconds   NUMBER,
    max_retries       NUMBER
  );

  -- ===========================================================================
  -- ПУБЛИЧНЫЕ ФУНКЦИИ (ТОЛЬКО ОБЪЯВЛЕНИЯ)
  -- ===========================================================================
  FUNCTION get_config RETURN t_config_rec;
  FUNCTION generate_session_id RETURN VARCHAR2;

  -- ===========================================================================
  -- ПУБЛИЧНЫЕ ПРОЦЕДУРЫ (ТОЛЬКО ОБЪЯВЛЕНИЯ)
  -- ===========================================================================
  PROCEDURE log_sync_event(
    p_session_id    IN VARCHAR2,
    p_sync_type     IN VARCHAR2,
    p_operation     IN VARCHAR2,
    p_object_id     IN VARCHAR2,
    p_status        IN VARCHAR2,
    p_start_time    IN TIMESTAMP,
    p_end_time      IN TIMESTAMP DEFAULT SYSTIMESTAMP,
    p_records_proc  IN NUMBER DEFAULT 0,
    p_records_succ  IN NUMBER DEFAULT 0,
    p_records_err   IN NUMBER DEFAULT 0,
    p_error_msg     IN VARCHAR2 DEFAULT NULL,
    p_detailed_log  IN CLOB DEFAULT NULL
  );

  PROCEDURE sync_users_only;
  PROCEDURE sync_groups_only;
  PROCEDURE sync_memberships_only;
  PROCEDURE sync_daily_full;

END PKG_AD_SYNC;
/

-- ============================================================================
-- ШАГ 2: СОЗДАЕМ ТЕЛО ПАКЕТА (Package Body)
-- БЕЗ ПОВТОРНОГО ОБЪЯВЛЕНИЯ КОНСТАНТ! (УЖЕ ЕСТЬ В СПЕЦИФИКАЦИИ!)
-- ============================================================================

CREATE OR REPLACE PACKAGE BODY AD_SYNC_SERVICE.PKG_AD_SYNC AS

  -- ===========================================================================
  -- ПРИВАТНЫЕ ФУНКЦИИ (ТОЛЬКО В ТЕЛЕ ПАКЕТА)
  -- ===========================================================================
  FUNCTION extract_sam_from_dn(p_dn VARCHAR2) RETURN VARCHAR2 IS
    l_start_pos NUMBER;
    l_end_pos   NUMBER;
    l_result    VARCHAR2(256);
  BEGIN
    IF p_dn IS NULL THEN
      RETURN 'UNKNOWN_USER';
    END IF;
    
    l_start_pos := INSTR(UPPER(p_dn), 'CN=');
    IF l_start_pos > 0 THEN
      l_start_pos := l_start_pos + 3;
      l_end_pos := INSTR(p_dn, ',', l_start_pos);
      IF l_end_pos = 0 THEN
        l_end_pos := LENGTH(p_dn) + 1;
      END IF;
      l_result := TRIM(SUBSTR(p_dn, l_start_pos, l_end_pos - l_start_pos));
    ELSE
      l_result := 'USER_' || TO_CHAR(SYSDATE, 'HH24MISS');
    END IF;
    
    RETURN l_result;
  END extract_sam_from_dn;

  -- ===========================================================================
  -- ПУБЛИЧНАЯ ФУНКЦИЯ: ПОЛУЧЕНИЕ КОНФИГУРАЦИИ
  -- ===========================================================================
  FUNCTION get_config RETURN t_config_rec IS
    l_config t_config_rec;
  BEGIN
    -- Проверенные значения из вашей среды
    l_config.ldap_host := '';
    l_config.ldap_port := 389;
    l_config.user_base_dn := '';
    l_config.group_base_dn := '';
    l_config.bind_dn := '';
    l_config.bind_password := '';
    l_config.batch_size := 1000;
    l_config.user_filter := '(&(objectClass=person)(!(userAccountControl:1.2.840.113556.1.4.803:=2)))';
    l_config.group_filter := '(&(objectClass=group)(!(groupType:1.2.840.113556.1.4.803:=2147483648)))';
    l_config.timeout_seconds := 300;
    l_config.max_retries := 3;

    -- Безопасная попытка получить из конфигурационной таблицы
    BEGIN
      FOR rec IN (
        SELECT config_name, config_value 
        FROM ad_sync_config 
        WHERE config_group IN ('LDAP', 'SYNC', 'FILTERS')
      ) LOOP
        CASE rec.config_name
          WHEN 'HOST' THEN 
            l_config.ldap_host := rec.config_value;
          WHEN 'PORT' THEN 
            l_config.ldap_port := TO_NUMBER(rec.config_value);
          WHEN 'USER_BASE_DN' THEN 
            l_config.user_base_dn := rec.config_value;
          WHEN 'GROUP_BASE_DN' THEN 
            l_config.group_base_dn := rec.config_value;
          WHEN 'BIND_DN' THEN 
            l_config.bind_dn := rec.config_value;
          WHEN 'BIND_PASSWORD' THEN 
            l_config.bind_password := rec.config_value;
          WHEN 'BATCH_SIZE' THEN 
            l_config.batch_size := TO_NUMBER(rec.config_value);
          WHEN 'USER_FILTER' THEN 
            l_config.user_filter := rec.config_value;
          WHEN 'GROUP_FILTER' THEN 
            l_config.group_filter := rec.config_value;
          WHEN 'TIMEOUT_SECONDS' THEN 
            l_config.timeout_seconds := TO_NUMBER(rec.config_value);
          WHEN 'MAX_RETRIES' THEN 
            l_config.max_retries := TO_NUMBER(rec.config_value);
          ELSE 
            NULL;
        END CASE;
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN 
        NULL; -- Используем дефолтные значения
    END;

    RETURN l_config;
  END get_config;

  -- ===========================================================================
  -- ПУБЛИЧНАЯ ФУНКЦИЯ: ГЕНЕРАЦИЯ ID СЕССИИ
  -- ===========================================================================
  FUNCTION generate_session_id RETURN VARCHAR2 IS
  BEGIN
    RETURN 'SYNC_' || TO_CHAR(SYSDATE, 'YYYYMMDD_HH24MISS') || '_' || 
           LPAD(TRUNC(DBMS_RANDOM.VALUE(1000, 9999)), 4, '0');
  END generate_session_id;

  -- ===========================================================================
  -- ПУБЛИЧНАЯ ПРОЦЕДУРА: ЛОГИРОВАНИЕ (АВТОНОМНАЯ ТРАНЗАКЦИЯ)
  -- ===========================================================================
  PROCEDURE log_sync_event(
    p_session_id    IN VARCHAR2,
    p_sync_type     IN VARCHAR2,
    p_operation     IN VARCHAR2,
    p_object_id     IN VARCHAR2,
    p_status        IN VARCHAR2,
    p_start_time    IN TIMESTAMP,
    p_end_time      IN TIMESTAMP DEFAULT SYSTIMESTAMP,
    p_records_proc  IN NUMBER DEFAULT 0,
    p_records_succ  IN NUMBER DEFAULT 0,
    p_records_err   IN NUMBER DEFAULT 0,
    p_error_msg     IN VARCHAR2 DEFAULT NULL,
    p_detailed_log  IN CLOB DEFAULT NULL
  ) IS
    PRAGMA AUTONOMOUS_TRANSACTION;
  BEGIN
    INSERT INTO ad_sync_log (
      sync_session_id,
      sync_type,
      sync_operation,
      object_identifier,
      sync_status,
      start_time,
      end_time,
      duration_seconds,
      records_processed,
      records_success,
      records_error,
      error_message,
      detailed_log,
      created_date,
      created_by
    ) VALUES (
      p_session_id,
      p_sync_type,
      p_operation,
      p_object_id,
      p_status,
      p_start_time,
      p_end_time,
      CASE 
        WHEN p_end_time > p_start_time 
        THEN EXTRACT(SECOND FROM (p_end_time - p_start_time))
        ELSE 0 
      END,
      p_records_proc,
      p_records_succ,
      p_records_err,
      SUBSTR(p_error_msg, 1, 4000),
      p_detailed_log,
      SYSDATE,
      USER
    );
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN 
      NULL; -- Критическая защита логирования
  END log_sync_event;

  -- ===========================================================================
  -- ПУБЛИЧНАЯ ПРОЦЕДУРА: СИНХРОНИЗАЦИЯ ПОЛЬЗОВАТЕЛЕЙ
  -- ИСПОЛЬЗУЕМ ТОЧНЫЙ СИНТАКСИС ИЗ Oracle Database 19c-21c Reference!
  -- ===========================================================================
  PROCEDURE sync_users_only IS
    l_config      t_config_rec;
    l_session_id  VARCHAR2(50);
    l_start_time  TIMESTAMP;
    l_session     DBMS_LDAP.SESSION;
    l_retval      PLS_INTEGER;
    l_message     DBMS_LDAP.MESSAGE;
    l_entry       DBMS_LDAP.MESSAGE;
    l_dn          VARCHAR2(2000);
    l_sam_account VARCHAR2(256);
    l_processed   NUMBER := 0;
    l_success     NUMBER := 0;
    l_errors      NUMBER := 0;
    l_retry_count NUMBER := 0;
    
  BEGIN
    l_config := get_config();
    l_session_id := generate_session_id();
    l_start_time := SYSTIMESTAMP;

    -- Логируем начало синхронизации
    log_sync_event(
      p_session_id => l_session_id,
      p_sync_type  => 'USERS',
      p_operation  => 'SYNC_START',
      p_object_id  => 'BULK',
      p_status     => C_SUCCESS,
      p_start_time => l_start_time
    );

    -- Помечаем всех пользователей как неактивных
    UPDATE ad_users 
    SET sync_status = C_INACTIVE, 
        last_sync_date = SYSDATE,
        modified_by = USER,
        modified_date = SYSDATE;

    -- Главный цикл с повторными попытками подключения
    WHILE l_retry_count < l_config.max_retries LOOP
      BEGIN
        -- Включаем режим исключений LDAP
        DBMS_LDAP.USE_EXCEPTION := TRUE;
        
        -- Инициализация LDAP соединения
        l_session := DBMS_LDAP.init(
          hostname => l_config.ldap_host, 
          portnum => l_config.ldap_port
        );
        
        -- Аутентификация (bind)
        l_retval := DBMS_LDAP.simple_bind_s(
          ld => l_session,
          dn => l_config.bind_dn,
          passwd => l_config.bind_password
        );
        
        IF l_retval = DBMS_LDAP.SUCCESS THEN
          -- ПРАВИЛЬНЫЙ ВЫЗОВ search_s (ИЗ ORACLE DATABASE REFERENCE!)
          -- Функция search_s имеет OUT параметр res!
          l_retval := DBMS_LDAP.search_s(
            ld => l_session,
            base => l_config.user_base_dn,
            scope => DBMS_LDAP.SCOPE_SUBTREE,
            filter => l_config.user_filter,
            attrs => NULL, -- все атрибуты
            attronly => 0, -- атрибуты и значения
            res => l_message -- OUT параметр!
          );
          
          IF l_retval = DBMS_LDAP.SUCCESS THEN
            -- Обрабатываем результаты поиска
            l_entry := DBMS_LDAP.first_entry(
              ld => l_session, 
              msg => l_message
            );
            
            -- Цикл по всем найденным записям
            WHILE l_entry IS NOT NULL LOOP
              BEGIN
                -- Получаем Distinguished Name
                l_dn := DBMS_LDAP.get_dn(
                  ld => l_session, 
                  ldapentry => l_entry
                );
                
                -- Извлекаем sAMAccountName
                l_sam_account := extract_sam_from_dn(l_dn);
                
                -- MERGE в таблицу пользователей (ТОЧНЫЕ ИМЕНА КОЛОНОК!)
                MERGE INTO ad_users tgt
                USING (
                  SELECT 
                    l_sam_account as sam_account_name,
                    l_dn as distinguished_name
                  FROM dual
                ) src ON (tgt.sam_account_name = src.sam_account_name)
                WHEN MATCHED THEN UPDATE SET
                  distinguished_name = src.distinguished_name,
                  sync_status = C_ACTIVE,
                  last_sync_date = SYSDATE,
                  modified_by = USER,
                  modified_date = SYSDATE
                WHEN NOT MATCHED THEN INSERT (
                  user_id,
                  sam_account_name,
                  distinguished_name,
                  sync_status,
                  created_date,
                  created_by,
                  last_sync_date
                ) VALUES (
                  'U' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS') || '_' || l_processed,
                  src.sam_account_name,
                  src.distinguished_name,
                  C_ACTIVE,
                  SYSDATE,
                  USER,
                  SYSDATE
                );
                
                l_success := l_success + 1;
                
                -- Пакетный коммит для производительности
                IF MOD(l_success, l_config.batch_size) = 0 THEN
                  COMMIT;
                END IF;
                
              EXCEPTION
                WHEN OTHERS THEN
                  l_errors := l_errors + 1;
                  -- Логируем ошибку конкретного пользователя
                  log_sync_event(
                    p_session_id => l_session_id,
                    p_sync_type  => 'USERS',
                    p_operation  => 'USER_ERROR',
                    p_object_id  => l_sam_account,
                    p_status     => C_ERROR,
                    p_start_time => l_start_time,
                    p_error_msg  => SQLERRM
                  );
              END;
              
              l_processed := l_processed + 1;
              
              -- Переходим к следующей записи
              l_entry := DBMS_LDAP.next_entry(
                ld => l_session, 
                msg => l_entry
              );
            END LOOP;
            
            -- Успешно завершили поиск - выходим из retry цикла
            EXIT;
            
          END IF; -- search_s success
        END IF; -- bind success
        
        -- Закрываем LDAP соединение
        l_retval := DBMS_LDAP.unbind_s(ld => l_session);
        
      EXCEPTION
        WHEN OTHERS THEN
          l_retry_count := l_retry_count + 1;
          
          -- Безопасное закрытие соединения при ошибке
          IF l_session IS NOT NULL THEN
            BEGIN
              l_retval := DBMS_LDAP.unbind_s(ld => l_session);
            EXCEPTION 
              WHEN OTHERS THEN 
                NULL;
            END;
          END IF;
          
          -- Если исчерпали попытки - финальная ошибка
          IF l_retry_count >= l_config.max_retries THEN
            log_sync_event(
              p_session_id => l_session_id,
              p_sync_type  => 'USERS',
              p_operation  => 'LDAP_FINAL_ERROR',
              p_object_id  => 'CONNECTION',
              p_status     => C_ERROR,
              p_start_time => l_start_time,
              p_error_msg  => SQLERRM
            );
            RAISE;
          ELSE
            -- Логируем попытку повтора
            log_sync_event(
              p_session_id => l_session_id,
              p_sync_type  => 'USERS',
              p_operation  => 'RETRY_' || l_retry_count,
              p_object_id  => 'CONNECTION',
              p_status     => C_WARNING,
              p_start_time => l_start_time,
              p_error_msg  => SQLERRM
            );
            
            -- Пауза перед повтором
            DBMS_LOCK.SLEEP(2);
          END IF;
      END;
    END LOOP; -- retry loop

    -- Финальный коммит всех изменений
    COMMIT;
    
    -- Удаляем пользователей, которых больше нет в Active Directory
    DELETE FROM ad_users WHERE sync_status = C_INACTIVE;
    COMMIT;

    -- Логируем завершение синхронизации
    log_sync_event(
      p_session_id   => l_session_id,
      p_sync_type    => 'USERS',
      p_operation    => 'SYNC_COMPLETE',
      p_object_id    => 'BULK',
      p_status       => CASE WHEN l_errors = 0 THEN C_SUCCESS ELSE C_WARNING END,
      p_start_time   => l_start_time,
      p_records_proc => l_processed,
      p_records_succ => l_success,
      p_records_err  => l_errors
    );

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      log_sync_event(
        p_session_id => l_session_id,
        p_sync_type  => 'USERS',
        p_operation  => 'SYNC_FAILED',
        p_object_id  => 'BULK',
        p_status     => C_ERROR,
        p_start_time => l_start_time,
        p_error_msg  => SQLERRM
      );
      RAISE;
  END sync_users_only;

  -- ===========================================================================
  -- ПУБЛИЧНАЯ ПРОЦЕДУРА: СИНХРОНИЗАЦИЯ ГРУПП
  -- ===========================================================================
  PROCEDURE sync_groups_only IS
    l_config      t_config_rec;
    l_session_id  VARCHAR2(50);
    l_start_time  TIMESTAMP;
    l_session     DBMS_LDAP.SESSION;
    l_retval      PLS_INTEGER;
    l_message     DBMS_LDAP.MESSAGE;
    l_entry       DBMS_LDAP.MESSAGE;
    l_dn          VARCHAR2(2000);
    l_group_name  VARCHAR2(256);
    l_processed   NUMBER := 0;
    l_success     NUMBER := 0;
    l_errors      NUMBER := 0;
    
  BEGIN
    l_config := get_config();
    l_session_id := generate_session_id();
    l_start_time := SYSTIMESTAMP;

    log_sync_event(
      p_session_id => l_session_id,
      p_sync_type  => 'GROUPS',
      p_operation  => 'SYNC_START',
      p_object_id  => 'BULK',
      p_status     => C_SUCCESS,
      p_start_time => l_start_time
    );

    -- Помечаем все группы как неактивные
    UPDATE ad_groups 
    SET sync_status = C_INACTIVE, 
        last_sync_date = SYSDATE,
        modified_by = USER,
        modified_date = SYSDATE;

    BEGIN
      DBMS_LDAP.USE_EXCEPTION := TRUE;
      
      -- LDAP соединение
      l_session := DBMS_LDAP.init(
        hostname => l_config.ldap_host, 
        portnum => l_config.ldap_port
      );
      
      l_retval := DBMS_LDAP.simple_bind_s(
        ld => l_session, 
        dn => l_config.bind_dn, 
        passwd => l_config.bind_password
      );
      
      IF l_retval = DBMS_LDAP.SUCCESS THEN
        -- Поиск групп
        l_retval := DBMS_LDAP.search_s(
          ld => l_session,
          base => l_config.group_base_dn,
          scope => DBMS_LDAP.SCOPE_SUBTREE,
          filter => l_config.group_filter,
          attrs => NULL,
          attronly => 0,
          res => l_message
        );
        
        IF l_retval = DBMS_LDAP.SUCCESS THEN
          l_entry := DBMS_LDAP.first_entry(l_session, l_message);
          
          WHILE l_entry IS NOT NULL LOOP
            BEGIN
              l_dn := DBMS_LDAP.get_dn(l_session, l_entry);
              l_group_name := extract_sam_from_dn(l_dn);
              
              -- MERGE в таблицу групп
              MERGE INTO ad_groups tgt
              USING (
                SELECT 
                  l_group_name as sam_account_name,
                  l_dn as distinguished_name
                FROM dual
              ) src ON (tgt.sam_account_name = src.sam_account_name)
              WHEN MATCHED THEN UPDATE SET
                distinguished_name = src.distinguished_name,
                sync_status = C_ACTIVE,
                last_sync_date = SYSDATE,
                modified_by = USER,
                modified_date = SYSDATE
              WHEN NOT MATCHED THEN INSERT (
                group_id,
                sam_account_name,
                distinguished_name,
                sync_status,
                created_date,
                created_by
              ) VALUES (
                'G' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS') || '_' || l_processed,
                src.sam_account_name,
                src.distinguished_name,
                C_ACTIVE,
                SYSDATE,
                USER
              );
              
              l_success := l_success + 1;
              
              IF MOD(l_success, l_config.batch_size) = 0 THEN
                COMMIT;
              END IF;
              
            EXCEPTION
              WHEN OTHERS THEN
                l_errors := l_errors + 1;
            END;
            
            l_processed := l_processed + 1;
            l_entry := DBMS_LDAP.next_entry(l_session, l_entry);
          END LOOP;
        END IF;
      END IF;
      
      l_retval := DBMS_LDAP.unbind_s(l_session);
      
    EXCEPTION
      WHEN OTHERS THEN
        IF l_session IS NOT NULL THEN
          l_retval := DBMS_LDAP.unbind_s(l_session);
        END IF;
        RAISE;
    END;

    COMMIT;
    DELETE FROM ad_groups WHERE sync_status = C_INACTIVE;
    COMMIT;

    log_sync_event(
      p_session_id   => l_session_id,
      p_sync_type    => 'GROUPS',
      p_operation    => 'SYNC_COMPLETE',
      p_object_id    => 'BULK',
      p_status       => CASE WHEN l_errors = 0 THEN C_SUCCESS ELSE C_WARNING END,
      p_start_time   => l_start_time,
      p_records_proc => l_processed,
      p_records_succ => l_success,
      p_records_err  => l_errors
    );

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      log_sync_event(
        p_session_id => l_session_id,
        p_sync_type  => 'GROUPS',
        p_operation  => 'SYNC_FAILED',
        p_object_id  => 'BULK',
        p_status     => C_ERROR,
        p_start_time => l_start_time,
        p_error_msg  => SQLERRM
      );
      RAISE;
  END sync_groups_only;

  -- ===========================================================================
  -- ЗАГЛУШКА: СИНХРОНИЗАЦИЯ ЧЛЕНСТВА В ГРУППАХ
  -- ===========================================================================
  PROCEDURE sync_memberships_only IS
    l_session_id VARCHAR2(50);
  BEGIN
    l_session_id := generate_session_id();
    log_sync_event(
      p_session_id => l_session_id,
      p_sync_type  => 'MEMBERSHIPS',
      p_operation  => 'SYNC_SKIPPED',
      p_object_id  => 'BULK',
      p_status     => C_SUCCESS,
      p_start_time => SYSTIMESTAMP,
      p_error_msg  => 'Implementation pending'
    );
  END sync_memberships_only;

  -- ===========================================================================
  -- ГЛАВНАЯ ПРОЦЕДУРА: ПОЛНАЯ ЕЖЕДНЕВНАЯ СИНХРОНИЗАЦИЯ
  -- ===========================================================================
  PROCEDURE sync_daily_full IS
    l_session_id VARCHAR2(50);
    l_start_time TIMESTAMP;
  BEGIN
    l_session_id := generate_session_id();
    l_start_time := SYSTIMESTAMP;

    log_sync_event(
      p_session_id => l_session_id,
      p_sync_type  => 'FULL_SYNC',
      p_operation  => 'DAILY_START',
      p_object_id  => 'ALL',
      p_status     => C_SUCCESS,
      p_start_time => l_start_time
    );

    BEGIN
      -- Последовательная синхронизация всех объектов
      sync_users_only();
      sync_groups_only();
      sync_memberships_only();

      -- Успешное завершение
      log_sync_event(
        p_session_id => l_session_id,
        p_sync_type  => 'FULL_SYNC',
        p_operation  => 'DAILY_COMPLETE',
        p_object_id  => 'ALL',
        p_status     => C_SUCCESS,
        p_start_time => l_start_time
      );

    EXCEPTION
      WHEN OTHERS THEN
        log_sync_event(
          p_session_id => l_session_id,
          p_sync_type  => 'FULL_SYNC',
          p_operation  => 'DAILY_FAILED',
          p_object_id  => 'ALL',
          p_status     => C_ERROR,
          p_start_time => l_start_time,
          p_error_msg  => SQLERRM
        );
        RAISE;
    END;
  END sync_daily_full;

END PKG_AD_SYNC;
/

-- ============================================================================
-- ШАГ 3: ПРОВЕРКИ И ТЕСТИРОВАНИЕ
-- ============================================================================

-- Проверяем успешную компиляцию пакета
SELECT object_name, object_type, status, 
       TO_CHAR(created, 'DD.MM.YYYY HH24:MI:SS') as created_date,
       TO_CHAR(last_ddl_time, 'DD.MM.YYYY HH24:MI:SS') as last_compiled
FROM user_objects 
WHERE object_name = 'PKG_AD_SYNC'
ORDER BY object_type;

-- Проверяем структуру таблиц (убеждаемся в корректности колонок)
PROMPT *** Структура таблицы AD_USERS ***
DESC AD_SYNC_SERVICE.AD_USERS;

PROMPT *** Структура таблицы AD_GROUPS ***
DESC AD_SYNC_SERVICE.AD_GROUPS;

PROMPT *** Структура таблицы AD_SYNC_LOG ***
DESC AD_SYNC_SERVICE.AD_SYNC_LOG;

-- ============================================================================
-- ШАГ 4: РУЧНОЕ ТЕСТИРОВАНИЕ
-- ============================================================================

-- Тест конфигурации
BEGIN
  DECLARE
    l_config AD_SYNC_SERVICE.PKG_AD_SYNC.t_config_rec;
  BEGIN
    DBMS_OUTPUT.ENABLE(1000000);
    
    l_config := AD_SYNC_SERVICE.PKG_AD_SYNC.get_config();
    
    DBMS_OUTPUT.PUT_LINE('=== КОНФИГУРАЦИЯ AD SYNC ===');
    DBMS_OUTPUT.PUT_LINE('LDAP Host: ' || l_config.ldap_host);
    DBMS_OUTPUT.PUT_LINE('LDAP Port: ' || l_config.ldap_port);
    DBMS_OUTPUT.PUT_LINE('User Base DN: ' || l_config.user_base_dn);
    DBMS_OUTPUT.PUT_LINE('Group Base DN: ' || l_config.group_base_dn);
    DBMS_OUTPUT.PUT_LINE('Batch Size: ' || l_config.batch_size);
    DBMS_OUTPUT.PUT_LINE('Max Retries: ' || l_config.max_retries);
    
    DBMS_OUTPUT.PUT_LINE('=== КОНФИГУРАЦИЯ УСПЕШНА ===');
  END;
END;
/

-- Тест генерации Session ID
BEGIN
  DECLARE
    l_session_id VARCHAR2(50);
  BEGIN
    DBMS_OUTPUT.ENABLE(1000000);
    
    FOR i IN 1..3 LOOP
      l_session_id := AD_SYNC_SERVICE.PKG_AD_SYNC.generate_session_id();
      DBMS_OUTPUT.PUT_LINE('Session ID #' || i || ': ' || l_session_id);
    END LOOP;
  END;
END;
/

-- Тест полной синхронизации (ОСТОРОЖНО - РЕАЛЬНАЯ СИНХРОНИЗАЦИЯ!)
BEGIN
  DBMS_OUTPUT.ENABLE(1000000);
  DBMS_OUTPUT.PUT_LINE('=== ЗАПУСК ПОЛНОЙ СИНХРОНИЗАЦИИ AD ===');
  DBMS_OUTPUT.PUT_LINE('Время начала: ' || TO_CHAR(SYSDATE, 'DD.MM.YYYY HH24:MI:SS'));
  
  AD_SYNC_SERVICE.PKG_AD_SYNC.sync_daily_full;
  
  DBMS_OUTPUT.PUT_LINE('Время окончания: ' || TO_CHAR(SYSDATE, 'DD.MM.YYYY HH24:MI:SS'));
  DBMS_OUTPUT.PUT_LINE('=== СИНХРОНИЗАЦИЯ ЗАВЕРШЕНА ===');
END;
/

-- ============================================================================
-- ШАГ 5: ПРОВЕРКА РЕЗУЛЬТАТОВ
-- ============================================================================

-- Смотрим последние логи синхронизации
SELECT sync_session_id, sync_type, sync_operation, sync_status,
       records_processed, records_success, records_error,
       TO_CHAR(start_time, 'DD.MM.YYYY HH24:MI:SS') as start_time,
       TO_CHAR(end_time, 'DD.MM.YYYY HH24:MI:SS') as end_time,
       duration_seconds,
       SUBSTR(error_message, 1, 100) as error_preview
FROM AD_SYNC_SERVICE.AD_SYNC_LOG 
ORDER BY created_date DESC
FETCH FIRST 10 ROWS ONLY;

-- Статистика пользователей по статусам
SELECT sync_status, COUNT(*) as user_count,
       TO_CHAR(MAX(last_sync_date), 'DD.MM.YYYY HH24:MI:SS') as last_sync
FROM AD_SYNC_SERVICE.AD_USERS 
GROUP BY sync_status
ORDER BY sync_status;

-- Статистика групп по статусам  
SELECT sync_status, COUNT(*) as group_count,
       TO_CHAR(MAX(last_sync_date), 'DD.MM.YYYY HH24:MI:SS') as last_sync
FROM AD_SYNC_SERVICE.AD_GROUPS
GROUP BY sync_status
ORDER BY sync_status;

-- Последние синхронизированные пользователи
SELECT user_id, sam_account_name, sync_status,
       TO_CHAR(last_sync_date, 'DD.MM.YYYY HH24:MI:SS') as last_sync,
       created_by
FROM AD_SYNC_SERVICE.AD_USERS
WHERE last_sync_date >= SYSDATE - 1
ORDER BY last_sync_date DESC
FETCH FIRST 5 ROWS ONLY;