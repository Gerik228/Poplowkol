
-- Создаем таблицу для хранения атрибутов пользователей
CREATE TABLE ad_user_attributes (
  attribute_id       NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id            VARCHAR2(100) NOT NULL,
  attribute_name     VARCHAR2(256) NOT NULL,
  attribute_value    CLOB,
  created_date       DATE DEFAULT SYSDATE,
  created_by         VARCHAR2(100) DEFAULT USER,
  sync_session_id    VARCHAR2(50),
  CONSTRAINT fk_ad_user_attr_user_id FOREIGN KEY (user_id) REFERENCES ad_users(user_id)
);

-- Создаем таблицу для хранения атрибутов групп  
CREATE TABLE ad_group_attributes (
  attribute_id       NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  group_id           VARCHAR2(100) NOT NULL,
  attribute_name     VARCHAR2(256) NOT NULL,
  attribute_value    CLOB,
  created_date       DATE DEFAULT SYSDATE,
  created_by         VARCHAR2(100) DEFAULT USER,
  sync_session_id    VARCHAR2(50),
  CONSTRAINT fk_ad_group_attr_group_id FOREIGN KEY (group_id) REFERENCES ad_groups(group_id)
);

-- Индексы для производительности
CREATE INDEX idx_ad_user_attr_user_id ON ad_user_attributes(user_id);
CREATE INDEX idx_ad_user_attr_name ON ad_user_attributes(attribute_name);
CREATE INDEX idx_ad_group_attr_group_id ON ad_group_attributes(group_id);
CREATE INDEX idx_ad_group_attr_name ON ad_group_attributes(attribute_name);

-- ============================================================================
-- ОБНОВЛЕННАЯ СПЕЦИФИКАЦИЯ ПАКЕТА С НОВЫМИ ФУНКЦИЯМИ
-- ============================================================================
CREATE OR REPLACE PACKAGE AD_SYNC_SERVICE.PKG_AD_SYNC AS

  -- КОНСТАНТЫ
  C_SUCCESS   CONSTANT VARCHAR2(10) := 'SUCCESS';
  C_ERROR     CONSTANT VARCHAR2(10) := 'ERROR';
  C_WARNING   CONSTANT VARCHAR2(10) := 'WARNING';
  C_ACTIVE    CONSTANT VARCHAR2(10) := 'ACTIVE';
  C_INACTIVE  CONSTANT VARCHAR2(10) := 'INACTIVE';

  -- ТИПЫ ДАННЫХ
  TYPE t_config_rec IS RECORD (
    ldap_host         VARCHAR2(256),
    ldap_port         NUMBER,
    user_base_dn      VARCHAR2(512),
    group_base_dn     VARCHAR2(512),
    bind_dn           VARCHAR2(512),
    bind_password     VARCHAR2(256),
    batch_size        NUMBER,
    user_filter       VARCHAR2(256),
    group_filter      VARCHAR2(256),
    timeout_seconds   NUMBER,
    max_retries       NUMBER
  );

  -- Тип для хранения атрибутов
  TYPE t_attribute_rec IS RECORD (
    name  VARCHAR2(256),
    value CLOB
  );
  
  TYPE t_attributes_table IS TABLE OF t_attribute_rec INDEX BY PLS_INTEGER;

  -- ФУНКЦИИ И ПРОЦЕДУРЫ
  FUNCTION get_config RETURN t_config_rec;
  FUNCTION generate_session_id RETURN VARCHAR2;
  
  -- Новые функции для работы с атрибутами
  FUNCTION get_all_ldap_attributes(
    p_session IN DBMS_LDAP.SESSION,
    p_entry IN DBMS_LDAP.MESSAGE
  ) RETURN t_attributes_table;
  
  FUNCTION get_ldap_attribute_value(
    p_session IN DBMS_LDAP.SESSION,
    p_entry IN DBMS_LDAP.MESSAGE,
    p_attribute_name IN VARCHAR2
  ) RETURN VARCHAR2;

  PROCEDURE log_sync_event(
    p_session_id    IN VARCHAR2,
    p_sync_type     IN VARCHAR2,
    p_operation     IN VARCHAR2,
    p_object_id     IN VARCHAR2,
    p_status        IN VARCHAR2,
    p_start_time    IN TIMESTAMP,
    p_end_time      IN TIMESTAMP DEFAULT SYSTIMESTAMP,
    p_records_proc  IN NUMBER DEFAULT 0,
    p_records_succ  IN NUMBER DEFAULT 0,
    p_records_err   IN NUMBER DEFAULT 0,
    p_error_msg     IN VARCHAR2 DEFAULT NULL,
    p_detailed_log  IN CLOB DEFAULT NULL
  );

  PROCEDURE sync_users_only;
  PROCEDURE sync_groups_only;
  PROCEDURE sync_memberships_only;
  PROCEDURE sync_daily_full;

END PKG_AD_SYNC;
/

-- ============================================================================
-- ОБНОВЛЕННОЕ ТЕЛО ПАКЕТА С ФУНКЦИЯМИ ПОЛУЧЕНИЯ ВСЕХ АТРИБУТОВ
-- ============================================================================
CREATE OR REPLACE PACKAGE BODY AD_SYNC_SERVICE.PKG_AD_SYNC AS

  -- ===========================================================================
  -- СОБСТВЕННАЯ ФУНКЦИЯ ЗАДЕРЖКИ
  -- ===========================================================================
  PROCEDURE custom_sleep(p_seconds IN NUMBER) IS
    l_start_time DATE;
    l_current_time DATE;
    l_dummy NUMBER;
  BEGIN
    l_start_time := SYSDATE;
    LOOP
      SELECT 1 INTO l_dummy FROM dual WHERE ROWNUM = 1;
      l_current_time := SYSDATE;
      EXIT WHEN (l_current_time - l_start_time) * 24 * 3600 >= p_seconds;
    END LOOP;
  END custom_sleep;

  -- ===========================================================================
  -- ИЗВЛЕЧЕНИЕ SAM ACCOUNT NAME ИЗ DN
  -- ===========================================================================
  FUNCTION extract_sam_from_dn(p_dn VARCHAR2) RETURN VARCHAR2 IS
    l_start_pos NUMBER;
    l_end_pos   NUMBER;
    l_result    VARCHAR2(256);
  BEGIN
    IF p_dn IS NULL THEN
      RETURN 'UNKNOWN_USER';
    END IF;
    
    l_start_pos := INSTR(UPPER(p_dn), 'CN=');
    IF l_start_pos > 0 THEN
      l_start_pos := l_start_pos + 3;
      l_end_pos := INSTR(p_dn, ',', l_start_pos);
      IF l_end_pos = 0 THEN
        l_end_pos := LENGTH(p_dn) + 1;
      END IF;
      l_result := TRIM(SUBSTR(p_dn, l_start_pos, l_end_pos - l_start_pos));
    ELSE
      l_result := 'USER_' || TO_CHAR(SYSDATE, 'HH24MISS');
    END IF;
    
    RETURN l_result;
  END extract_sam_from_dn;

  -- ===========================================================================
  -- НОВАЯ ФУНКЦИЯ: ПОЛУЧЕНИЕ КОНКРЕТНОГО АТРИБУТА ИЗ LDAP ЗАПИСИ
  -- ===========================================================================
  FUNCTION get_ldap_attribute_value(
    p_session IN DBMS_LDAP.SESSION,
    p_entry IN DBMS_LDAP.MESSAGE,
    p_attribute_name IN VARCHAR2
  ) RETURN VARCHAR2 IS
    l_values      DBMS_LDAP.STRING_COLLECTION;
    l_value_count NUMBER;
  BEGIN
    -- Получаем значения атрибута
    l_values := DBMS_LDAP.get_values(
      ld => p_session,
      ldapentry => p_entry,
      attr => p_attribute_name
    );
    
    -- Если есть значения, возвращаем первое
    l_value_count := DBMS_LDAP.count_values(l_values);
    IF l_value_count > 0 THEN
      RETURN l_values(l_values.FIRST);
    ELSE
      RETURN NULL;
    END IF;
    
  EXCEPTION
    WHEN OTHERS THEN
      RETURN NULL;
  END get_ldap_attribute_value;

  -- ===========================================================================
  -- НОВАЯ ФУНКЦИЯ: ПОЛУЧЕНИЕ ВСЕХ АТРИБУТОВ ИЗ LDAP ЗАПИСИ
  -- ===========================================================================
  FUNCTION get_all_ldap_attributes(
    p_session IN DBMS_LDAP.SESSION,
    p_entry IN DBMS_LDAP.MESSAGE
  ) RETURN t_attributes_table IS
    l_attributes    t_attributes_table;
    l_attr_name     VARCHAR2(256);
    l_attr_values   DBMS_LDAP.STRING_COLLECTION;
    l_value_count   NUMBER;
    l_ber_element   DBMS_LDAP.BER_ELEMENT;
    l_index         PLS_INTEGER := 1;
  BEGIN
    -- Получаем первый атрибут
    l_attr_name := DBMS_LDAP.first_attribute(
      ld => p_session,
      ldapentry => p_entry,
      ber_elem => l_ber_element
    );
    
    -- Проходим по всем атрибутам
    WHILE l_attr_name IS NOT NULL LOOP
      BEGIN
        -- Получаем значения атрибута
        l_attr_values := DBMS_LDAP.get_values(
          ld => p_session,
          ldapentry => p_entry,
          attr => l_attr_name
        );
        
        l_value_count := DBMS_LDAP.count_values(l_attr_values);
        
        -- Если атрибут имеет значения
        IF l_value_count > 0 THEN
          -- Если несколько значений, объединяем их через разделитель
          IF l_value_count = 1 THEN
            l_attributes(l_index).name := l_attr_name;
            l_attributes(l_index).value := l_attr_values(l_attr_values.FIRST);
          ELSE
            -- Для многозначных атрибутов объединяем через точку с запятой
            DECLARE
              l_combined_value CLOB;
              l_val_index PLS_INTEGER;
            BEGIN
              l_val_index := l_attr_values.FIRST;
              WHILE l_val_index IS NOT NULL LOOP
                IF l_combined_value IS NOT NULL THEN
                  l_combined_value := l_combined_value || '; ';
                END IF;
                l_combined_value := l_combined_value || l_attr_values(l_val_index);
                l_val_index := l_attr_values.NEXT(l_val_index);
              END LOOP;
              
              l_attributes(l_index).name := l_attr_name;
              l_attributes(l_index).value := l_combined_value;
            END;
          END IF;
          
          l_index := l_index + 1;
        END IF;
        
      EXCEPTION
        WHEN OTHERS THEN
          -- Игнорируем ошибки отдельных атрибутов
          NULL;
      END;
      
      -- Переходим к следующему атрибуту
      l_attr_name := DBMS_LDAP.next_attribute(
        ld => p_session,
        ldapentry => p_entry,
        ber_elem => l_ber_element
      );
    END LOOP;
    
    RETURN l_attributes;
    
  EXCEPTION
    WHEN OTHERS THEN
      RETURN l_attributes; -- Возвращаем что успели получить
  END get_all_ldap_attributes;

  -- ===========================================================================
  -- ФУНКЦИЯ ПОЛУЧЕНИЯ КОНФИГУРАЦИИ
  -- ===========================================================================
  FUNCTION get_config RETURN t_config_rec IS
    l_config t_config_rec;
  BEGIN
  
    l_config.timeout_seconds := 300;
    l_config.max_retries := 3;

    BEGIN
      FOR rec IN (
        SELECT config_name, config_value 
        FROM ad_sync_config 
        WHERE config_group IN ('LDAP', 'SYNC', 'FILTERS')
      ) LOOP
        CASE rec.config_name
          WHEN 'HOST' THEN l_config.ldap_host := rec.config_value;
          WHEN 'PORT' THEN l_config.ldap_port := TO_NUMBER(rec.config_value);
          WHEN 'USER_BASE_DN' THEN l_config.user_base_dn := rec.config_value;
          WHEN 'GROUP_BASE_DN' THEN l_config.group_base_dn := rec.config_value;
          WHEN 'BIND_DN' THEN l_config.bind_dn := rec.config_value;
          WHEN 'BIND_PASSWORD' THEN l_config.bind_password := rec.config_value;
          WHEN 'BATCH_SIZE' THEN l_config.batch_size := TO_NUMBER(rec.config_value);
          WHEN 'USER_FILTER' THEN l_config.user_filter := rec.config_value;
          WHEN 'GROUP_FILTER' THEN l_config.group_filter := rec.config_value;
          WHEN 'TIMEOUT_SECONDS' THEN l_config.timeout_seconds := TO_NUMBER(rec.config_value);
          WHEN 'MAX_RETRIES' THEN l_config.max_retries := TO_NUMBER(rec.config_value);
          ELSE NULL;
        END CASE;
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN NULL;
    END;

    RETURN l_config;
  END get_config;

  -- ===========================================================================
  -- ГЕНЕРАЦИЯ ID СЕССИИ
  -- ===========================================================================
  FUNCTION generate_session_id RETURN VARCHAR2 IS
  BEGIN
    RETURN 'SYNC_' || TO_CHAR(SYSDATE, 'YYYYMMDD_HH24MISS') || '_' || 
           LPAD(TRUNC(DBMS_RANDOM.VALUE(1000, 9999)), 4, '0');
  END generate_session_id;

  -- ===========================================================================
  -- ЛОГИРОВАНИЕ
  -- ===========================================================================
  PROCEDURE log_sync_event(
    p_session_id    IN VARCHAR2,
    p_sync_type     IN VARCHAR2,
    p_operation     IN VARCHAR2,
    p_object_id     IN VARCHAR2,
    p_status        IN VARCHAR2,
    p_start_time    IN TIMESTAMP,
    p_end_time      IN TIMESTAMP DEFAULT SYSTIMESTAMP,
    p_records_proc  IN NUMBER DEFAULT 0,
    p_records_succ  IN NUMBER DEFAULT 0,
    p_records_err   IN NUMBER DEFAULT 0,
    p_error_msg     IN VARCHAR2 DEFAULT NULL,
    p_detailed_log  IN CLOB DEFAULT NULL
  ) IS
    PRAGMA AUTONOMOUS_TRANSACTION;
  BEGIN
    INSERT INTO ad_sync_log (
      sync_session_id, sync_type, sync_operation, object_identifier, sync_status,
      start_time, end_time, duration_seconds, records_processed, records_success, 
      records_error, error_message, detailed_log, created_date, created_by
    ) VALUES (
      p_session_id, p_sync_type, p_operation, p_object_id, p_status,
      p_start_time, p_end_time, 
      CASE WHEN p_end_time > p_start_time 
           THEN EXTRACT(SECOND FROM (p_end_time - p_start_time))
           ELSE 0 END,
      p_records_proc, p_records_succ, p_records_err, 
      SUBSTR(p_error_msg, 1, 4000), p_detailed_log, SYSDATE, USER
    );
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN NULL;
  END log_sync_event;

  -- ===========================================================================
  -- РАСШИРЕННАЯ СИНХРОНИЗАЦИЯ ПОЛЬЗОВАТЕЛЕЙ СО ВСЕМИ АТРИБУТАМИ
  -- ===========================================================================
  PROCEDURE sync_users_only IS
    l_config        t_config_rec;
    l_session_id    VARCHAR2(50);
    l_start_time    TIMESTAMP;
    l_session       DBMS_LDAP.SESSION;
    l_retval        PLS_INTEGER;
    l_message       DBMS_LDAP.MESSAGE;
    l_entry         DBMS_LDAP.MESSAGE;
    l_dn            VARCHAR2(2000);
    l_sam_account   VARCHAR2(256);
    l_processed     NUMBER := 0;
    l_success       NUMBER := 0;
    l_errors        NUMBER := 0;
    l_retry_count   NUMBER := 0;
    l_attrs         DBMS_LDAP.STRING_COLLECTION;
    
    -- Переменные для работы с атрибутами
    l_all_attributes t_attributes_table;
    l_user_id        VARCHAR2(100);
    
    -- Часто используемые атрибуты пользователей (можешь добавлять/убирать!)
    l_display_name   VARCHAR2(512);
    l_email          VARCHAR2(512);
    l_department     VARCHAR2(512);
    l_title          VARCHAR2(512);
    l_phone          VARCHAR2(256);
    l_manager        VARCHAR2(512);
    l_office         VARCHAR2(256);
    l_company        VARCHAR2(256);
    
  BEGIN
    l_config := get_config();
    l_session_id := generate_session_id();
    l_start_time := SYSTIMESTAMP;

    log_sync_event(l_session_id, 'USERS', 'SYNC_START', 'BULK', 
                   C_SUCCESS, l_start_time);

    -- Помечаем всех пользователей как неактивных
    UPDATE ad_users 
    SET sync_status = C_INACTIVE, last_sync_date = SYSDATE,
        modified_by = USER, modified_date = SYSDATE;

    -- Очищаем старые атрибуты
    DELETE FROM ad_user_attributes;

    -- Главный цикл с повторными попытками
    WHILE l_retry_count < l_config.max_retries LOOP
      BEGIN
        l_session := DBMS_LDAP.init(l_config.ldap_host, l_config.ldap_port);
        l_retval := DBMS_LDAP.simple_bind_s(l_session, l_config.bind_dn, l_config.bind_password);
        
        IF l_retval = DBMS_LDAP.SUCCESS THEN
          l_retval := DBMS_LDAP.search_s(
            ld => l_session,
            base => l_config.user_base_dn,
            scope => DBMS_LDAP.SCOPE_SUBTREE,
            filter => l_config.user_filter,
            attrs => l_attrs, -- Пустой массив = ВСЕ атрибуты!
            attronly => 0,
            res => l_message
          );
          
          IF l_retval = DBMS_LDAP.SUCCESS THEN
            l_entry := DBMS_LDAP.first_entry(l_session, l_message);
            
            WHILE l_entry IS NOT NULL LOOP
              BEGIN
                l_dn := DBMS_LDAP.get_dn(l_session, l_entry);
                l_sam_account := extract_sam_from_dn(l_dn);
                l_user_id := 'U' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS') || '_' || l_processed;
                
                -- ===== ПОЛУЧАЕМ ОСНОВНЫЕ АТРИБУТЫ =====
                l_display_name := get_ldap_attribute_value(l_session, l_entry, 'displayName');
                l_email := get_ldap_attribute_value(l_session, l_entry, 'mail');
                l_department := get_ldap_attribute_value(l_session, l_entry, 'department');
                l_title := get_ldap_attribute_value(l_session, l_entry, 'title');
                l_phone := get_ldap_attribute_value(l_session, l_entry, 'telephoneNumber');
                l_manager := get_ldap_attribute_value(l_session, l_entry, 'manager');
                l_office := get_ldap_attribute_value(l_session, l_entry, 'physicalDeliveryOfficeName');
                l_company := get_ldap_attribute_value(l_session, l_entry, 'company');
                
                -- MERGE пользователя в основную таблицу
                MERGE INTO ad_users tgt
                USING (
                  SELECT l_sam_account as sam_account_name, l_dn as distinguished_name
                  FROM dual
                ) src ON (tgt.sam_account_name = src.sam_account_name)
                WHEN MATCHED THEN UPDATE SET
                  distinguished_name = src.distinguished_name,
                  sync_status = C_ACTIVE, last_sync_date = SYSDATE,
                  modified_by = USER, modified_date = SYSDATE
                WHEN NOT MATCHED THEN INSERT (
                  user_id, sam_account_name, distinguished_name, sync_status,
                  created_date, created_by, last_sync_date
                ) VALUES (
                  l_user_id, src.sam_account_name, src.distinguished_name, C_ACTIVE,
                  SYSDATE, USER, SYSDATE
                );
                
                -- ===== ПОЛУЧАЕМ ВСЕ АТРИБУТЫ =====
                l_all_attributes := get_all_ldap_attributes(l_session, l_entry);
                
                -- Сохраняем все атрибуты в отдельную таблицу
                FOR i IN 1..l_all_attributes.COUNT LOOP
                  BEGIN
                    INSERT INTO ad_user_attributes (
                      user_id, attribute_name, attribute_value, 
                      sync_session_id, created_date, created_by
                    ) VALUES (
                      l_user_id, l_all_attributes(i).name, l_all_attributes(i).value,
                      l_session_id, SYSDATE, USER
                    );
                  EXCEPTION
                    WHEN OTHERS THEN NULL; -- Игнорируем ошибки отдельных атрибутов
                  END;
                END LOOP;
                
                l_success := l_success + 1;
                
                -- Частые коммиты из-за большого объема данных
                IF MOD(l_success, l_config.batch_size) = 0 THEN
                  COMMIT;
                END IF;
                
              EXCEPTION
                WHEN OTHERS THEN
                  l_errors := l_errors + 1;
                  log_sync_event(l_session_id, 'USERS', 'USER_ERROR', 
                                l_sam_account, C_ERROR, l_start_time, 
                                p_error_msg => SQLERRM);
              END;
              
              l_processed := l_processed + 1;
              l_entry := DBMS_LDAP.next_entry(l_session, l_entry);
            END LOOP;
            
            EXIT; -- Успех - выходим из retry цикла
          END IF;
        END IF;
        
        l_retval := DBMS_LDAP.unbind_s(l_session);
        
      EXCEPTION
        WHEN OTHERS THEN
          l_retry_count := l_retry_count + 1;
          
          IF l_session IS NOT NULL THEN
            BEGIN
              l_retval := DBMS_LDAP.unbind_s(l_session);
            EXCEPTION WHEN OTHERS THEN NULL;
            END;
          END IF;
          
          IF l_retry_count >= l_config.max_retries THEN
            log_sync_event(l_session_id, 'USERS', 'LDAP_FINAL_ERROR', 
                          'CONNECTION', C_ERROR, l_start_time, p_error_msg => SQLERRM);
            RAISE;
          ELSE
            log_sync_event(l_session_id, 'USERS', 'RETRY_' || l_retry_count,
                          'CONNECTION', C_WARNING, l_start_time, p_error_msg => SQLERRM);
            custom_sleep(2);
          END IF;
      END;
    END LOOP;

    COMMIT;
    DELETE FROM ad_users WHERE sync_status = C_INACTIVE;
    COMMIT;

    log_sync_event(l_session_id, 'USERS', 'SYNC_COMPLETE', 'BULK',
                   CASE WHEN l_errors = 0 THEN C_SUCCESS ELSE C_WARNING END,
                   l_start_time, p_records_proc => l_processed,
                   p_records_succ => l_success, p_records_err => l_errors);

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      log_sync_event(l_session_id, 'USERS', 'SYNC_FAILED', 'BULK',
                     C_ERROR, l_start_time, p_error_msg => SQLERRM);
      RAISE;
  END sync_users_only;

  -- ===========================================================================
  -- РАСШИРЕННАЯ СИНХРОНИЗАЦИЯ ГРУПП СО ВСЕМИ АТРИБУТАМИ
  -- ===========================================================================
  PROCEDURE sync_groups_only IS
    l_config        t_config_rec;
    l_session_id    VARCHAR2(50);
    l_start_time    TIMESTAMP;
    l_session       DBMS_LDAP.SESSION;
    l_retval        PLS_INTEGER;
    l_message       DBMS_LDAP.MESSAGE;
    l_entry         DBMS_LDAP.MESSAGE;
    l_dn            VARCHAR2(2000);
    l_group_name    VARCHAR2(256);
    l_processed     NUMBER := 0;
    l_success       NUMBER := 0;
    l_errors        NUMBER := 0;
    l_attrs         DBMS_LDAP.STRING_COLLECTION;
    
    -- Переменные для работы с атрибутами групп
    l_all_attributes t_attributes_table;
    l_group_id       VARCHAR2(100);
    l_description    VARCHAR2(1000);
    l_group_type     VARCHAR2(256);
    
  BEGIN
    l_config := get_config();
    l_session_id := generate_session_id();
    l_start_time := SYSTIMESTAMP;

    log_sync_event(l_session_id, 'GROUPS', 'SYNC_START', 'BULK', 
                   C_SUCCESS, l_start_time);

    UPDATE ad_groups 
    SET sync_status = C_INACTIVE, last_sync_date = SYSDATE,
        modified_by = USER, modified_date = SYSDATE;
        
    -- Очищаем старые атрибуты групп
    DELETE FROM ad_group_attributes;

    BEGIN
      l_session := DBMS_LDAP.init(l_config.ldap_host, l_config.ldap_port);
      l_retval := DBMS_LDAP.simple_bind_s(l_session, l_config.bind_dn, l_config.bind_password);
      
      IF l_retval = DBMS_LDAP.SUCCESS THEN
        l_retval := DBMS_LDAP.search_s(
          ld => l_session,
          base => l_config.group_base_dn,
          scope => DBMS_LDAP.SCOPE_SUBTREE,
          filter => l_config.group_filter,
          attrs => l_attrs, -- Все атрибуты!
          attronly => 0,
          res => l_message
        );
        
        IF l_retval = DBMS_LDAP.SUCCESS THEN
          l_entry := DBMS_LDAP.first_entry(l_session, l_message);
          
          WHILE l_entry IS NOT NULL LOOP
            BEGIN
              l_dn := DBMS_LDAP.get_dn(l_session, l_entry);
              l_group_name := extract_sam_from_dn(l_dn);
              l_group_id := 'G' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS') || '_' || l_processed;
              
              -- Получаем основные атрибуты группы
              l_description := get_ldap_attribute_value(l_session, l_entry, 'description');
              l_group_type := get_ldap_attribute_value(l_session, l_entry, 'groupType');
              
              MERGE INTO ad_groups tgt
              USING (
                SELECT l_group_name as sam_account_name, l_dn as distinguished_name
                FROM dual
              ) src ON (tgt.sam_account_name = src.sam_account_name)
              WHEN MATCHED THEN UPDATE SET
                distinguished_name = src.distinguished_name,
                sync_status = C_ACTIVE, last_sync_date = SYSDATE,
                modified_by = USER, modified_date = SYSDATE
              WHEN NOT MATCHED THEN INSERT (
                group_id, sam_account_name, distinguished_name, sync_status,
                created_date, created_by
              ) VALUES (
                l_group_id, src.sam_account_name, src.distinguished_name, C_ACTIVE,
                SYSDATE, USER
              );
              
              -- Получаем все атрибуты группы
              l_all_attributes := get_all_ldap_attributes(l_session, l_entry);
              
              -- Сохраняем все атрибуты
              FOR i IN 1..l_all_attributes.COUNT LOOP
                BEGIN
                  INSERT INTO ad_group_attributes (
                    group_id, attribute_name, attribute_value, 
                    sync_session_id, created_date, created_by
                  ) VALUES (
                    l_group_id, l_all_attributes(i).name, l_all_attributes(i).value,
                    l_session_id, SYSDATE, USER
                  );
                EXCEPTION
                  WHEN OTHERS THEN NULL;
                END;
              END LOOP;
              
              l_success := l_success + 1;
              
              IF MOD(l_success, l_config.batch_size) = 0 THEN
                COMMIT;
              END IF;
              
            EXCEPTION
              WHEN OTHERS THEN
                l_errors := l_errors + 1;
            END;
            
            l_processed := l_processed + 1;
            l_entry := DBMS_LDAP.next_entry(l_session, l_entry);
          END LOOP;
        END IF;
      END IF;
      
      l_retval := DBMS_LDAP.unbind_s(l_session);
      
    EXCEPTION
      WHEN OTHERS THEN
        IF l_session IS NOT NULL THEN
          l_retval := DBMS_LDAP.unbind_s(l_session);
        END IF;
        RAISE;
    END;

    COMMIT;
    DELETE FROM ad_groups WHERE sync_status = C_INACTIVE;
    COMMIT;

    log_sync_event(l_session_id, 'GROUPS', 'SYNC_COMPLETE', 'BULK',
                   CASE WHEN l_errors = 0 THEN C_SUCCESS ELSE C_WARNING END,
                   l_start_time, p_records_proc => l_processed,
                   p_records_succ => l_success, p_records_err => l_errors);

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      log_sync_event(l_session_id, 'GROUPS', 'SYNC_FAILED', 'BULK',
                     C_ERROR, l_start_time, p_error_msg => SQLERRM);
      RAISE;
  END sync_groups_only;

  -- ===========================================================================
  -- ЗАГЛУШКА ЧЛЕНСТВА
  -- ===========================================================================
  PROCEDURE sync_memberships_only IS
    l_session_id VARCHAR2(50);
  BEGIN
    l_session_id := generate_session_id();
    log_sync_event(l_session_id, 'MEMBERSHIPS', 'SYNC_SKIPPED', 'BULK',
                   C_SUCCESS, SYSTIMESTAMP, p_error_msg => 'Not implemented');
  END sync_memberships_only;

  -- ===========================================================================
  -- ГЛАВНАЯ ПРОЦЕДУРА
  -- ===========================================================================
  PROCEDURE sync_daily_full IS
    l_session_id VARCHAR2(50);
    l_start_time TIMESTAMP;
  BEGIN
    l_session_id := generate_session_id();
    l_start_time := SYSTIMESTAMP;

    log_sync_event(l_session_id, 'FULL_SYNC', 'DAILY_START', 'ALL',
                   C_SUCCESS, l_start_time);

    BEGIN
      sync_users_only();
      sync_groups_only();
      sync_memberships_only();

      log_sync_event(l_session_id, 'FULL_SYNC', 'DAILY_COMPLETE', 'ALL',
                     C_SUCCESS, l_start_time);
    EXCEPTION
      WHEN OTHERS THEN
        log_sync_event(l_session_id, 'FULL_SYNC', 'DAILY_FAILED', 'ALL',
                       C_ERROR, l_start_time, p_error_msg => SQLERRM);
        RAISE;
    END;
  END sync_daily_full;

END PKG_AD_SYNC;
/

-- ============================================================================
-- ПОЛЕЗНЫЕ ЗАПРОСЫ ДЛЯ ПРОСМОТРА АТРИБУТОВ
-- ============================================================================

-- Посмотреть все атрибуты конкретного пользователя
/*
SELECT u.sam_account_name, 
       ua.attribute_name, 
       SUBSTR(ua.attribute_value, 1, 100) as attribute_value_preview
FROM ad_users u
JOIN ad_user_attributes ua ON u.user_id = ua.user_id
WHERE u.sam_account_name = 'ivan.petrov'
ORDER BY ua.attribute_name;
*/

-- Посмотреть самые популярные атрибуты пользователей
/*
SELECT attribute_name, COUNT(*) as users_count
FROM ad_user_attributes
GROUP BY attribute_name
ORDER BY COUNT(*) DESC;
*/

-- Посмотреть все атрибуты конкретной группы
/*
SELECT g.sam_account_name, 
       ga.attribute_name, 
       SUBSTR(ga.attribute_value, 1, 100) as attribute_value_preview
FROM ad_groups g
JOIN ad_group_attributes ga ON g.group_id = ga.group_id
WHERE g.sam_account_name = 'Domain Admins'
ORDER BY ga.attribute_name;
*/

-- ============================================================================
-- ЗАПУСК И ТЕСТИРОВАНИЕ
-- ============================================================================

-- Проверяем компиляцию
SELECT object_name, object_type, status 
FROM user_objects 
WHERE object_name = 'PKG_AD_SYNC'
ORDER BY object_type;

-- Запускаем синхронизацию
BEGIN
  DBMS_OUTPUT.ENABLE(1000000);
  DBMS_OUTPUT.PUT_LINE('=== ЗАПУСК РАСШИРЕННОЙ AD SYNC ===');
  
  AD_SYNC_SERVICE.PKG_AD_SYNC.sync_daily_full;
  
  DBMS_OUTPUT.PUT_LINE('=== ЗАВЕРШЕНО ===');
END;
/