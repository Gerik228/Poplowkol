


-- ============================================================================
-- ИСПРАВЛЕННОЕ СОЗДАНИЕ ТАБЛИЦ (БЕЗ ОШИБОК ВНЕШНИХ КЛЮЧЕЙ)
-- ============================================================================

-- Сначала удаляем все таблицы если есть
DROP TABLE ad_user_extended_attributes CASCADE CONSTRAINTS;
DROP TABLE ad_users CASCADE CONSTRAINTS;
DROP TABLE ad_departments CASCADE CONSTRAINTS;

-- ============================================================================
-- ШАГ 1: СОЗДАЕМ ТАБЛИЦУ ПОДРАЗДЕЛЕНИЙ (СНАЧАЛА!)
-- ============================================================================

CREATE TABLE ad_departments (
  department_id       VARCHAR2(100) PRIMARY KEY,
  department_code     VARCHAR2(50) UNIQUE,
  department_name     VARCHAR2(500),
  parent_department   VARCHAR2(100),
  distinguished_name  VARCHAR2(1000),
  level_number        NUMBER,
  full_path          VARCHAR2(2000),
  sync_status        VARCHAR2(10) DEFAULT 'ACTIVE',
  created_date       DATE DEFAULT SYSDATE,
  created_by         VARCHAR2(100) DEFAULT USER,
  modified_date      DATE,
  modified_by        VARCHAR2(100),
  last_sync_date     DATE,
  CONSTRAINT chk_dept_sync_status CHECK (sync_status IN ('ACTIVE', 'INACTIVE'))
);

-- ============================================================================
-- ШАГ 2: СОЗДАЕМ ТАБЛИЦУ ПОЛЬЗОВАТЕЛЕЙ (ТЕПЕРЬ МОЖНО СО ССЫЛКОЙ НА ОТДЕЛЫ)
-- ============================================================================

CREATE TABLE ad_users (
  -- ОСНОВНЫЕ ПОЛЯ
  user_id             VARCHAR2(100) PRIMARY KEY,
  sam_account_name    VARCHAR2(256) UNIQUE NOT NULL,
  distinguished_name  VARCHAR2(1000),
  
  -- АТРИБУТЫ ПОЛЬЗОВАТЕЛЕЙ
  display_name        VARCHAR2(500),  -- ФИО пользователя
  description_field   VARCHAR2(1000), -- описание/отдел
  email_address       VARCHAR2(256),  -- email
  phone_number        VARCHAR2(50),   -- рабочий телефон
  city_location       VARCHAR2(100),  -- город
  employee_id         VARCHAR2(50),   -- табельный номер
  department_name     VARCHAR2(500),  -- название отдела
  department_code     VARCHAR2(50),   -- код отдела
  street_address      VARCHAR2(500),  -- адрес
  job_title           VARCHAR2(256),  -- должность
  company_name        VARCHAR2(256),  -- организация
  manager_dn          VARCHAR2(1000), -- DN руководителя
  manager_name        VARCHAR2(500),  -- имя руководителя
  
  -- ДОПОЛНИТЕЛЬНЫЕ ПОЛЯ
  user_principal_name VARCHAR2(256),
  telephone_number    VARCHAR2(50),
  mobile_number       VARCHAR2(50),
  office_location     VARCHAR2(256),
  when_created        DATE,
  account_control     NUMBER,
  
  -- СВЯЗЬ С ПОДРАЗДЕЛЕНИЕМ
  department_id       VARCHAR2(100),
  
  -- СЛУЖЕБНЫЕ ПОЛЯ
  sync_status         VARCHAR2(10) DEFAULT 'ACTIVE',
  created_date        DATE DEFAULT SYSDATE,
  created_by          VARCHAR2(100) DEFAULT USER,
  modified_date       DATE,
  modified_by         VARCHAR2(100),
  last_sync_date      DATE,
  
  -- ОГРАНИЧЕНИЯ
  CONSTRAINT chk_user_sync_status CHECK (sync_status IN ('ACTIVE', 'INACTIVE')),
  CONSTRAINT fk_user_dept FOREIGN KEY (department_id) REFERENCES ad_departments(department_id)
);

-- ============================================================================
-- ШАГ 3: СОЗДАЕМ ТАБЛИЦУ РАСШИРЕННЫХ АТРИБУТОВ
-- ============================================================================

CREATE TABLE ad_user_extended_attributes (
  attribute_id       NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id            VARCHAR2(100) NOT NULL,
  attribute_name     VARCHAR2(256) NOT NULL,
  attribute_value    CLOB,
  created_date       DATE DEFAULT SYSDATE,
  created_by         VARCHAR2(100) DEFAULT USER,
  sync_session_id    VARCHAR2(50),
  CONSTRAINT fk_ext_attr_user FOREIGN KEY (user_id) REFERENCES ad_users(user_id),
  CONSTRAINT uk_user_attr_name UNIQUE (user_id, attribute_name)
);

-- ============================================================================
-- ШАГ 4: СОЗДАЕМ ИНДЕКСЫ ДЛЯ ПРОИЗВОДИТЕЛЬНОСТИ
-- ============================================================================

-- Индексы для пользователей
CREATE INDEX idx_users_sam_account ON ad_users(sam_account_name);
CREATE INDEX idx_users_email ON ad_users(email_address);
CREATE INDEX idx_users_employee_id ON ad_users(employee_id);
CREATE INDEX idx_users_dept_code ON ad_users(department_code);
CREATE INDEX idx_users_sync_status ON ad_users(sync_status);
CREATE INDEX idx_users_last_sync ON ad_users(last_sync_date);

-- Индексы для подразделений
CREATE INDEX idx_departments_code ON ad_departments(department_code);
CREATE INDEX idx_departments_name ON ad_departments(department_name);
CREATE INDEX idx_departments_sync ON ad_departments(sync_status);

-- Индексы для расширенных атрибутов
CREATE INDEX idx_ext_attr_user_id ON ad_user_extended_attributes(user_id);
CREATE INDEX idx_ext_attr_name ON ad_user_extended_attributes(attribute_name);

-- ============================================================================
-- ШАГ 5: СОЗДАЕМ ТАБЛИЦУ ЛОГОВ ЕСЛИ ЕЁ НЕТ
-- ============================================================================

CREATE TABLE ad_sync_log (
  log_id              NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  sync_session_id     VARCHAR2(50) NOT NULL,
  sync_type           VARCHAR2(50),
  sync_operation      VARCHAR2(100),
  object_identifier   VARCHAR2(500),
  sync_status         VARCHAR2(10),
  start_time          TIMESTAMP,
  end_time            TIMESTAMP,
  duration_seconds    NUMBER,
  records_processed   NUMBER DEFAULT 0,
  records_success     NUMBER DEFAULT 0,
  records_error       NUMBER DEFAULT 0,
  error_message       VARCHAR2(4000),
  detailed_log        CLOB,
  created_date        DATE DEFAULT SYSDATE,
  created_by          VARCHAR2(100) DEFAULT USER
);

CREATE INDEX idx_sync_log_session ON ad_sync_log(sync_session_id);
CREATE INDEX idx_sync_log_type ON ad_sync_log(sync_type);
CREATE INDEX idx_sync_log_status ON ad_sync_log(sync_status);
CREATE INDEX idx_sync_log_date ON ad_sync_log(created_date);

-- ============================================================================
-- ШАГ 6: ПРОВЕРЯЕМ ЧТО ВСЁ СОЗДАЛОСЬ
-- ============================================================================

-- Проверяем таблицы
SELECT table_name, 
       TO_CHAR(created, 'DD.MM.YYYY HH24:MI:SS') as created_time
FROM user_tables 
WHERE table_name IN ('AD_USERS', 'AD_DEPARTMENTS', 'AD_USER_EXTENDED_ATTRIBUTES', 'AD_SYNC_LOG')
ORDER BY table_name;

-- Проверяем структуру основной таблицы
SELECT column_name, data_type, data_length, nullable
FROM user_tab_columns
WHERE table_name = 'AD_USERS'
ORDER BY column_id;

-- Проверяем внешние ключи
SELECT constraint_name, constraint_type, table_name, r_constraint_name
FROM user_constraints
WHERE table_name IN ('AD_USERS', 'AD_USER_EXTENDED_ATTRIBUTES')
AND constraint_type = 'R';

-- ============================================================================
-- ШАГ 7: ДОБАВЛЯЕМ ТЕСТОВЫЕ ДАННЫЕ ДЛЯ ПРОВЕРКИ
-- ============================================================================

-- Тестовое подразделение
INSERT INTO ad_departments (
  department_id, department_code, department_name, sync_status
) VALUES (
  'DEPT_TEST_001', 'TEST_DEPT', 'Тестовое подразделение', 'ACTIVE'
);

-- Тестовый пользователь
INSERT INTO ad_users (
  user_id, sam_account_name, display_name, email_address, 
  department_code, department_id, sync_status
) VALUES (
  'USER_TEST_001', 'test.user', 'Тестовый Пользователь', 'test@company.com',
  'TEST_DEPT', 'DEPT_TEST_001', 'ACTIVE'
);

-- Тестовый атрибут
INSERT INTO ad_user_extended_attributes (
  user_id, attribute_name, attribute_value
) VALUES (
  'USER_TEST_001', 'department', 'Тестовое подразделение'
);

COMMIT;

-- Проверяем что данные вставились
SELECT u.sam_account_name, u.display_name, u.email_address, 
       d.department_name, u.sync_status
FROM ad_users u
LEFT JOIN ad_departments d ON u.department_id = d.department_id
WHERE u.user_id = 'USER_TEST_001';

-- Удаляем тестовые данные
DELETE FROM ad_user_extended_attributes WHERE user_id = 'USER_TEST_001';
DELETE FROM ad_users WHERE user_id = 'USER_TEST_001';
DELETE FROM ad_departments WHERE department_id = 'DEPT_TEST_001';
COMMIT;

-- ============================================================================
-- ГОТОВО! ТЕПЕРЬ МОЖНО СОЗДАВАТЬ ПАКЕТ
-- ============================================================================

DBMS_OUTPUT.PUT_LINE('======================================');
DBMS_OUTPUT.PUT_LINE('ВСЕ ТАБЛИЦЫ СОЗДАНЫ УСПЕШНО!');
DBMS_OUTPUT.PUT_LINE('======================================');
DBMS_OUTPUT.PUT_LINE('Создано:');
DBMS_OUTPUT.PUT_LINE('- ad_departments (подразделения)');
DBMS_OUTPUT.PUT_LINE('- ad_users (пользователи)');
DBMS_OUTPUT.PUT_LINE('- ad_user_extended_attributes (атрибуты)');
DBMS_OUTPUT.PUT_LINE('- ad_sync_log (логи синхронизации)');
DBMS_OUTPUT.PUT_LINE('======================================');
DBMS_OUTPUT.PUT_LINE('Теперь можно создавать пакет PKG_AD_SYNC');
DBMS_OUTPUT.PUT_LINE('======================================');














DROP TABLE ad_users CASCADE CONSTRAINTS;

-- Создаем таблицу заново с правильной структурой
CREATE TABLE ad_users (
  -- ОСНОВНЫЕ ПОЛЯ
  user_id             VARCHAR2(100) PRIMARY KEY,
  sam_account_name    VARCHAR2(256) UNIQUE NOT NULL,
  distinguished_name  VARCHAR2(1000),
  

  display_name        VARCHAR2(500),  -- name (ФИО)
  description_field   VARCHAR2(1000), -- description (отдел)  
  email_address       VARCHAR2(256),  -- mail (почта)
  phone_number        VARCHAR2(50),   -- ipPhone (номер телефона)
  city_location       VARCHAR2(100),  -- l (город)
  employee_id         VARCHAR2(50),   -- employeeID (id пользователя)
  department_name     VARCHAR2(500),  -- department (его департамент)
  department_code     VARCHAR2(50),   -- PSKBKodDivision (код департамента)
  street_address      VARCHAR2(500),  -- streetAddress (улица)
  job_title           VARCHAR2(256),  -- title (должность)
  company_name        VARCHAR2(256),  -- company (где находится)
  manager_dn          VARCHAR2(1000), -- manager (DN менеджера)
  manager_name        VARCHAR2(500), 
  -- ДОПОЛНИТЕЛЬНЫЕ ПОЛЕЗНЫЕ ПОЛЯ
  user_principal_name VARCHAR2(256),  -- userPrincipalName
  telephone_number    VARCHAR2(50),   -- telephoneNumber
  mobile_number       VARCHAR2(50),   -- mobile
  office_location     VARCHAR2(256),  -- physicalDeliveryOfficeName
  when_created        DATE,           -- whenCreated
  account_control     NUMBER,         -- userAccountControl
  
 
  department_id       VARCHAR2(100),
  
  -- СЛУЖЕБНЫЕ ПОЛЯ
  sync_status         VARCHAR2(10) DEFAULT 'ACTIVE',
  created_date        DATE DEFAULT SYSDATE,
  created_by          VARCHAR2(100) DEFAULT USER,
  modified_date       DATE,
  modified_by         VARCHAR2(100),
  last_sync_date      DATE,
  
  -- ОГРАНИЧЕНИЯ
  CONSTRAINT chk_sync_status CHECK (sync_status IN ('ACTIVE', 'INACTIVE')),
  CONSTRAINT fk_user_dept FOREIGN KEY (department_id) REFERENCES ad_departments(department_id)
);

-- Создаем индексы для производительности
CREATE INDEX idx_users_sam_account ON ad_users(sam_account_name);
CREATE INDEX idx_users_email ON ad_users(email_address);
CREATE INDEX idx_users_employee_id ON ad_users(employee_id);
CREATE INDEX idx_users_dept_code ON ad_users(department_code);
CREATE INDEX idx_users_sync_status ON ad_users(sync_status);
CREATE INDEX idx_users_last_sync ON ad_users(last_sync_date);














CREATE TABLE ad_departments (
  department_id       VARCHAR2(100) PRIMARY KEY,
  department_code     VARCHAR2(50),   -- PSKBKodDivision
  department_name     VARCHAR2(500),  -- name/description
  parent_department   VARCHAR2(100),  -- для иерархии
  distinguished_name  VARCHAR2(1000),
  level_number        NUMBER,         -- уровень вложенности
  full_path          VARCHAR2(2000),  -- полный путь в иерархии
  sync_status        VARCHAR2(10) DEFAULT 'ACTIVE',
  created_date       DATE DEFAULT SYSDATE,
  created_by         VARCHAR2(100) DEFAULT USER,
  modified_date      DATE,
  modified_by        VARCHAR2(100),
  last_sync_date     DATE,
  CONSTRAINT fk_parent_dept FOREIGN KEY (parent_department) REFERENCES ad_departments(department_id)
);

-- Расширенная таблица пользователей с основными атрибутами
ALTER TABLE ad_users ADD (
  display_name        VARCHAR2(500),  -- name (ФИО)
  description_field   VARCHAR2(1000), -- description (отдел)  
  email_address       VARCHAR2(256),  -- mail
  phone_number        VARCHAR2(50),   -- ipPhone
  city_location       VARCHAR2(100),  -- l (город)
  employee_id         VARCHAR2(50),   -- employeeID
  department_name     VARCHAR2(500),  -- department
  department_code     VARCHAR2(50),   -- PSKBKodDivision
  street_address      VARCHAR2(500),  -- streetAddress
  job_title           VARCHAR2(256),  -- title
  company_name        VARCHAR2(256),  -- company
  manager_dn          VARCHAR2(1000), -- manager DN
  manager_name        VARCHAR2(500),  -- расшифрованное имя менеджера
  department_id       VARCHAR2(100),  -- связь с подразделением
  CONSTRAINT fk_user_dept FOREIGN KEY (department_id) REFERENCES ad_departments(department_id)
);

-- Гибкая таблица для дополнительных атрибутов (для будущих расширений)
CREATE TABLE ad_user_extended_attributes (
  attribute_id       NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id            VARCHAR2(100) NOT NULL,
  attribute_name     VARCHAR2(256) NOT NULL,
  attribute_value    CLOB,
  created_date       DATE DEFAULT SYSDATE,
  sync_session_id    VARCHAR2(50),
  CONSTRAINT fk_ext_attr_user FOREIGN KEY (user_id) REFERENCES ad_users(user_id),
  CONSTRAINT uk_user_attr_name UNIQUE (user_id, attribute_name)
);

-- Индексы для производительности
CREATE INDEX idx_users_dept_code ON ad_users(department_code);
CREATE INDEX idx_users_employee_id ON ad_users(employee_id);
CREATE INDEX idx_users_email ON ad_users(email_address);
CREATE INDEX idx_departments_code ON ad_departments(department_code);

-- ============================================================================
-- ШАГ 2: ОБНОВЛЕННЫЙ ПАКЕТ ДЛЯ СИНХРОНИЗАЦИИ
-- ============================================================================

CREATE OR REPLACE PACKAGE AD_SYNC_SERVICE.PKG_AD_SYNC AS

  -- КОНСТАНТЫ
  C_SUCCESS   CONSTANT VARCHAR2(10) := 'SUCCESS';
  C_ERROR     CONSTANT VARCHAR2(10) := 'ERROR';
  C_WARNING   CONSTANT VARCHAR2(10) := 'WARNING';
  C_ACTIVE    CONSTANT VARCHAR2(10) := 'ACTIVE';
  C_INACTIVE  CONSTANT VARCHAR2(10) := 'INACTIVE';

  -- КОНФИГУРАЦИЯ
  TYPE t_config_rec IS RECORD (
    ldap_host         VARCHAR2(256),
    ldap_port         NUMBER,
    user_base_dn      VARCHAR2(512),
    group_base_dn     VARCHAR2(512),
    dept_base_dn      VARCHAR2(512),
    bind_dn           VARCHAR2(512),
    bind_password     VARCHAR2(256),
    batch_size        NUMBER,
    user_filter       VARCHAR2(256),
    group_filter      VARCHAR2(256),
    dept_filter       VARCHAR2(256),
    timeout_seconds   NUMBER,
    max_retries       NUMBER
  );

  -- МАССИВ НУЖНЫХ АТРИБУТОВ (ЛЕГКО РАСШИРЯТЬ!)
  TYPE t_required_attrs IS TABLE OF VARCHAR2(256) INDEX BY PLS_INTEGER;

  -- ФУНКЦИИ И ПРОЦЕДУРЫ
  FUNCTION get_config RETURN t_config_rec;
  FUNCTION generate_session_id RETURN VARCHAR2;
  FUNCTION get_required_user_attributes RETURN t_required_attrs;
  
  FUNCTION get_ldap_attribute_value(
    p_session IN DBMS_LDAP.SESSION,
    p_entry IN DBMS_LDAP.MESSAGE,
    p_attribute_name IN VARCHAR2
  ) RETURN VARCHAR2;

  PROCEDURE log_sync_event(
    p_session_id    IN VARCHAR2,
    p_sync_type     IN VARCHAR2,
    p_operation     IN VARCHAR2,
    p_object_id     IN VARCHAR2,
    p_status        IN VARCHAR2,
    p_start_time    IN TIMESTAMP,
    p_end_time      IN TIMESTAMP DEFAULT SYSTIMESTAMP,
    p_records_proc  IN NUMBER DEFAULT 0,
    p_records_succ  IN NUMBER DEFAULT 0,
    p_records_err   IN NUMBER DEFAULT 0,
    p_error_msg     IN VARCHAR2 DEFAULT NULL,
    p_detailed_log  IN CLOB DEFAULT NULL
  );

  PROCEDURE sync_departments;
  PROCEDURE sync_users_only;
  PROCEDURE sync_groups_only;
  PROCEDURE sync_daily_full;

END PKG_AD_SYNC;
/

-- ============================================================================
--
CREATE OR REPLACE PACKAGE BODY AD_SYNC_SERVICE.PKG_AD_SYNC AS

  -- ===========================================================================
  -- СОБСТВЕННАЯ ФУНКЦИЯ ЗАДЕРЖКИ
  -- ===========================================================================
  PROCEDURE custom_sleep(p_seconds IN NUMBER) IS
    l_start_time DATE;
    l_current_time DATE;
    l_dummy NUMBER;
  BEGIN
    l_start_time := SYSDATE;
    LOOP
      SELECT 1 INTO l_dummy FROM dual WHERE ROWNUM = 1;
      l_current_time := SYSDATE;
      EXIT WHEN (l_current_time - l_start_time) * 24 * 3600 >= p_seconds;
    END LOOP;
  END custom_sleep;

  -- ===========================================================================
  -- ФУНКЦИЯ СПИСКА НУЖНЫХ АТРИБУТОВ (ЗДЕСЬ ЛЕГКО ДОБАВЛЯТЬ НОВЫЕ!)
  -- ===========================================================================
  FUNCTION get_required_user_attributes RETURN t_required_attrs IS
    l_attrs t_required_attrs;
  BEGIN
    -- ТВОИ АТРИБУТЫ ИЗ СКРИНШОТА:
    l_attrs(1)  := 'sAMAccountName';      -- логин
    l_attrs(2)  := 'name';                -- ФИО
    l_attrs(3)  := 'description';         -- отдел
    l_attrs(4)  := 'mail';                -- почта
    l_attrs(5)  := 'ipPhone';             -- номер телефона
    l_attrs(6)  := 'l';                   -- город
    l_attrs(7)  := 'employeeID';          -- id пользователя
    l_attrs(8)  := 'department';          -- его департамент
    l_attrs(9)  := 'PSKBKodDivision';     -- код департамента
    l_attrs(10) := 'streetAddress';       -- улица
    l_attrs(11) := 'title';               -- должность
    l_attrs(12) := 'company';             -- где находится
    l_attrs(13) := 'manager';             -- данные менеджер
    
    -- ДОПОЛНИТЕЛЬНЫЕ ПОЛЕЗНЫЕ АТРИБУТЫ:
    l_attrs(14) := 'displayName';
    l_attrs(15) := 'distinguishedName';
    l_attrs(16) := 'userPrincipalName';
    l_attrs(17) := 'telephoneNumber';
    l_attrs(18) := 'mobile';
    l_attrs(19) := 'physicalDeliveryOfficeName';
    l_attrs(20) := 'whenCreated';
    l_attrs(21) := 'userAccountControl';
    
    -- ЗДЕСЬ ЛЕГКО ДОБАВЛЯТЬ НОВЫЕ:
    -- l_attrs(22) := 'новый_атрибут';
    
    RETURN l_attrs;
  END get_required_user_attributes;

  -- ===========================================================================
  -- ИЗВЛЕЧЕНИЕ SAM ACCOUNT NAME ИЗ DN
  -- ===========================================================================
  FUNCTION extract_sam_from_dn(p_dn VARCHAR2) RETURN VARCHAR2 IS
    l_start_pos NUMBER;
    l_end_pos   NUMBER;
    l_result    VARCHAR2(256);
  BEGIN
    IF p_dn IS NULL THEN
      RETURN 'UNKNOWN';
    END IF;
    
    l_start_pos := INSTR(UPPER(p_dn), 'CN=');
    IF l_start_pos > 0 THEN
      l_start_pos := l_start_pos + 3;
      l_end_pos := INSTR(p_dn, ',', l_start_pos);
      IF l_end_pos = 0 THEN
        l_end_pos := LENGTH(p_dn) + 1;
      END IF;
      l_result := TRIM(SUBSTR(p_dn, l_start_pos, l_end_pos - l_start_pos));
    ELSE
      l_result := 'UNKNOWN_' || TO_CHAR(SYSDATE, 'HH24MISS');
    END IF;
    
    RETURN l_result;
  END extract_sam_from_dn;

  -- ===========================================================================
  -- РАСШИФРОВКА DN МЕНЕДЖЕРА В ЧИТАЕМОЕ ИМЯ
  -- ===========================================================================
  FUNCTION resolve_manager_name(p_manager_dn VARCHAR2) RETURN VARCHAR2 IS
    l_name VARCHAR2(500);
  BEGIN
    IF p_manager_dn IS NULL THEN
      RETURN NULL;
    END IF;
    
    -- Пытаемся найти 
    BEGIN
      SELECT display_name INTO l_name
      FROM ad_users
      WHERE distinguished_name = p_manager_dn
      AND ROWNUM = 1;
      
      RETURN l_name;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        -- Если не найден, извлекаем имя из DN
        RETURN extract_sam_from_dn(p_manager_dn);
    END;
  END resolve_manager_name;

  -- ===========================================================================
  -- ПОЛУЧЕНИЕ КОНКРЕТНОГО АТРИБУТА ИЗ LDAP ЗАПИСИ
  -- ===========================================================================
  FUNCTION get_ldap_attribute_value(
    p_session IN DBMS_LDAP.SESSION,
    p_entry IN DBMS_LDAP.MESSAGE,
    p_attribute_name IN VARCHAR2
  ) RETURN VARCHAR2 IS
    l_values      DBMS_LDAP.STRING_COLLECTION;
    l_value_count NUMBER;
  BEGIN
    l_values := DBMS_LDAP.get_values(
      ld => p_session,
      ldapentry => p_entry,
      attr => p_attribute_name
    );
    
    l_value_count := DBMS_LDAP.count_values(l_values);
    IF l_value_count > 0 THEN
      RETURN l_values(l_values.FIRST);
    ELSE
      RETURN NULL;
    END IF;
    
  EXCEPTION
    WHEN OTHERS THEN
      RETURN NULL;
  END get_ldap_attribute_value;

  -- ===========================================================================
  -- ФУНКЦИЯ ПОЛУЧЕНИЯ КОНФИГУРАЦИИ
  -- ===========================================================================
  FUNCTION get_config RETURN t_config_rec IS
    l_config t_config_rec;
  BEGIN
    l_config.ldap_host := '';
    l_config.ldap_port := 389;
    l_config.user_base_dn := '';
    l_config.group_base_dn := '';
    l_config.dept_base_dn := ''; -- 
    l_config.';
    l_config.bind_password := '';
    l_config.batch_size := 50;
    l_config.user_filter := '(&(objectClass=person)(!(userAccountControl:1.2.840.113556.1.4.803:=2)))';
    l_config.group_filter := '(&(objectClass=group)(!(groupType:1.2.840.113556.1.4.803:=2147483648)))';
    l_config.dept_filter := '(&(objectClass=organizationalUnit)(name=*))';
    l_config.timeout_seconds := 300;
    l_config.max_retries := 3;

    RETURN l_config;
  END get_config;

  -- ===========================================================================
  -- ГЕНЕРАЦИЯ ID СЕССИИ
  -- ===========================================================================
  FUNCTION generate_session_id RETURN VARCHAR2 IS
  BEGIN
    RETURN 'SYNC_' || TO_CHAR(SYSDATE, 'YYYYMMDD_HH24MISS') || '_' || 
           LPAD(TRUNC(DBMS_RANDOM.VALUE(1000, 9999)), 4, '0');
  END generate_session_id;

  -- ===========================================================================
  -- ЛОГИРОВАНИЕ
  -- ===========================================================================
  PROCEDURE log_sync_event(
    p_session_id    IN VARCHAR2,
    p_sync_type     IN VARCHAR2,
    p_operation     IN VARCHAR2,
    p_object_id     IN VARCHAR2,
    p_status        IN VARCHAR2,
    p_start_time    IN TIMESTAMP,
    p_end_time      IN TIMESTAMP DEFAULT SYSTIMESTAMP,
    p_records_proc  IN NUMBER DEFAULT 0,
    p_records_succ  IN NUMBER DEFAULT 0,
    p_records_err   IN NUMBER DEFAULT 0,
    p_error_msg     IN VARCHAR2 DEFAULT NULL,
    p_detailed_log  IN CLOB DEFAULT NULL
  ) IS
    PRAGMA AUTONOMOUS_TRANSACTION;
  BEGIN
    INSERT INTO ad_sync_log (
      sync_session_id, sync_type, sync_operation, object_identifier, sync_status,
      start_time, end_time, duration_seconds, records_processed, records_success, 
      records_error, error_message, detailed_log, created_date, created_by
    ) VALUES (
      p_session_id, p_sync_type, p_operation, p_object_id, p_status,
      p_start_time, p_end_time, 
      CASE WHEN p_end_time > p_start_time 
           THEN EXTRACT(SECOND FROM (p_end_time - p_start_time))
           ELSE 0 END,
      p_records_proc, p_records_succ, p_records_err, 
      SUBSTR(p_error_msg, 1, 4000), p_detailed_log, SYSDATE, USER
    );
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN NULL;
  END log_sync_event;

  -- ===========================================================================
  -- СИНХРОНИЗАЦИЯ ПОДРАЗДЕЛЕНИЙ
  -- ===========================================================================
  PROCEDURE sync_departments IS
    l_config      t_config_rec;
    l_session_id  VARCHAR2(50);
    l_start_time  TIMESTAMP;
    l_session     DBMS_LDAP.SESSION;
    l_retval      PLS_INTEGER;
    l_message     DBMS_LDAP.MESSAGE;
    l_entry       DBMS_LDAP.MESSAGE;
    l_dn          VARCHAR2(2000);
    l_dept_name   VARCHAR2(500);
    l_dept_code   VARCHAR2(50);
    l_processed   NUMBER := 0;
    l_success     NUMBER := 0;
    l_errors      NUMBER := 0;
    l_attrs       DBMS_LDAP.STRING_COLLECTION;
    
  BEGIN
    l_config := get_config();
    l_session_id := generate_session_id();
    l_start_time := SYSTIMESTAMP;

    log_sync_event(l_session_id, 'DEPARTMENTS', 'SYNC_START', 'BULK', 
                   C_SUCCESS, l_start_time);

    UPDATE ad_departments 
    SET sync_status = C_INACTIVE, last_sync_date = SYSDATE;

    BEGIN
      l_session := DBMS_LDAP.init(l_config.ldap_host, l_config.ldap_port);
      l_retval := DBMS_LDAP.simple_bind_s(l_session, l_config.bind_dn, l_config.bind_password);
      
      IF l_retval = DBMS_LDAP.SUCCESS THEN
        l_retval := DBMS_LDAP.search_s(
          ld => l_session,
          base => l_config.dept_base_dn,
          scope => DBMS_LDAP.SCOPE_SUBTREE,
          filter => l_config.dept_filter,
          attrs => l_attrs,
          attronly => 0,
          res => l_message
        );
        
        IF l_retval = DBMS_LDAP.SUCCESS THEN
          l_entry := DBMS_LDAP.first_entry(l_session, l_message);
          
          WHILE l_entry IS NOT NULL LOOP
            BEGIN
              l_dn := DBMS_LDAP.get_dn(l_session, l_entry);
              l_dept_name := get_ldap_attribute_value(l_session, l_entry, 'name');
              l_dept_code := get_ldap_attribute_value(l_session, l_entry, 'PSKBKodDivision');
              
              IF l_dept_name IS NOT NULL THEN
                MERGE INTO ad_departments tgt
                USING (
                  SELECT 
                    'DEPT_' || l_processed as department_id,
                    l_dept_code as department_code,
                    l_dept_name as department_name,
                    l_dn as distinguished_name
                  FROM dual
                ) src ON (tgt.distinguished_name = src.distinguished_name)
                WHEN MATCHED THEN UPDATE SET
                  department_code = src.department_code,
                  department_name = src.department_name,
                  sync_status = C_ACTIVE,
                  last_sync_date = SYSDATE,
                  modified_by = USER,
                  modified_date = SYSDATE
                WHEN NOT MATCHED THEN INSERT (
                  department_id, department_code, department_name, 
                  distinguished_name, sync_status, created_date, created_by
                ) VALUES (
                  src.department_id, src.department_code, src.department_name,
                  src.distinguished_name, C_ACTIVE, SYSDATE, USER
                );
                
                l_success := l_success + 1;
              END IF;
              
            EXCEPTION
              WHEN OTHERS THEN
                l_errors := l_errors + 1;
            END;
            
            l_processed := l_processed + 1;
            l_entry := DBMS_LDAP.next_entry(l_session, l_entry);
          END LOOP;
        END IF;
      END IF;
      
      l_retval := DBMS_LDAP.unbind_s(l_session);
    END;

    COMMIT;
    log_sync_event(l_session_id, 'DEPARTMENTS', 'SYNC_COMPLETE', 'BULK',
                   C_SUCCESS, l_start_time, p_records_proc => l_processed,
                   p_records_succ => l_success, p_records_err => l_errors);
  END sync_departments;

  -- ===========================================================================
  -- СИНХРОНИЗАЦИЯ ПОЛЬЗОВАТЕЛЕЙ С НУЖНЫМИ АТРИБУТАМИ
  -- ===========================================================================
  PROCEDURE sync_users_only IS
    l_config        t_config_rec;
    l_session_id    VARCHAR2(50);
    l_start_time    TIMESTAMP;
    l_session       DBMS_LDAP.SESSION;
    l_retval        PLS_INTEGER;
    l_message       DBMS_LDAP.MESSAGE;
    l_entry         DBMS_LDAP.MESSAGE;
    l_dn            VARCHAR2(2000);
    l_sam_account   VARCHAR2(256);
    l_processed     NUMBER := 0;
    l_success       NUMBER := 0;
    l_errors        NUMBER := 0;
    l_retry_count   NUMBER := 0;
    l_attrs         DBMS_LDAP.STRING_COLLECTION;
    l_user_id       VARCHAR2(100);
    
    -- ПЕРЕМЕННЫЕ ДЛЯ ВСЕХ НУЖНЫХ АТРИБУТОВ:
    l_display_name      VARCHAR2(500);
    l_description       VARCHAR2(1000);
    l_email             VARCHAR2(256);
    l_ip_phone          VARCHAR2(50);
    l_city              VARCHAR2(100);
    l_employee_id       VARCHAR2(50);
    l_department        VARCHAR2(500);
    l_dept_code         VARCHAR2(50);
    l_street_address    VARCHAR2(500);
    l_job_title         VARCHAR2(256);
    l_company           VARCHAR2(256);
    l_manager_dn        VARCHAR2(1000);
    l_manager_name      VARCHAR2(500);
    l_department_id     VARCHAR2(100);
    
    -- МАССИВ ДОПОЛНИТЕЛЬНЫХ АТРИБУТОВ
    l_required_attrs    t_required_attrs;
    l_attr_value        VARCHAR2(4000);
    
  BEGIN
    l_config := get_config();
    l_session_id := generate_session_id();
    l_start_time := SYSTIMESTAMP;
    l_required_attrs := get_required_user_attributes();

    log_sync_event(l_session_id, 'USERS', 'SYNC_START', 'BULK', 
                   C_SUCCESS, l_start_time);

    -- Помечаем всех пользователей как неактивных
    UPDATE ad_users 
    SET sync_status = C_INACTIVE, last_sync_date = SYSDATE;

    -- Очищаем старые расширенные атрибуты
    DELETE FROM ad_user_extended_attributes;

    -- Главный цикл с повторными попытками
    WHILE l_retry_count < l_config.max_retries LOOP
      BEGIN
        l_session := DBMS_LDAP.init(l_config.ldap_host, l_config.ldap_port);
        l_retval := DBMS_LDAP.simple_bind_s(l_session, l_config.bind_dn, l_config.bind_password);
        
        IF l_retval = DBMS_LDAP.SUCCESS THEN
          l_retval := DBMS_LDAP.search_s(
            ld => l_session,
            base => l_config.user_base_dn,
            scope => DBMS_LDAP.SCOPE_SUBTREE,
            filter => l_config.user_filter,
            attrs => l_attrs, -- Все атрибуты
            attronly => 0,
            res => l_message
          );
          
          IF l_retval = DBMS_LDAP.SUCCESS THEN
            l_entry := DBMS_LDAP.first_entry(l_session, l_message);
            
            WHILE l_entry IS NOT NULL LOOP
              BEGIN
                l_dn := DBMS_LDAP.get_dn(l_session, l_entry);
                l_sam_account := get_ldap_attribute_value(l_session, l_entry, 'sAMAccountName');
                l_user_id := 'U' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS') || '_' || l_processed;
                
                -- ===== ПОЛУЧАЕМ ВСЕ ОСНОВНЫЕ АТРИБУТЫ =====
                l_display_name := get_ldap_attribute_value(l_session, l_entry, 'name');
                l_description := get_ldap_attribute_value(l_session, l_entry, 'description');
                l_email := get_ldap_attribute_value(l_session, l_entry, 'mail');
                l_ip_phone := get_ldap_attribute_value(l_session, l_entry, 'ipPhone');
                l_city := get_ldap_attribute_value(l_session, l_entry, 'l');
                l_employee_id := get_ldap_attribute_value(l_session, l_entry, 'employeeID');
                l_department := get_ldap_attribute_value(l_session, l_entry, 'department');
                l_dept_code := get_ldap_attribute_value(l_session, l_entry, 'PSKBKodDivision');
                l_street_address := get_ldap_attribute_value(l_session, l_entry, 'streetAddress');
                l_job_title := get_ldap_attribute_value(l_session, l_entry, 'title');
                l_company := get_ldap_attribute_value(l_session, l_entry, 'company');
                l_manager_dn := get_ldap_attribute_value(l_session, l_entry, 'manager');
                
                -- Расшифровываем имя менеджера
                l_manager_name := resolve_manager_name(l_manager_dn);
                
                -- Ищем ID подразделения по коду
                BEGIN
                  SELECT department_id INTO l_department_id
                  FROM ad_departments
                  WHERE department_code = l_dept_code
                  AND ROWNUM = 1;
                EXCEPTION
                  WHEN NO_DATA_FOUND THEN
                    l_department_id := NULL;
                END;
                
                -- ===== MERGE ПОЛЬЗОВАТЕЛЯ С ВСЕМИ АТРИБУТАМИ =====
                MERGE INTO ad_users tgt
                USING (
                  SELECT l_sam_account as sam_account_name, l_dn as distinguished_name
                  FROM dual
                ) src ON (tgt.sam_account_name = src.sam_account_name)
                WHEN MATCHED THEN UPDATE SET
                  distinguished_name = src.distinguished_name,
                  display_name = l_display_name,
                  description_field = l_description,
                  email_address = l_email,
                  phone_number = l_ip_phone,
                  city_location = l_city,
                  employee_id = l_employee_id,
                  department_name = l_department,
                  department_code = l_dept_code,
                  street_address = l_street_address,
                  job_title = l_job_title,
                  company_name = l_company,
                  manager_dn = l_manager_dn,
                  manager_name = l_manager_name,
                  department_id = l_department_id,
                  sync_status = C_ACTIVE,
                  last_sync_date = SYSDATE,
                  modified_by = USER,
                  modified_date = SYSDATE
                WHEN NOT MATCHED THEN INSERT (
                  user_id, sam_account_name, distinguished_name,
                  display_name, description_field, email_address, phone_number,
                  city_location, employee_id, department_name, department_code,
                  street_address, job_title, company_name, manager_dn, manager_name,
                  department_id, sync_status, created_date, created_by, last_sync_date
                ) VALUES (
                  l_user_id, src.sam_account_name, src.distinguished_name,
                  l_display_name, l_description, l_email, l_ip_phone,
                  l_city, l_employee_id, l_department, l_dept_code,
                  l_street_address, l_job_title, l_company, l_manager_dn, l_manager_name,
                  l_department_id, C_ACTIVE, SYSDATE, USER, SYSDATE
                );
                
                -- ===== СОХРАНЯЕМ ДОПОЛНИТЕЛЬНЫЕ АТРИБУТЫ =====
                FOR i IN 1..l_required_attrs.COUNT LOOP
                  BEGIN
                    l_attr_value := get_ldap_attribute_value(l_session, l_entry, l_required_attrs(i));
                    IF l_attr_value IS NOT NULL THEN
                      INSERT INTO ad_user_extended_attributes (
                        user_id, attribute_name, attribute_value, sync_session_id
                      ) VALUES (
                        l_user_id, l_required_attrs(i), l_attr_value, l_session_id
                      );
                    END IF;
                  EXCEPTION
                    WHEN OTHERS THEN NULL; -- Игнорируем ошибки отдельных атрибутов
                  END;
                END LOOP;
                
                l_success := l_success + 1;
                
                -- Частые коммиты
                IF MOD(l_success, l_config.batch_size) = 0 THEN
                  COMMIT;
                END IF;
                
              EXCEPTION
                WHEN OTHERS THEN
                  l_errors := l_errors + 1;
                  log_sync_event(l_session_id, 'USERS', 'USER_ERROR', 
                                l_sam_account, C_ERROR, l_start_time, 
                                p_error_msg => SQLERRM);
              END;
              
              l_processed := l_processed + 1;
              l_entry := DBMS_LDAP.next_entry(l_session, l_entry);
            END LOOP;
            
            EXIT; -- Успех - выходим из retry цикла
          END IF;
        END IF;
        
        l_retval := DBMS_LDAP.unbind_s(l_session);
        
      EXCEPTION
        WHEN OTHERS THEN
          l_retry_count := l_retry_count + 1;
          
          IF l_session IS NOT NULL THEN
            BEGIN
              l_retval := DBMS_LDAP.unbind_s(l_session);
            EXCEPTION WHEN OTHERS THEN NULL;
            END;
          END IF;
          
          IF l_retry_count >= l_config.max_retries THEN
            log_sync_event(l_session_id, 'USERS', 'LDAP_FINAL_ERROR', 
                          'CONNECTION', C_ERROR, l_start_time, p_error_msg => SQLERRM);
            RAISE;
          ELSE
            log_sync_event(l_session_id, 'USERS', 'RETRY_' || l_retry_count,
                          'CONNECTION', C_WARNING, l_start_time, p_error_msg => SQLERRM);
            custom_sleep(2);
          END IF;
      END;
    END LOOP;

    COMMIT;
    DELETE FROM ad_users WHERE sync_status = C_INACTIVE;
    COMMIT;

    log_sync_event(l_session_id, 'USERS', 'SYNC_COMPLETE', 'BULK',
                   CASE WHEN l_errors = 0 THEN C_SUCCESS ELSE C_WARNING END,
                   l_start_time, p_records_proc => l_processed,
                   p_records_succ => l_success, p_records_err => l_errors);

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      log_sync_event(l_session_id, 'USERS', 'SYNC_FAILED', 'BULK',
                     C_ERROR, l_start_time, p_error_msg => SQLERRM);
      RAISE;
  END sync_users_only;

  -- ===========================================================================
  -- СИНХРОНИЗАЦИЯ ГРУПП (УПРОЩЕННАЯ)
  -- ===========================================================================
  PROCEDURE sync_groups_only IS
    l_session_id VARCHAR2(50);
  BEGIN
    l_session_id := generate_session_id();
    log_sync_event(l_session_id, 'GROUPS', 'SYNC_SKIPPED', 'BULK',
                   C_SUCCESS, SYSTIMESTAMP, p_error_msg => 'Groups sync - implement if needed');
  END sync_groups_only;

  -- ===========================================================================
  -- ГЛАВНАЯ ПРОЦЕДУРА ПОЛНОЙ СИНХРОНИЗАЦИИ
  -- ===========================================================================
  PROCEDURE sync_daily_full IS
    l_session_id VARCHAR2(50);
    l_start_time TIMESTAMP;
  BEGIN
    l_session_id := generate_session_id();
    l_start_time := SYSTIMESTAMP;

    log_sync_event(l_session_id, 'FULL_SYNC', 'DAILY_START', 'ALL',
                   C_SUCCESS, l_start_time);

    BEGIN
      -- Сначала синхронизируем подразделения
      sync_departments();
      
      -- Потом пользователей (чтобы могли связаться с подразделениями)
      sync_users_only();
      
      -- Группы по необходимости
      sync_groups_only();

      log_sync_event(l_session_id, 'FULL_SYNC', 'DAILY_COMPLETE', 'ALL',
                     C_SUCCESS, l_start_time);
    EXCEPTION
      WHEN OTHERS THEN
        log_sync_event(l_session_id, 'FULL_SYNC', 'DAILY_FAILED', 'ALL',
                       C_ERROR, l_start_time, p_error_msg => SQLERRM);
        RAISE;
    END;
  END sync_daily_full;

END PKG_AD_SYNC;
/

-- ============================================================================
-- ШАГ 4: ПОЛЕЗНЫЕ ПРЕДСТАВЛЕНИЯ ДЛЯ РАБОТЫ
-- ============================================================================

-- Представление пользователей с подразделениями
CREATE OR REPLACE VIEW v_ad_users_full AS
SELECT 
  u.user_id,
  u.sam_account_name as login,
  u.display_name as full_name,
  u.email_address as email,
  u.phone_number as phone,
  u.job_title as position,
  u.department_name,
  u.department_code,
  d.department_name as dept_full_name,
  u.manager_name,
  u.city_location as city,
  u.company_name as company,
  u.employee_id,
  u.sync_status,
  u.last_sync_date
FROM ad_users u
LEFT JOIN ad_departments d ON u.department_id = d.department_id
WHERE u.sync_status = 'ACTIVE';

-- Представление атрибутов пользователей
CREATE OR REPLACE VIEW v_user_attributes AS
SELECT 
  u.sam_account_name as login,
  u.display_name as full_name,
  ea.attribute_name,
  ea.attribute_value
FROM ad_users u
JOIN ad_user_extended_attributes ea ON u.user_id = ea.user_id
WHERE u.sync_status = 'ACTIVE';

-- ============================================================================
-- ШАГ 5: ТЕСТИРОВАНИЕ И ЗАПУСК
-- ============================================================================

-- Проверяем компиляцию
SELECT object_name, object_type, status 
FROM user_objects 
WHERE object_name = 'PKG_AD_SYNC'
ORDER BY object_type;

-- Запускаем полную синхронизацию
BEGIN
  DBMS_OUTPUT.ENABLE(1000000);
  DBMS_OUTPUT.PUT_LINE('=== ЗАПУСК ПОЛНОЙ СИНХРОНИЗАЦИИ ===');
  
  AD_SYNC_SERVICE.PKG_AD_SYNC.sync_daily_full;
  
  DBMS_OUTPUT.PUT_LINE('=== ЗАВЕРШЕНО ===');
END;
/

-- ============================================================================
-- ШАГ 6: ПРОВЕРКА РЕЗУЛЬТАТОВ
-- ============================================================================

-- Смотрим синхронизированных пользователей
SELECT login, full_name, email, phone, position, department_name, city
FROM v_ad_users_full
ORDER BY full_name
FETCH FIRST 10 ROWS ONLY;

-- Смотрим подразделения
SELECT department_code, department_name, sync_status, last_sync_date
FROM ad_departments
ORDER BY department_name;

-- Смотрим расширенные атрибуты
SELECT login, attribute_name, 
       CASE WHEN LENGTH(attribute_value) > 50 
            THEN SUBSTR(attribute_value, 1, 47) || '...'
            ELSE attribute_value END as value_preview
FROM v_user_attributes
WHERE login = 'твой.логин' -- замени на реальный логин
ORDER BY attribute_name;

-- Статистика синхронизации
SELECT sync_type, sync_status, COUNT(*) as operations_count,
       MAX(created_date) as last_sync_time
FROM ad_sync_log
GROUP BY sync_type, sync_status
ORDER BY sync_type, sync_status;