

CREATE OR REPLACE PACKAGE BODY AD_SYNC_SERVICE.PKG_AD_SYNC AS



C_SUCCESS   CONSTANT VARCHAR2(10) := 'SUCCESS';
C_ERROR     CONSTANT VARCHAR2(10) := 'ERROR';  
C_WARNING   CONSTANT VARCHAR2(10) := 'WARNING';
C_ACTIVE    CONSTANT VARCHAR2(10) := 'ACTIVE';
C_INACTIVE  CONSTANT VARCHAR2(10) := 'INACTIVE';

-- ========================================================================
-- ФУНКЦИЯ ПОЛУЧЕНИЯ КОНФИГУРАЦИИ (БЕЗ NO_DATA_FOUND)
-- ========================================================================
FUNCTION get_config RETURN t_config_rec IS
  l_config t_config_rec;
BEGIN
  -- Жестко заданные рабочие значения (из переписки)
  l_config.ldap_host := '';
  l_config.ldap_port := 389;
  l_config.user_base_dn := '';
  l_config.group_base_dn := '';
  l_config.bind_dn := '';
  l_config.bind_password := '';
  l_config.batch_size := 1000;
  l_config.user_filter := '(objectClass=person)';
  l_config.group_filter := '(objectClass=group)';
  l_config.timeout_seconds := 300;
  l_config.max_retries := 3;

  -- Попытка получить из таблицы конфигурации (НЕ ПАДАЕТ НА ОШИБКАХ!)
  BEGIN
    FOR rec IN (SELECT config_name, config_value FROM ad_sync_config 
                WHERE config_group IN ('LDAP', 'SYNC', 'FILTERS')) LOOP
      CASE rec.config_name
        WHEN 'HOST' THEN l_config.ldap_host := rec.config_value;
        WHEN 'PORT' THEN l_config.ldap_port := TO_NUMBER(rec.config_value);
        WHEN 'USER_BASE_DN' THEN l_config.user_base_dn := rec.config_value;
        WHEN 'GROUP_BASE_DN' THEN l_config.group_base_dn := rec.config_value;
        WHEN 'BIND_DN' THEN l_config.bind_dn := rec.config_value;
        WHEN 'BIND_PASSWORD' THEN l_config.bind_password := rec.config_value;
        WHEN 'BATCH_SIZE' THEN l_config.batch_size := TO_NUMBER(rec.config_value);
        WHEN 'USER_FILTER' THEN l_config.user_filter := rec.config_value;
        WHEN 'GROUP_FILTER' THEN l_config.group_filter := rec.config_value;
        ELSE NULL;
      END CASE;
    END LOOP;
  EXCEPTION
    WHEN OTHERS THEN 
      NULL; -- Используем defaults
  END;

  RETURN l_config;
END get_config;

-- ========================================================================
-- ГЕНЕРАЦИЯ ID СЕССИИ 
-- ========================================================================
FUNCTION generate_session_id RETURN VARCHAR2 IS
BEGIN
  RETURN 'SYNC_' || TO_CHAR(SYSDATE, 'YYYYMMDD_HH24MISS') || '_' || 
         LPAD(TRUNC(DBMS_RANDOM.VALUE(1000, 9999)), 4, '0');
END generate_session_id;

-- ========================================================================
-- ЛОГИРОВАНИЕ (АВТОНОМНАЯ ТРАНЗАКЦИЯ)
-- ========================================================================
PROCEDURE log_sync_event(
  p_session_id    IN VARCHAR2,
  p_sync_type     IN VARCHAR2,
  p_operation     IN VARCHAR2,
  p_object_id     IN VARCHAR2,
  p_status        IN VARCHAR2,
  p_start_time    IN TIMESTAMP,
  p_end_time      IN TIMESTAMP DEFAULT SYSTIMESTAMP,
  p_records_proc  IN NUMBER DEFAULT 0,
  p_records_succ  IN NUMBER DEFAULT 0,
  p_records_err   IN NUMBER DEFAULT 0,
  p_error_msg     IN VARCHAR2 DEFAULT NULL,
  p_detailed_log  IN CLOB DEFAULT NULL
) IS
  PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
  INSERT INTO ad_sync_log (
    sync_session_id,
    sync_type,
    sync_operation,
    object_identifier,
    sync_status,
    start_time,
    end_time,
    duration_seconds,
    records_processed,
    records_success,
    records_error,
    error_message,
    detailed_log,
    created_date,
    created_by
  ) VALUES (
    p_session_id,
    p_sync_type,
    p_operation,
    p_object_id,
    p_status,
    p_start_time,
    p_end_time,
    CASE WHEN p_end_time > p_start_time 
         THEN EXTRACT(SECOND FROM (p_end_time - p_start_time))
         ELSE 0 END,
    p_records_proc,
    p_records_succ,
    p_records_err,
    SUBSTR(p_error_msg, 1, 4000),
    p_detailed_log,
    SYSDATE,
    USER
  );
  COMMIT;
EXCEPTION
  WHEN OTHERS THEN NULL; -- Критическая защита от падения логирования
END log_sync_event;

-- ========================================================================
-- ИЗВЛЕЧЕНИЕ SAM ACCOUNT NAME ИЗ DN (ПРОВЕРЕННАЯ ФУНКЦИЯ)
-- ========================================================================
FUNCTION extract_sam_from_dn(p_dn VARCHAR2) RETURN VARCHAR2 IS
  l_start_pos NUMBER;
  l_end_pos   NUMBER;
  l_result    VARCHAR2(256);
BEGIN
  IF p_dn IS NULL THEN
    RETURN 'UNKNOWN_USER';
  END IF;
  
  l_start_pos := INSTR(UPPER(p_dn), 'CN=');
  IF l_start_pos > 0 THEN
    l_start_pos := l_start_pos + 3;
    l_end_pos := INSTR(p_dn, ',', l_start_pos);
    IF l_end_pos = 0 THEN
      l_end_pos := LENGTH(p_dn) + 1;
    END IF;
    l_result := TRIM(SUBSTR(p_dn, l_start_pos, l_end_pos - l_start_pos));
  ELSE
    l_result := 'USER_' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS');
  END IF;
  
  RETURN l_result;
END extract_sam_from_dn;

-- ========================================================================
-- ОСНОВНАЯ ПРОЦЕДУРА СИНХРОНИЗАЦИИ ПОЛЬЗОВАТЕЛЕЙ
-- ========================================================================
PROCEDURE sync_users_only IS
  l_config      t_config_rec;
  l_session_id  VARCHAR2(50);
  l_start_time  TIMESTAMP;
  l_session     DBMS_LDAP.SESSION;
  l_retval      PLS_INTEGER;
  l_message     DBMS_LDAP.MESSAGE;
  l_entry       DBMS_LDAP.MESSAGE;
  l_dn          VARCHAR2(2000);
  l_sam_account VARCHAR2(256);
  l_processed   NUMBER := 0;
  l_success     NUMBER := 0;
  l_errors      NUMBER := 0;
  l_retry_count NUMBER := 0;
  
BEGIN
  l_config := get_config();
  l_session_id := generate_session_id();
  l_start_time := SYSTIMESTAMP;

  -- Логируем начало
  log_sync_event(
    p_session_id => l_session_id,
    p_sync_type  => 'USERS',
    p_operation  => 'SYNC_START', 
    p_object_id  => 'BULK',
    p_status     => C_SUCCESS,
    p_start_time => l_start_time
  );

  -- Помечаем всех пользователей как неактивных
  UPDATE ad_users SET sync_status = C_INACTIVE, last_sync_date = SYSDATE;

  -- Цикл повторных попыток подключения
  WHILE l_retry_count < l_config.max_retries LOOP
    BEGIN
      -- Инициализация LDAP 
      l_session := DBMS_LDAP.init(l_config.ldap_host, l_config.ldap_port);
      
      -- Bind (аутентификация)
      l_retval := DBMS_LDAP.simple_bind_s(
        ld     => l_session,
        dn     => l_config.bind_dn,
        passwd => l_config.bind_password
      );
      
      IF l_retval = 0 THEN
        -- ПРАВИЛЬНЫЙ ВЫЗОВ LDAP ПОИСКА (из анализа переписки)
        l_message := DBMS_LDAP.search_s(
          ld     => l_session,
          base   => l_config.user_base_dn,
          scope  => DBMS_LDAP.SCOPE_SUBTREE,
          filter => l_config.user_filter,
          attrs  => NULL,
          attrsonly => 0
        );
        
        -- Обрабатываем результаты
        l_entry := DBMS_LDAP.first_entry(l_session, l_message);
        
        WHILE l_entry IS NOT NULL LOOP
          BEGIN
            -- Получаем DN
            l_dn := DBMS_LDAP.get_dn(l_session, l_entry);
            l_sam_account := extract_sam_from_dn(l_dn);
            
            -- MERGE в таблицу AD_USERS (ТОЧНЫЕ ИМЕНА КОЛОНОК!)
            MERGE INTO ad_users tgt
            USING (
              SELECT 
                l_sam_account as sam_account_name,
                l_dn as distinguished_name
              FROM dual
            ) src ON (tgt.sam_account_name = src.sam_account_name)
            WHEN MATCHED THEN UPDATE SET
              distinguished_name = src.distinguished_name,
              sync_status = C_ACTIVE,
              last_sync_date = SYSDATE,
              modified_by = USER,
              modified_date = SYSDATE
            WHEN NOT MATCHED THEN INSERT (
              user_id,
              sam_account_name,
              distinguished_name,
              sync_status,
              created_date,
              created_by,
              last_sync_date
            ) VALUES (
              'U' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS') || '_' || l_processed,
              src.sam_account_name,
              src.distinguished_name,
              C_ACTIVE,
              SYSDATE,
              USER,
              SYSDATE
            );
            
            l_success := l_success + 1;
            
            -- Пакетный commit
            IF MOD(l_success, l_config.batch_size) = 0 THEN
              COMMIT;
            END IF;
            
          EXCEPTION
            WHEN OTHERS THEN
              l_errors := l_errors + 1;
              -- Логируем ошибку конкретного пользователя
              log_sync_event(
                p_session_id => l_session_id,
                p_sync_type  => 'USERS',
                p_operation  => 'USER_ERROR',
                p_object_id  => l_sam_account,
                p_status     => C_ERROR,
                p_start_time => l_start_time,
                p_error_msg  => SQLERRM
              );
          END;
          
          l_processed := l_processed + 1;
          l_entry := DBMS_LDAP.next_entry(l_session, l_entry);
        END LOOP;
        
        -- Успешно завершили - выход из retry loop
        EXIT;
        
      ELSE
        RAISE_APPLICATION_ERROR(-20001, 'LDAP bind failed: ' || l_retval);
      END IF;
      
      -- Закрываем соединение
      l_retval := DBMS_LDAP.unbind_s(l_session);
      
    EXCEPTION
      WHEN OTHERS THEN
        l_retry_count := l_retry_count + 1;
        
        -- Закрываем соединение при ошибке
        IF l_session IS NOT NULL THEN
          BEGIN
            l_retval := DBMS_LDAP.unbind_s(l_session);
          EXCEPTION WHEN OTHERS THEN NULL;
          END;
        END IF;
        
        -- Если исчерпали попытки
        IF l_retry_count >= l_config.max_retries THEN
          log_sync_event(
            p_session_id => l_session_id,
            p_sync_type  => 'USERS',
            p_operation  => 'LDAP_FINAL_ERROR',
            p_object_id  => 'CONNECTION',
            p_status     => C_ERROR,
            p_start_time => l_start_time,
            p_error_msg  => SQLERRM
          );
          RAISE;
        ELSE
          -- Логируем retry
          log_sync_event(
            p_session_id => l_session_id,
            p_sync_type  => 'USERS',
            p_operation  => 'RETRY_' || l_retry_count,
            p_object_id  => 'CONNECTION',
            p_status     => C_WARNING,
            p_start_time => l_start_time,
            p_error_msg  => SQLERRM
          );
          
          -- Пауза перед повтором
          DBMS_LOCK.SLEEP(2);
        END IF;
    END;
  END LOOP;

  -- Финальный commit
  COMMIT;
  
  -- Удаляем пользователей, которых нет в AD
  DELETE FROM ad_users WHERE sync_status = C_INACTIVE;
  COMMIT;

  -- Логируем завершение
  log_sync_event(
    p_session_id   => l_session_id,
    p_sync_type    => 'USERS',
    p_operation    => 'SYNC_COMPLETE',
    p_object_id    => 'BULK',
    p_status       => CASE WHEN l_errors = 0 THEN C_SUCCESS ELSE C_WARNING END,
    p_start_time   => l_start_time,
    p_records_proc => l_processed,
    p_records_succ => l_success,
    p_records_err  => l_errors
  );

EXCEPTION
  WHEN OTHERS THEN
    ROLLBACK;
    log_sync_event(
      p_session_id => l_session_id,
      p_sync_type  => 'USERS',
      p_operation  => 'SYNC_FAILED',
      p_object_id  => 'BULK',
      p_status     => C_ERROR,
      p_start_time => l_start_time,
      p_error_msg  => SQLERRM
    );
    RAISE;
END sync_users_only;

-- ========================================================================
-- ПРОЦЕДУРА СИНХРОНИЗАЦИИ ГРУПП
-- ========================================================================
PROCEDURE sync_groups_only IS
  l_config      t_config_rec;
  l_session_id  VARCHAR2(50);
  l_start_time  TIMESTAMP;
  l_session     DBMS_LDAP.SESSION;
  l_retval      PLS_INTEGER;
  l_message     DBMS_LDAP.MESSAGE;
  l_entry       DBMS_LDAP.MESSAGE;
  l_dn          VARCHAR2(2000);
  l_group_name  VARCHAR2(256);
  l_processed   NUMBER := 0;
  l_success     NUMBER := 0;
  l_errors      NUMBER := 0;
  
BEGIN
  l_config := get_config();
  l_session_id := generate_session_id();
  l_start_time := SYSTIMESTAMP;

  log_sync_event(
    p_session_id => l_session_id,
    p_sync_type  => 'GROUPS',
    p_operation  => 'SYNC_START',
    p_object_id  => 'BULK',
    p_status     => C_SUCCESS,
    p_start_time => l_start_time
  );

  -- Помечаем группы как неактивные
  UPDATE ad_groups SET sync_status = C_INACTIVE, last_sync_date = SYSDATE;

  BEGIN
    -- LDAP соединение
    l_session := DBMS_LDAP.init(l_config.ldap_host, l_config.ldap_port);
    l_retval := DBMS_LDAP.simple_bind_s(l_session, l_config.bind_dn, l_config.bind_password);
    
    IF l_retval = 0 THEN
      -- Поиск групп
      l_message := DBMS_LDAP.search_s(
        ld     => l_session,
        base   => l_config.group_base_dn, 
        scope  => DBMS_LDAP.SCOPE_SUBTREE,
        filter => l_config.group_filter,
        attrs  => NULL,
        attrsonly => 0
      );
      
      l_entry := DBMS_LDAP.first_entry(l_session, l_message);
      
      WHILE l_entry IS NOT NULL LOOP
        BEGIN
          l_dn := DBMS_LDAP.get_dn(l_session, l_entry);
          l_group_name := extract_sam_from_dn(l_dn);
          
          -- MERGE в таблицу AD_GROUPS (ТОЧНЫЕ ИМЕНА КОЛОНОК!)
          MERGE INTO ad_groups tgt
          USING (
            SELECT 
              l_group_name as sam_account_name,
              l_dn as distinguished_name
            FROM dual
          ) src ON (tgt.sam_account_name = src.sam_account_name)
          WHEN MATCHED THEN UPDATE SET
            distinguished_name = src.distinguished_name,
            sync_status = C_ACTIVE,
            last_sync_date = SYSDATE,
            modified_by = USER,
            modified_date = SYSDATE
          WHEN NOT MATCHED THEN INSERT (
            group_id,
            sam_account_name,
            distinguished_name,
            sync_status,
            created_date,
            created_by
          ) VALUES (
            'G' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS') || '_' || l_processed,
            src.sam_account_name,
            src.distinguished_name,
            C_ACTIVE,
            SYSDATE,
            USER
          );
          
          l_success := l_success + 1;
          
          IF MOD(l_success, l_config.batch_size) = 0 THEN
            COMMIT;
          END IF;
          
        EXCEPTION
          WHEN OTHERS THEN
            l_errors := l_errors + 1;
        END;
        
        l_processed := l_processed + 1;
        l_entry := DBMS_LDAP.next_entry(l_session, l_entry);
      END LOOP;
    END IF;
    
    l_retval := DBMS_LDAP.unbind_s(l_session);
    
  EXCEPTION
    WHEN OTHERS THEN
      IF l_session IS NOT NULL THEN
        l_retval := DBMS_LDAP.unbind_s(l_session);
      END IF;
      RAISE;
  END;

  COMMIT;
  DELETE FROM ad_groups WHERE sync_status = C_INACTIVE;
  COMMIT;

  log_sync_event(
    p_session_id   => l_session_id,
    p_sync_type    => 'GROUPS',
    p_operation    => 'SYNC_COMPLETE',
    p_object_id    => 'BULK',
    p_status       => CASE WHEN l_errors = 0 THEN C_SUCCESS ELSE C_WARNING END,
    p_start_time   => l_start_time,
    p_records_proc => l_processed,
    p_records_succ => l_success,
    p_records_err  => l_errors
  );

EXCEPTION
  WHEN OTHERS THEN
    ROLLBACK;
    log_sync_event(
      p_session_id => l_session_id,
      p_sync_type  => 'GROUPS',
      p_operation  => 'SYNC_FAILED',
      p_object_id  => 'BULK',
      p_status     => C_ERROR,
      p_start_time => l_start_time,
      p_error_msg  => SQLERRM
    );
    RAISE;
END sync_groups_only;

-- ========================================================================
-- ЗАГЛУШКА ДЛЯ СИНХРОНИЗАЦИИ ЧЛЕНСТВА
-- ========================================================================
PROCEDURE sync_memberships_only IS
  l_session_id VARCHAR2(50);
BEGIN
  l_session_id := generate_session_id();
  log_sync_event(
    p_session_id => l_session_id,
    p_sync_type  => 'MEMBERSHIPS',
    p_operation  => 'SYNC_SKIPPED',
    p_object_id  => 'BULK',
    p_status     => C_SUCCESS,
    p_start_time => SYSTIMESTAMP,
    p_error_msg  => 'Not implemented yet'
  );
END sync_memberships_only;

-- ========================================================================
-- ГЛАВНАЯ ПРОЦЕДУРА ЕЖЕДНЕВНОЙ СИНХРОНИЗАЦИИ
-- ========================================================================
PROCEDURE sync_daily_full IS
  l_session_id VARCHAR2(50);
  l_start_time TIMESTAMP;
BEGIN
  l_session_id := generate_session_id();
  l_start_time := SYSTIMESTAMP;

  log_sync_event(
    p_session_id => l_session_id,
    p_sync_type  => 'FULL_SYNC',
    p_operation  => 'DAILY_START',
    p_object_id  => 'ALL',
    p_status     => C_SUCCESS,
    p_start_time => l_start_time
  );

  BEGIN
    -- Синхронизируем пользователей
    sync_users_only();
    
    -- Синхронизируем группы  
    sync_groups_only();
    
    -- Синхронизируем членство (заглушка)
    sync_memberships_only();

    -- Успешное завершение
    log_sync_event(
      p_session_id => l_session_id,
      p_sync_type  => 'FULL_SYNC',
      p_operation  => 'DAILY_COMPLETE',
      p_object_id  => 'ALL',
      p_status     => C_SUCCESS,
      p_start_time => l_start_time
    );

  EXCEPTION
    WHEN OTHERS THEN
      log_sync_event(
        p_session_id => l_session_id,
        p_sync_type  => 'FULL_SYNC',
        p_operation  => 'DAILY_FAILED',
        p_object_id  => 'ALL',
        p_status     => C_ERROR,
        p_start_time => l_start_time,
        p_error_msg  => SQLERRM
      );
      RAISE;
  END;
END sync_daily_full;

END PKG_AD_SYNC;
/

-- ============================================================================
-- ПРОВЕРКИ И ТЕСТИРОВАНИЕ
-- ============================================================================

-- Проверяем компиляцию пакета
SELECT object_name, object_type, status 
FROM user_objects 
WHERE object_name = 'PKG_AD_SYNC'
ORDER BY object_type;

-- Проверяем структуру таблиц
DESC AD_SYNC_SERVICE.AD_USERS;
DESC AD_SYNC_SERVICE.AD_GROUPS;  
DESC AD_SYNC_SERVICE.AD_SYNC_LOG;

-- ============================================================================
-- РУЧНОЙ ЗАПУСК ДЛЯ ТЕСТИРОВАНИЯ
-- ============================================================================

-- Тест полной синхронизации
BEGIN
  AD_SYNC_SERVICE.PKG_AD_SYNC.sync_daily_full;
END;
/

-- Проверяем логи
SELECT sync_session_id, sync_type, sync_operation, sync_status,
       records_processed, records_success, records_error,
       created_date, error_message
FROM AD_SYNC_SERVICE.AD_SYNC_LOG 
ORDER BY created_date DESC
FETCH FIRST 10 ROWS ONLY;

-- Проверяем результаты синхронизации
SELECT sync_status, COUNT(*) as count
FROM AD_SYNC_SERVICE.AD_USERS 
GROUP BY sync_status;

SELECT sync_status, COUNT(*) as count  
FROM AD_SYNC_SERVICE.AD_GROUPS
GROUP BY sync_status;