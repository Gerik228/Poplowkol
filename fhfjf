
CREATE OR REPLACE PACKAGE AD_SYNC_SERVICE.PKG_AD_SYNC AS

  -- КОНСТАНТЫ
  C_SUCCESS   CONSTANT VARCHAR2(10) := 'SUCCESS';
  C_ERROR     CONSTANT VARCHAR2(10) := 'ERROR';
  C_WARNING   CONSTANT VARCHAR2(10) := 'WARNING';
  C_ACTIVE    CONSTANT VARCHAR2(10) := 'ACTIVE';
  C_INACTIVE  CONSTANT VARCHAR2(10) := 'INACTIVE';

  -- ТИПЫ ДАННЫХ
  TYPE t_config_rec IS RECORD (
    ldap_host         VARCHAR2(256),
    ldap_port         NUMBER,
    user_base_dn      VARCHAR2(512),
    group_base_dn     VARCHAR2(512),
    bind_dn           VARCHAR2(512),
    bind_password     VARCHAR2(256),
    batch_size        NUMBER,
    user_filter       VARCHAR2(256),
    group_filter      VARCHAR2(256),
    timeout_seconds   NUMBER,
    max_retries       NUMBER
  );

  -- ФУНКЦИИ И ПРОЦЕДУРЫ
  FUNCTION get_config RETURN t_config_rec;
  FUNCTION generate_session_id RETURN VARCHAR2;

  PROCEDURE log_sync_event(
    p_session_id    IN VARCHAR2,
    p_sync_type     IN VARCHAR2,
    p_operation     IN VARCHAR2,
    p_object_id     IN VARCHAR2,
    p_status        IN VARCHAR2,
    p_start_time    IN TIMESTAMP,
    p_end_time      IN TIMESTAMP DEFAULT SYSTIMESTAMP,
    p_records_proc  IN NUMBER DEFAULT 0,
    p_records_succ  IN NUMBER DEFAULT 0,
    p_records_err   IN NUMBER DEFAULT 0,
    p_error_msg     IN VARCHAR2 DEFAULT NULL,
    p_detailed_log  IN CLOB DEFAULT NULL
  );

  PROCEDURE sync_users_only;
  PROCEDURE sync_groups_only;
  PROCEDURE sync_memberships_only;
  PROCEDURE sync_daily_full;

END PKG_AD_SYNC;
/

-- ============================================================================
-- ТЕЛО ПАКЕТА С ИСПРАВЛЕНИЯМИ
-- ============================================================================
CREATE OR REPLACE PACKAGE BODY AD_SYNC_SERVICE.PKG_AD_SYNC AS

  -- ===========================================================================
  -- СОБСТВЕННАЯ ФУНКЦИЯ ЗАДЕРЖКИ (ЗАМЕНА DBMS_LOCK.SLEEP!)
  -- ===========================================================================
  PROCEDURE custom_sleep(p_seconds IN NUMBER) IS
    l_start_time DATE;
    l_current_time DATE;
    l_dummy NUMBER;
  BEGIN
    l_start_time := SYSDATE;
    
    -- Простой цикл ожидания
    LOOP
      -- Делаем минимальную работу чтобы не нагружать CPU
      SELECT 1 INTO l_dummy FROM dual WHERE ROWNUM = 1;
      
      l_current_time := SYSDATE;
      
      -- Выходим когда прошло нужное время
      EXIT WHEN (l_current_time - l_start_time) * 24 * 3600 >= p_seconds;
    END LOOP;
  END custom_sleep;

  -- ===========================================================================
  -- ПРИВАТНЫЕ ФУНКЦИИ
  -- ===========================================================================
  FUNCTION extract_sam_from_dn(p_dn VARCHAR2) RETURN VARCHAR2 IS
    l_start_pos NUMBER;
    l_end_pos   NUMBER;
    l_result    VARCHAR2(256);
  BEGIN
    IF p_dn IS NULL THEN
      RETURN 'UNKNOWN_USER';
    END IF;
    
    l_start_pos := INSTR(UPPER(p_dn), 'CN=');
    IF l_start_pos > 0 THEN
      l_start_pos := l_start_pos + 3;
      l_end_pos := INSTR(p_dn, ',', l_start_pos);
      IF l_end_pos = 0 THEN
        l_end_pos := LENGTH(p_dn) + 1;
      END IF;
      l_result := TRIM(SUBSTR(p_dn, l_start_pos, l_end_pos - l_start_pos));
    ELSE
      l_result := 'USER_' || TO_CHAR(SYSDATE, 'HH24MISS');
    END IF;
    
    RETURN l_result;
  END extract_sam_from_dn;

  -- ===========================================================================
  -- ФУНКЦИЯ ПОЛУЧЕНИЯ КОНФИГУРАЦИИ
  -- ===========================================================================
  FUNCTION get_config RETURN t_config_rec IS
    l_config t_config_rec;
  BEGIN
 

    -- Безопасная попытка получить из таблицы конфигурации
    BEGIN
      FOR rec IN (
        SELECT config_name, config_value 
        FROM ad_sync_config 
        WHERE config_group IN ('LDAP', 'SYNC', 'FILTERS')
      ) LOOP
        CASE rec.config_name
          WHEN 'HOST' THEN l_config.ldap_host := rec.config_value;
          WHEN 'PORT' THEN l_config.ldap_port := TO_NUMBER(rec.config_value);
          WHEN 'USER_BASE_DN' THEN l_config.user_base_dn := rec.config_value;
          WHEN 'GROUP_BASE_DN' THEN l_config.group_base_dn := rec.config_value;
          WHEN 'BIND_DN' THEN l_config.bind_dn := rec.config_value;
          WHEN 'BIND_PASSWORD' THEN l_config.bind_password := rec.config_value;
          WHEN 'BATCH_SIZE' THEN l_config.batch_size := TO_NUMBER(rec.config_value);
          WHEN 'USER_FILTER' THEN l_config.user_filter := rec.config_value;
          WHEN 'GROUP_FILTER' THEN l_config.group_filter := rec.config_value;
          WHEN 'TIMEOUT_SECONDS' THEN l_config.timeout_seconds := TO_NUMBER(rec.config_value);
          WHEN 'MAX_RETRIES' THEN l_config.max_retries := TO_NUMBER(rec.config_value);
          ELSE NULL;
        END CASE;
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN NULL;
    END;

    RETURN l_config;
  END get_config;

  -- ===========================================================================
  -- ГЕНЕРАЦИЯ ID СЕССИИ
  -- ===========================================================================
  FUNCTION generate_session_id RETURN VARCHAR2 IS
  BEGIN
    RETURN 'SYNC_' || TO_CHAR(SYSDATE, 'YYYYMMDD_HH24MISS') || '_' || 
           LPAD(TRUNC(DBMS_RANDOM.VALUE(1000, 9999)), 4, '0');
  END generate_session_id;

  -- ===========================================================================
  -- ЛОГИРОВАНИЕ
  -- ===========================================================================
  PROCEDURE log_sync_event(
    p_session_id    IN VARCHAR2,
    p_sync_type     IN VARCHAR2,
    p_operation     IN VARCHAR2,
    p_object_id     IN VARCHAR2,
    p_status        IN VARCHAR2,
    p_start_time    IN TIMESTAMP,
    p_end_time      IN TIMESTAMP DEFAULT SYSTIMESTAMP,
    p_records_proc  IN NUMBER DEFAULT 0,
    p_records_succ  IN NUMBER DEFAULT 0,
    p_records_err   IN NUMBER DEFAULT 0,
    p_error_msg     IN VARCHAR2 DEFAULT NULL,
    p_detailed_log  IN CLOB DEFAULT NULL
  ) IS
    PRAGMA AUTONOMOUS_TRANSACTION;
  BEGIN
    INSERT INTO ad_sync_log (
      sync_session_id, sync_type, sync_operation, object_identifier, sync_status,
      start_time, end_time, duration_seconds, records_processed, records_success, 
      records_error, error_message, detailed_log, created_date, created_by
    ) VALUES (
      p_session_id, p_sync_type, p_operation, p_object_id, p_status,
      p_start_time, p_end_time, 
      CASE WHEN p_end_time > p_start_time 
           THEN EXTRACT(SECOND FROM (p_end_time - p_start_time))
           ELSE 0 END,
      p_records_proc, p_records_succ, p_records_err, 
      SUBSTR(p_error_msg, 1, 4000), p_detailed_log, SYSDATE, USER
    );
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN NULL;
  END log_sync_event;

  -- ===========================================================================
  -- СИНХРОНИЗАЦИЯ ПОЛЬЗОВАТЕЛЕЙ (ИСПРАВЛЕННАЯ!)
  -- ===========================================================================
  PROCEDURE sync_users_only IS
    l_config      t_config_rec;
    l_session_id  VARCHAR2(50);
    l_start_time  TIMESTAMP;
    l_session     DBMS_LDAP.SESSION;
    l_retval      PLS_INTEGER;
    l_message     DBMS_LDAP.MESSAGE;
    l_entry       DBMS_LDAP.MESSAGE;
    l_dn          VARCHAR2(2000);
    l_sam_account VARCHAR2(256);
    l_processed   NUMBER := 0;
    l_success     NUMBER := 0;
    l_errors      NUMBER := 0;
    l_retry_count NUMBER := 0;
    
    -- ИСПРАВЛЕНИЕ: Создаем пустой массив атрибутов вместо NULL!
    l_attrs       DBMS_LDAP.STRING_COLLECTION;
    
  BEGIN
    l_config := get_config();
    l_session_id := generate_session_id();
    l_start_time := SYSTIMESTAMP;

    log_sync_event(l_session_id, 'USERS', 'SYNC_START', 'BULK', 
                   C_SUCCESS, l_start_time);

    -- Помечаем всех пользователей как неактивных
    UPDATE ad_users 
    SET sync_status = C_INACTIVE, last_sync_date = SYSDATE,
        modified_by = USER, modified_date = SYSDATE;

    -- Главный цикл с повторными попытками
    WHILE l_retry_count < l_config.max_retries LOOP
      BEGIN
        -- Инициализация LDAP
        l_session := DBMS_LDAP.init(l_config.ldap_host, l_config.ldap_port);
        
        -- Bind
        l_retval := DBMS_LDAP.simple_bind_s(l_session, l_config.bind_dn, l_config.bind_password);
        
        IF l_retval = DBMS_LDAP.SUCCESS THEN
          -- ИСПРАВЛЕННЫЙ ВЫЗОВ search_s с правильными параметрами!
          l_retval := DBMS_LDAP.search_s(
            ld => l_session,
            base => l_config.user_base_dn,
            scope => DBMS_LDAP.SCOPE_SUBTREE,
            filter => l_config.user_filter,
            attrs => l_attrs,        -- Пустой массив вместо NULL!
            attronly => 0,
            res => l_message
          );
          
          IF l_retval = DBMS_LDAP.SUCCESS THEN
            -- Обработка результатов
            l_entry := DBMS_LDAP.first_entry(l_session, l_message);
            
            WHILE l_entry IS NOT NULL LOOP
              BEGIN
                l_dn := DBMS_LDAP.get_dn(l_session, l_entry);
                l_sam_account := extract_sam_from_dn(l_dn);
                
                -- MERGE в таблицу пользователей
                MERGE INTO ad_users tgt
                USING (
                  SELECT l_sam_account as sam_account_name, l_dn as distinguished_name
                  FROM dual
                ) src ON (tgt.sam_account_name = src.sam_account_name)
                WHEN MATCHED THEN UPDATE SET
                  distinguished_name = src.distinguished_name,
                  sync_status = C_ACTIVE, last_sync_date = SYSDATE,
                  modified_by = USER, modified_date = SYSDATE
                WHEN NOT MATCHED THEN INSERT (
                  user_id, sam_account_name, distinguished_name, sync_status,
                  created_date, created_by, last_sync_date
                ) VALUES (
                  'U' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS') || '_' || l_processed,
                  src.sam_account_name, src.distinguished_name, C_ACTIVE,
                  SYSDATE, USER, SYSDATE
                );
                
                l_success := l_success + 1;
                
                IF MOD(l_success, l_config.batch_size) = 0 THEN
                  COMMIT;
                END IF;
                
              EXCEPTION
                WHEN OTHERS THEN
                  l_errors := l_errors + 1;
                  log_sync_event(l_session_id, 'USERS', 'USER_ERROR', 
                                l_sam_account, C_ERROR, l_start_time, 
                                p_error_msg => SQLERRM);
              END;
              
              l_processed := l_processed + 1;
              l_entry := DBMS_LDAP.next_entry(l_session, l_entry);
            END LOOP;
            
            -- Успех - выходим из retry цикла
            EXIT;
          END IF;
        END IF;
        
        -- Закрываем соединение
        l_retval := DBMS_LDAP.unbind_s(l_session);
        
      EXCEPTION
        WHEN OTHERS THEN
          l_retry_count := l_retry_count + 1;
          
          IF l_session IS NOT NULL THEN
            BEGIN
              l_retval := DBMS_LDAP.unbind_s(l_session);
            EXCEPTION WHEN OTHERS THEN NULL;
            END;
          END IF;
          
          IF l_retry_count >= l_config.max_retries THEN
            log_sync_event(l_session_id, 'USERS', 'LDAP_FINAL_ERROR', 
                          'CONNECTION', C_ERROR, l_start_time, p_error_msg => SQLERRM);
            RAISE;
          ELSE
            log_sync_event(l_session_id, 'USERS', 'RETRY_' || l_retry_count,
                          'CONNECTION', C_WARNING, l_start_time, p_error_msg => SQLERRM);
            
            -- ИСПОЛЬЗУЕМ НАШУ СОБСТВЕННУЮ ЗАДЕРЖКУ!
            custom_sleep(2);
          END IF;
      END;
    END LOOP;

    COMMIT;
    DELETE FROM ad_users WHERE sync_status = C_INACTIVE;
    COMMIT;

    log_sync_event(l_session_id, 'USERS', 'SYNC_COMPLETE', 'BULK',
                   CASE WHEN l_errors = 0 THEN C_SUCCESS ELSE C_WARNING END,
                   l_start_time, p_records_proc => l_processed,
                   p_records_succ => l_success, p_records_err => l_errors);

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      log_sync_event(l_session_id, 'USERS', 'SYNC_FAILED', 'BULK',
                     C_ERROR, l_start_time, p_error_msg => SQLERRM);
      RAISE;
  END sync_users_only;

  -- ===========================================================================
  -- СИНХРОНИЗАЦИЯ ГРУПП (ИСПРАВЛЕННАЯ!)
  -- ===========================================================================
  PROCEDURE sync_groups_only IS
    l_config      t_config_rec;
    l_session_id  VARCHAR2(50);
    l_start_time  TIMESTAMP;
    l_session     DBMS_LDAP.SESSION;
    l_retval      PLS_INTEGER;
    l_message     DBMS_LDAP.MESSAGE;
    l_entry       DBMS_LDAP.MESSAGE;
    l_dn          VARCHAR2(2000);
    l_group_name  VARCHAR2(256);
    l_processed   NUMBER := 0;
    l_success     NUMBER := 0;
    l_errors      NUMBER := 0;
    
    -- ИСПРАВЛЕНИЕ: Пустой массив атрибутов!
    l_attrs       DBMS_LDAP.STRING_COLLECTION;
    
  BEGIN
    l_config := get_config();
    l_session_id := generate_session_id();
    l_start_time := SYSTIMESTAMP;

    log_sync_event(l_session_id, 'GROUPS', 'SYNC_START', 'BULK', 
                   C_SUCCESS, l_start_time);

    UPDATE ad_groups 
    SET sync_status = C_INACTIVE, last_sync_date = SYSDATE,
        modified_by = USER, modified_date = SYSDATE;

    BEGIN
      l_session := DBMS_LDAP.init(l_config.ldap_host, l_config.ldap_port);
      l_retval := DBMS_LDAP.simple_bind_s(l_session, l_config.bind_dn, l_config.bind_password);
      
      IF l_retval = DBMS_LDAP.SUCCESS THEN
        -- ИСПРАВЛЕННЫЙ ВЫЗОВ с пустым массивом!
        l_retval := DBMS_LDAP.search_s(
          ld => l_session,
          base => l_config.group_base_dn,
          scope => DBMS_LDAP.SCOPE_SUBTREE,
          filter => l_config.group_filter,
          attrs => l_attrs,        -- Пустой массив!
          attronly => 0,
          res => l_message
        );
        
        IF l_retval = DBMS_LDAP.SUCCESS THEN
          l_entry := DBMS_LDAP.first_entry(l_session, l_message);
          
          WHILE l_entry IS NOT NULL LOOP
            BEGIN
              l_dn := DBMS_LDAP.get_dn(l_session, l_entry);
              l_group_name := extract_sam_from_dn(l_dn);
              
              MERGE INTO ad_groups tgt
              USING (
                SELECT l_group_name as sam_account_name, l_dn as distinguished_name
                FROM dual
              ) src ON (tgt.sam_account_name = src.sam_account_name)
              WHEN MATCHED THEN UPDATE SET
                distinguished_name = src.distinguished_name,
                sync_status = C_ACTIVE, last_sync_date = SYSDATE,
                modified_by = USER, modified_date = SYSDATE
              WHEN NOT MATCHED THEN INSERT (
                group_id, sam_account_name, distinguished_name, sync_status,
                created_date, created_by
              ) VALUES (
                'G' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS') || '_' || l_processed,
                src.sam_account_name, src.distinguished_name, C_ACTIVE,
                SYSDATE, USER
              );
              
              l_success := l_success + 1;
              
              IF MOD(l_success, l_config.batch_size) = 0 THEN
                COMMIT;
              END IF;
              
            EXCEPTION
              WHEN OTHERS THEN
                l_errors := l_errors + 1;
            END;
            
            l_processed := l_processed + 1;
            l_entry := DBMS_LDAP.next_entry(l_session, l_entry);
          END LOOP;
        END IF;
      END IF;
      
      l_retval := DBMS_LDAP.unbind_s(l_session);
      
    EXCEPTION
      WHEN OTHERS THEN
        IF l_session IS NOT NULL THEN
          l_retval := DBMS_LDAP.unbind_s(l_session);
        END IF;
        RAISE;
    END;

    COMMIT;
    DELETE FROM ad_groups WHERE sync_status = C_INACTIVE;
    COMMIT;

    log_sync_event(l_session_id, 'GROUPS', 'SYNC_COMPLETE', 'BULK',
                   CASE WHEN l_errors = 0 THEN C_SUCCESS ELSE C_WARNING END,
                   l_start_time, p_records_proc => l_processed,
                   p_records_succ => l_success, p_records_err => l_errors);

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      log_sync_event(l_session_id, 'GROUPS', 'SYNC_FAILED', 'BULK',
                     C_ERROR, l_start_time, p_error_msg => SQLERRM);
      RAISE;
  END sync_groups_only;

  -- ===========================================================================
  -- ЗАГЛУШКА ЧЛЕНСТВА
  -- ===========================================================================
  PROCEDURE sync_memberships_only IS
    l_session_id VARCHAR2(50);
  BEGIN
    l_session_id := generate_session_id();
    log_sync_event(l_session_id, 'MEMBERSHIPS', 'SYNC_SKIPPED', 'BULK',
                   C_SUCCESS, SYSTIMESTAMP, p_error_msg => 'Not implemented');
  END sync_memberships_only;

  -- ===========================================================================
  -- ГЛАВНАЯ ПРОЦЕДУРА
  -- ===========================================================================
  PROCEDURE sync_daily_full IS
    l_session_id VARCHAR2(50);
    l_start_time TIMESTAMP;
  BEGIN
    l_session_id := generate_session_id();
    l_start_time := SYSTIMESTAMP;

    log_sync_event(l_session_id, 'FULL_SYNC', 'DAILY_START', 'ALL',
                   C_SUCCESS, l_start_time);

    BEGIN
      sync_users_only();
      sync_groups_only();
      sync_memberships_only();

      log_sync_event(l_session_id, 'FULL_SYNC', 'DAILY_COMPLETE', 'ALL',
                     C_SUCCESS, l_start_time);
    EXCEPTION
      WHEN OTHERS THEN
        log_sync_event(l_session_id, 'FULL_SYNC', 'DAILY_FAILED', 'ALL',
                       C_ERROR, l_start_time, p_error_msg => SQLERRM);
        RAISE;
    END;
  END sync_daily_full;

END PKG_AD_SYNC;
/

-- ============================================================================
-- ПРОВЕРКА И ТЕСТИРОВАНИЕ
-- ============================================================================

-- Проверяем компиляцию
SELECT object_name, object_type, status 
FROM user_objects 
WHERE object_name = 'PKG_AD_SYNC'
ORDER BY object_type;

-- Тестируем
BEGIN
  DBMS_OUTPUT.ENABLE(1000000);
  DBMS_OUTPUT.PUT_LINE('=== ЗАПУСК AD SYNC ===');
  
  AD_SYNC_SERVICE.PKG_AD_SYNC.sync_daily_full;
  
  DBMS_OUTPUT.PUT_LINE('=== ЗАВЕРШЕНО ===');
END;
/