
CREATE TABLE ad_users (
  -- ИДЕНТИФИКАТОРЫ
  user_id             VARCHAR2(100) PRIMARY KEY,
  sam_account_name    VARCHAR2(256) UNIQUE NOT NULL,
  distinguished_name  VARCHAR2(1000),
  
  -- ОСНОВНЫЕ АТРИБУТЫ ПОЛЬЗОВАТЕЛЯ
  display_name        VARCHAR2(500),  -- name (ФИО)
  description_field   VARCHAR2(1000), -- description (отдел)  
  email_address       VARCHAR2(256),  -- mail (почта)
  phone_number        VARCHAR2(50),   -- ipPhone (номер телефона)
  city_location       VARCHAR2(100),  -- l (город)
  employee_id         VARCHAR2(50),   -- employeeID (id пользователя)
  department_name     VARCHAR2(500),  -- department (департамент)
  department_code     VARCHAR2(50),   -- PSKBKodDivision (код департамента)
  street_address      VARCHAR2(500),  -- streetAddress (улица)
  job_title           VARCHAR2(256),  -- title (должность)
  company_name        VARCHAR2(256),  -- company (где находится)
  manager_dn          VARCHAR2(1000), -- manager (DN менеджера)
  manager_name        VARCHAR2(500),  -- расшифрованное имя менеджера
  user_principal_name VARCHAR2(256),  -- userPrincipalName
  telephone_number    VARCHAR2(50),   -- telephoneNumber
  mobile_number       VARCHAR2(50),   -- mobile
  office_location     VARCHAR2(256),  -- physicalDeliveryOfficeName
  when_created        DATE,           -- whenCreated
  account_control     NUMBER,         -- userAccountControl
  sync_status         VARCHAR2(10) DEFAULT 'ACTIVE',
  created_date        DATE DEFAULT SYSDATE,
  created_by          VARCHAR2(100) DEFAULT USER,
  modified_date       DATE,
  modified_by         VARCHAR2(100),
  last_sync_date      DATE,
  
  -- ОГРАНИЧЕНИЯ
  CONSTRAINT chk_user_sync_status CHECK (sync_status IN ('ACTIVE', 'INACTIVE'))
);

-- Таблица для дополнительных атрибутов (расширяемость)
CREATE TABLE ad_user_extended_attributes (
  attribute_id       NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id            VARCHAR2(100) NOT NULL,
  attribute_name     VARCHAR2(256) NOT NULL,
  attribute_value    CLOB,
  created_date       DATE DEFAULT SYSDATE,
  sync_session_id    VARCHAR2(50),
  CONSTRAINT fk_ext_attr_user FOREIGN KEY (user_id) REFERENCES ad_users(user_id),
  CONSTRAINT uk_user_attr_name UNIQUE (user_id, attribute_name)
);

-- Таблица логов синхронизации
CREATE TABLE ad_sync_log (
  log_id              NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  sync_session_id     VARCHAR2(50) NOT NULL,
  sync_type           VARCHAR2(50),
  sync_operation      VARCHAR2(100),
  object_identifier   VARCHAR2(500),
  sync_status         VARCHAR2(10),
  start_time          TIMESTAMP,
  end_time            TIMESTAMP,
  duration_seconds    NUMBER,
  records_processed   NUMBER DEFAULT 0,
  records_success     NUMBER DEFAULT 0,
  records_error       NUMBER DEFAULT 0,
  error_message       VARCHAR2(4000),
  detailed_log        CLOB,
  created_date        DATE DEFAULT SYSDATE,
  created_by          VARCHAR2(100) DEFAULT USER
);

-- ИНДЕКСЫ ДЛЯ ПРОИЗВОДИТЕЛЬНОСТИ
CREATE INDEX idx_users_sam_account ON ad_users(sam_account_name);
CREATE INDEX idx_users_email ON ad_users(email_address);
CREATE INDEX idx_users_employee_id ON ad_users(employee_id);
CREATE INDEX idx_users_dept_code ON ad_users(department_code);
CREATE INDEX idx_users_sync_status ON ad_users(sync_status);
CREATE INDEX idx_users_last_sync ON ad_users(last_sync_date);

CREATE INDEX idx_ext_attr_user_id ON ad_user_extended_attributes(user_id);
CREATE INDEX idx_ext_attr_name ON ad_user_extended_attributes(attribute_name);

CREATE INDEX idx_sync_log_session ON ad_sync_log(sync_session_id);
CREATE INDEX idx_sync_log_type ON ad_sync_log(sync_type);
CREATE INDEX idx_sync_log_date ON ad_sync_log(created_date);

-- Проверяем что таблицы созданы
SELECT table_name, created FROM user_tables 
WHERE table_name IN ('AD_USERS', 'AD_USER_EXTENDED_ATTRIBUTES', 'AD_SYNC_LOG')
ORDER BY table_name;
```

---

#
CREATE OR REPLACE PACKAGE AD_SYNC_SERVICE.PKG_AD_SYNC AS

  -- КОНСТАНТЫ
  C_SUCCESS   CONSTANT VARCHAR2(10) := 'SUCCESS';
  C_ERROR     CONSTANT VARCHAR2(10) := 'ERROR';
  C_WARNING   CONSTANT VARCHAR2(10) := 'WARNING';
  C_ACTIVE    CONSTANT VARCHAR2(10) := 'ACTIVE';
  C_INACTIVE  CONSTANT VARCHAR2(10) := 'INACTIVE';

  -- КОНФИГУРАЦИЯ 
  TYPE t_config_rec IS RECORD (
    ldap_host         VARCHAR2(256),
    ldap_port         NUMBER,
    user_base_dn      VARCHAR2(512),
    bind_dn           VARCHAR2(512),
    bind_password     VARCHAR2(256),
    batch_size        NUMBER,
    user_filter       VARCHAR2(512),
    timeout_seconds   NUMBER,
    max_retries       NUMBER
  );

  -- МАССИВ АТРИБУТОВ
  TYPE t_required_attrs IS TABLE OF VARCHAR2(256) INDEX BY PLS_INTEGER;

  -- ОСНОВНЫЕ ФУНКЦИИ
  FUNCTION get_config RETURN t_config_rec;
  FUNCTION generate_session_id RETURN VARCHAR2;
  FUNCTION get_required_user_attributes RETURN t_required_attrs;
  
  FUNCTION get_ldap_attribute_value(
    p_session IN DBMS_LDAP.SESSION,
    p_entry IN DBMS_LDAP.MESSAGE,
    p_attribute_name IN VARCHAR2
  ) RETURN VARCHAR2;

  -- ФУНКЦИИ ИССЛЕДОВАНИЯ
  PROCEDURE show_user_attributes(p_sam_account VARCHAR2 DEFAULT NULL);
  PROCEDURE test_ldap_connection;

  -- ЛОГИРОВАНИЕ
  PROCEDURE log_sync_event(
    p_session_id    IN VARCHAR2,
    p_sync_type     IN VARCHAR2,
    p_operation     IN VARCHAR2,
    p_object_id     IN VARCHAR2,
    p_status        IN VARCHAR2,
    p_start_time    IN TIMESTAMP,
    p_end_time      IN TIMESTAMP DEFAULT SYSTIMESTAMP,
    p_records_proc  IN NUMBER DEFAULT 0,
    p_records_succ  IN NUMBER DEFAULT 0,
    p_records_err   IN NUMBER DEFAULT 0,
    p_error_msg     IN VARCHAR2 DEFAULT NULL,
    p_detailed_log  IN CLOB DEFAULT NULL
  );

  -- ОСНОВНАЯ ПРОЦЕДУРА СИНХРОНИЗАЦИИ
  PROCEDURE sync_users_only;

END PKG_AD_SYNC;
/

-- ============================================================================
-- ТЕЛО ПАКЕТА
-- ============================================================================

CREATE OR REPLACE PACKAGE BODY AD_SYNC_SERVICE.PKG_AD_SYNC AS

  -- СОБСТВЕННАЯ ФУНКЦИЯ ЗАДЕРЖКИ (ВМЕСТО DBMS_LOCK.SLEEP)
  PROCEDURE custom_sleep(p_seconds IN NUMBER) IS
    l_start_time DATE;
    l_current_time DATE;
    l_dummy NUMBER;
  BEGIN
    l_start_time := SYSDATE;
    LOOP
      SELECT 1 INTO l_dummy FROM dual WHERE ROWNUM = 1;
      l_current_time := SYSDATE;
      EXIT WHEN (l_current_time - l_start_time) * 24 * 3600 >= p_seconds;
    END LOOP;
  END custom_sleep;

  
  FUNCTION get_required_user_attributes RETURN t_required_attrs IS
    l_attrs t_required_attrs;
  BEGIN
   
    l_attrs(1)  := 'sAMAccountName';      
    l_attrs(2)  := 'name';                
    l_attrs(3)  := 'description';         
    l_attrs(4)  := 'mail';                
    l_attrs(5)  := 'ipPhone';             
    l_attrs(6)  := 'l';                   
    l_attrs(7)  := 'employeeID';          
    l_attrs(8)  := 'department';          
    l_attrs(9)  := 'PSKBKodDivision';     
    l_attrs(10) := 'streetAddress';       
    l_attrs(11) := 'title';              
    l_attrs(12) := 'company';             
    l_attrs(13) := 'manager';            
    
    
    l_attrs(14) := 'displayName';
    l_attrs(15) := 'distinguishedName';
    l_attrs(16) := 'userPrincipalName';
    l_attrs(17) := 'telephoneNumber';
    l_attrs(18) := 'mobile';
    l_attrs(19) := 'physicalDeliveryOfficeName';
    l_attrs(20) := 'whenCreated';
    l_attrs(21) := 'userAccountControl';
    l_attrs(22) := 'memberOf';
    l_attrs(23) := 'cn';
    l_attrs(24) := 'givenName';
    l_attrs(25) := 'sn';
    
    -- МЕСТО ДЛЯ ДОБАВЛЕНИЯ НОВЫХ АТРИБУТОВ:
    -- l_attrs(26) := 'новый_атрибут';
    
    RETURN l_attrs;
  END get_required_user_attributes;

  -- ИЗВЛЕЧЕНИЕ ИМЕНИ ИЗ DN
  FUNCTION extract_name_from_dn(p_dn VARCHAR2) RETURN VARCHAR2 IS
    l_start_pos NUMBER;
    l_end_pos   NUMBER;
    l_result    VARCHAR2(256);
  BEGIN
    IF p_dn IS NULL THEN
      RETURN 'UNKNOWN';
    END IF;
    
    l_start_pos := INSTR(UPPER(p_dn), 'CN=');
    IF l_start_pos > 0 THEN
      l_start_pos := l_start_pos + 3;
      l_end_pos := INSTR(p_dn, ',', l_start_pos);
      IF l_end_pos = 0 THEN
        l_end_pos := LENGTH(p_dn) + 1;
      END IF;
      l_result := TRIM(SUBSTR(p_dn, l_start_pos, l_end_pos - l_start_pos));
    ELSE
      l_result := 'USER_' || TO_CHAR(SYSDATE, 'HH24MISS');
    END IF;
    
    RETURN l_result;
  END extract_name_from_dn;

  -- ПОЛУЧЕНИЕ ЗНАЧЕНИЯ
  FUNCTION get_ldap_attribute_value(
    p_session IN DBMS_LDAP.SESSION,
    p_entry IN DBMS_LDAP.MESSAGE,
    p_attribute_name IN VARCHAR2
  ) RETURN VARCHAR2 IS
    l_values      DBMS_LDAP.STRING_COLLECTION;
    l_value_count NUMBER;
  BEGIN
    l_values := DBMS_LDAP.get_values(
      ld => p_session,
      ldapentry => p_entry,
      attr => p_attribute_name
    );
    
    l_value_count := DBMS_LDAP.count_values(l_values);
    IF l_value_count > 0 THEN
      RETURN l_values(l_values.FIRST);
    ELSE
      RETURN NULL;
    END IF;
    
  EXCEPTION
    WHEN OTHERS THEN
      RETURN NULL;
  END get_ldap_attribute_value;

  -- КОНФИГУРАЦИЯ (НАСТРОИТЬ ПОД СВОИ ПАРАМЕТРЫ!)
  FUNCTION get_config RETURN t_config_rec IS
    l_config t_config_rec;
  BEGIN
    CONF
    
   
    l_config.batch_size := 50;  -- Уменьшено для стабильности
    l_config.user_filter := '(&(objectClass=person)(sAMAccountName=*)(!(userAccountControl:1.2.840.113556.1.4.803:=2)))';
    l_config.timeout_seconds := 300;
    l_config.max_retries := 3;

    RETURN l_config;
  END get_config;

  -- ГЕНЕРАЦИЯ ID СЕССИИ
  FUNCTION generate_session_id RETURN VARCHAR2 IS
  BEGIN
    RETURN 'SYNC_' || TO_CHAR(SYSDATE, 'YYYYMMDD_HH24MISS') || '_' || 
           LPAD(TRUNC(DBMS_RANDOM.VALUE(1000, 9999)), 4, '0');
  END generate_session_id;

  -- ЛОГИРОВАНИЕ СОБЫТИЙ
  PROCEDURE log_sync_event(
    p_session_id    IN VARCHAR2,
    p_sync_type     IN VARCHAR2,
    p_operation     IN VARCHAR2,
    p_object_id     IN VARCHAR2,
    p_status        IN VARCHAR2,
    p_start_time    IN TIMESTAMP,
    p_end_time      IN TIMESTAMP DEFAULT SYSTIMESTAMP,
    p_records_proc  IN NUMBER DEFAULT 0,
    p_records_succ  IN NUMBER DEFAULT 0,
    p_records_err   IN NUMBER DEFAULT 0,
    p_error_msg     IN VARCHAR2 DEFAULT NULL,
    p_detailed_log  IN CLOB DEFAULT NULL
  ) IS
    PRAGMA AUTONOMOUS_TRANSACTION;
  BEGIN
    INSERT INTO ad_sync_log (
      sync_session_id, sync_type, sync_operation, object_identifier, sync_status,
      start_time, end_time, duration_seconds, records_processed, records_success, 
      records_error, error_message, detailed_log, created_date, created_by
    ) VALUES (
      p_session_id, p_sync_type, p_operation, p_object_id, p_status,
      p_start_time, p_end_time, 
      CASE WHEN p_end_time > p_start_time 
           THEN EXTRACT(SECOND FROM (p_end_time - p_start_time))
           ELSE 0 END,
      p_records_proc, p_records_succ, p_records_err, 
      SUBSTR(p_error_msg, 1, 4000), p_detailed_log, SYSDATE, USER
    );
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN NULL;
  END log_sync_event;

  -- ТЕСТ ПОДКЛЮЧЕНИЯ К LDAP
  PROCEDURE test_ldap_connection IS
    l_config  t_config_rec;
    l_session DBMS_LDAP.SESSION;
    l_retval  PLS_INTEGER;
  BEGIN
    l_config := get_config();
    
    DBMS_OUTPUT.ENABLE(1000000);
    DBMS_OUTPUT.PUT_LINE('=== ТЕСТ ПОДКЛЮЧЕНИЯ ===');
    DBMS_OUTPUT.PUT_LINE('Сервер: ' || l_config.ldap_host || ':' || l_config.ldap_port);
    
    BEGIN
      l_session := DBMS_LDAP.init(l_config.ldap_host, l_config.ldap_port);
      DBMS_OUTPUT.PUT_LINE('✓ Соединение установлено');
      
      l_retval := DBMS_LDAP.simple_bind_s(l_session, l_config.bind_dn, l_config.bind_password);
      
      IF l_retval = DBMS_LDAP.SUCCESS THEN
        DBMS_OUTPUT.PUT_LINE('✓ Аутентификация успешна');
      ELSE
        DBMS_OUTPUT.PUT_LINE('✗ Ошибка аутентификации: ' || l_retval);
      END IF;
      
      l_retval := DBMS_LDAP.unbind_s(l_session);
      
    EXCEPTION
      WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('✗ Ошибка подключения: ' || SQLERRM);
    END;
    
    DBMS_OUTPUT.PUT_LINE('===============================');
  END test_ldap_connection;

  -- ПОКАЗАТЬ АТРИБУТЫ ПОЛЬЗОВАТЕЛЯ (ДЛЯ ОТЛАДКИ)
  PROCEDURE show_user_attributes(p_sam_account VARCHAR2 DEFAULT NULL) IS
    l_config      t_config_rec;
    l_session     DBMS_LDAP.SESSION;
    l_retval      PLS_INTEGER;
    l_message     DBMS_LDAP.MESSAGE;
    l_entry       DBMS_LDAP.MESSAGE;
    l_dn          VARCHAR2(2000);
    l_attrs       DBMS_LDAP.STRING_COLLECTION;
    l_attr_name   VARCHAR2(256);
    l_attr_value  VARCHAR2(4000);
    l_ber_element DBMS_LDAP.BER_ELEMENT;
    l_filter      VARCHAR2(256);
    l_count       NUMBER := 0;
  BEGIN
    l_config := get_config();
    
    IF p_sam_account IS NOT NULL THEN
      l_filter := '(&(objectClass=person)(sAMAccountName=' || p_sam_account || '))';
    ELSE
      l_filter := '(&(objectClass=person)(sAMAccountName=*))';
    END IF;
    
    DBMS_OUTPUT.ENABLE(1000000);
    DBMS_OUTPUT.PUT_LINE('=== АТРИБУТЫ ПОЛЬЗОВАТЕЛЯ ===');
    
    l_session := DBMS_LDAP.init(l_config.ldap_host, l_config.ldap_port);
    l_retval := DBMS_LDAP.simple_bind_s(l_session, l_config.bind_dn, l_config.bind_password);
    
    IF l_retval = DBMS_LDAP.SUCCESS THEN
      l_retval := DBMS_LDAP.search_s(
        ld => l_session,
        base => l_config.user_base_dn,
        scope => DBMS_LDAP.SCOPE_SUBTREE,
        filter => l_filter,
        attrs => l_attrs,
        attronly => 0,
        res => l_message
      );
      
      IF l_retval = DBMS_LDAP.SUCCESS THEN
        l_entry := DBMS_LDAP.first_entry(l_session, l_message);
        
        IF l_entry IS NOT NULL THEN
          l_dn := DBMS_LDAP.get_dn(l_session, l_entry);
          DBMS_OUTPUT.PUT_LINE('DN: ' || l_dn);
          DBMS_OUTPUT.PUT_LINE('==============================');
          
          l_attr_name := DBMS_LDAP.first_attribute(l_session, l_entry, l_ber_element);
          
          WHILE l_attr_name IS NOT NULL LOOP
            l_attr_value := get_ldap_attribute_value(l_session, l_entry, l_attr_name);
            l_count := l_count + 1;
            
            DBMS_OUTPUT.PUT_LINE(l_count || '. ' || l_attr_name || ' = ' || 
                               SUBSTR(NVL(l_attr_value, '<пусто>'), 1, 100));
            
            l_attr_name := DBMS_LDAP.next_attribute(l_session, l_entry, l_ber_element);
          END LOOP;
        END IF;
      END IF;
    END IF;
    
    l_retval := DBMS_LDAP.unbind_s(l_session);
    DBMS_OUTPUT.PUT_LINE('==============================');
    
  EXCEPTION
    WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('ОШИБКА: ' || SQLERRM);
      IF l_session IS NOT NULL THEN
        l_retval := DBMS_LDAP.unbind_s(l_session);
      END IF;
  END show_user_attributes;

  -- ОСНОВНАЯ ПРОЦЕДУРА СИНХРОНИЗАЦИИ 
  PROCEDURE sync_users_only IS
    l_config        t_config_rec;
    l_session_id    VARCHAR2(50);
    l_start_time    TIMESTAMP;
    l_session       DBMS_LDAP.SESSION;
    l_retval        PLS_INTEGER;
    l_message       DBMS_LDAP.MESSAGE;
    l_entry         DBMS_LDAP.MESSAGE;
    l_dn            VARCHAR2(2000);
    l_sam_account   VARCHAR2(256);
    l_processed     NUMBER := 0;
    l_success       NUMBER := 0;
    l_errors        NUMBER := 0;
    l_retry_count   NUMBER := 0;
    l_attrs         DBMS_LDAP.STRING_COLLECTION;
    l_user_id       VARCHAR2(100);
    
    -- ПЕРЕМЕННЫЕ ДЛЯ ВСЕХ АТРИБУТОВ ПОЛЬЗОВАТЕЛЯ
    l_display_name      VARCHAR2(500);
    l_description       VARCHAR2(1000);
    l_email             VARCHAR2(256);
    l_ip_phone          VARCHAR2(50);
    l_city              VARCHAR2(100);
    l_employee_id       VARCHAR2(50);
    l_department        VARCHAR2(500);
    l_dept_code         VARCHAR2(50);
    l_street_address    VARCHAR2(500);
    l_job_title         VARCHAR2(256);
    l_company           VARCHAR2(256);
    l_manager_dn        VARCHAR2(1000);
    l_manager_name      VARCHAR2(500);
    
  BEGIN
    l_config := get_config();
    l_session_id := generate_session_id();
    l_start_time := SYSTIMESTAMP;

    log_sync_event(l_session_id, 'USERS', 'SYNC_START', 'BULK', 
                   C_SUCCESS, l_start_time);

    -- Помечаем всех пользователей как неактивных
    UPDATE ad_users 
    SET sync_status = C_INACTIVE, last_sync_date = SYSDATE;

    -- ОСНОВНОЙ ЦИКЛ С ПОВТОРНЫМИ ПОПЫТКАМИ
    WHILE l_retry_count < l_config.max_retries LOOP
      BEGIN
        -- Подключение к LDAP
        l_session := DBMS_LDAP.init(l_config.ldap_host, l_config.ldap_port);
        l_retval := DBMS_LDAP.simple_bind_s(l_session, l_config.bind_dn, l_config.bind_password);
        
        IF l_retval = DBMS_LDAP.SUCCESS THEN
          -- Поиск пользователей
          l_retval := DBMS_LDAP.search_s(
            ld => l_session,
            base => l_config.user_base_dn,
            scope => DBMS_LDAP.SCOPE_SUBTREE,
            filter => l_config.user_filter,
            attrs => l_attrs,  -- получаем все атрибуты
            attronly => 0,
            res => l_message
          );
          
          IF l_retval = DBMS_LDAP.SUCCESS THEN
            l_entry := DBMS_LDAP.first_entry(l_session, l_message);
            
            -- ОБРАБАТЫВАЕМ КАЖДОГО 
            WHILE l_entry IS NOT NULL LOOP
              BEGIN
                l_dn := DBMS_LDAP.get_dn(l_session, l_entry);
                l_sam_account := get_ldap_attribute_value(l_session, l_entry, 'sAMAccountName');
                
                IF l_sam_account IS NOT NULL THEN
                  l_user_id := 'U' || TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS') || '_' || l_processed;
                  
                  -- ПОЛУЧАЕМ ВСЕ НУЖНЫЕ АТРИБУТЫ
                  l_display_name := get_ldap_attribute_value(l_session, l_entry, 'name');
                  l_description := get_ldap_attribute_value(l_session, l_entry, 'description');
                  l_email := get_ldap_attribute_value(l_session, l_entry, 'mail');
                  l_ip_phone := get_ldap_attribute_value(l_session, l_entry, 'ipPhone');
                  l_city := get_ldap_attribute_value(l_session, l_entry, 'l');
                  l_employee_id := get_ldap_attribute_value(l_session, l_entry, 'employeeID');
                  l_department := get_ldap_attribute_value(l_session, l_entry, 'department');
                  l_dept_code := get_ldap_attribute_value(l_session, l_entry, 'PSKBKodDivision');
                  l_street_address := get_ldap_attribute_value(l_session, l_entry, 'streetAddress');
                  l_job_title := get_ldap_attribute_value(l_session, l_entry, 'title');
                  l_company := get_ldap_attribute_value(l_session, l_entry, 'company');
                  l_manager_dn := get_ldap_attribute_value(l_session, l_entry, 'manager');
                  l_manager_name := extract_name_from_dn(l_manager_dn);
                  
                  -- СОХРАНЯЕМ БАЗЕ
                  MERGE INTO ad_users tgt
                  USING (
                    SELECT l_sam_account as sam_account_name, l_dn as distinguished_name
                    FROM dual
                  ) src ON (tgt.sam_account_name = src.sam_account_name)
                  WHEN MATCHED THEN UPDATE SET
                    distinguished_name = src.distinguished_name,
                    display_name = l_display_name,
                    description_field = l_description,
                    email_address = l_email,
                    phone_number = l_ip_phone,
                    city_location = l_city,
                    employee_id = l_employee_id,
                    department_name = l_department,
                    department_code = l_dept_code,
                    street_address = l_street_address,
                    job_title = l_job_title,
                    company_name = l_company,
                    manager_dn = l_manager_dn,
                    manager_name = l_manager_name,
                    sync_status = C_ACTIVE,
                    last_sync_date = SYSDATE,
                    modified_by = USER,
                    modified_date = SYSDATE
                  WHEN NOT MATCHED THEN INSERT (
                    user_id, sam_account_name, distinguished_name,
                    display_name, description_field, email_address, phone_number,
                    city_location, employee_id, department_name, department_code,
                    street_address, job_title, company_name, manager_dn, manager_name,
                    sync_status, created_date, created_by, last_sync_date
                  ) VALUES (
                    l_user_id, src.sam_account_name, src.distinguished_name,
                    l_display_name, l_description, l_email, l_ip_phone,
                    l_city, l_employee_id, l_department, l_dept_code,
                    l_street_address, l_job_title, l_company, l_manager_dn, l_manager_name,
                    C_ACTIVE, SYSDATE, USER, SYSDATE
                  );
                  
                  l_success := l_success + 1;
                  
                  -- Периодические коммиты для избежания Internal Server Error
                  IF MOD(l_success, l_config.batch_size) = 0 THEN
                    COMMIT;
                  END IF;
                END IF;
                
              EXCEPTION
                WHEN OTHERS THEN
                  l_errors := l_errors + 1;
                  log_sync_event(l_session_id, 'USERS', 'USER_ERROR', 
                                l_sam_account, C_ERROR, l_start_time, 
                                p_error_msg => SQLERRM);
              END;
              
              l_processed := l_processed + 1;
              l_entry := DBMS_LDAP.next_entry(l_session, l_entry);
            END LOOP;
            
            EXIT; -- Успешно завершили
          END IF;
        END IF;
        
        -- Закрываем соединение
        l_retval := DBMS_LDAP.unbind_s(l_session);
        
      EXCEPTION
        WHEN OTHERS THEN
          l_retry_count := l_retry_count + 1;
          
          -- Безопасное закрытие соединения
          IF l_session IS NOT NULL THEN
            BEGIN
              l_retval := DBMS_LDAP.unbind_s(l_session);
            EXCEPTION WHEN OTHERS THEN NULL;
            END;
          END IF;
          
          -- Проверяем лимит повторов
          IF l_retry_count >= l_config.max_retries THEN
            log_sync_event(l_session_id, 'USERS', 'LDAP_FINAL_ERROR', 
                          'CONNECTION', C_ERROR, l_start_time, p_error_msg => SQLERRM);
            RAISE;
          ELSE
            log_sync_event(l_session_id, 'USERS', 'RETRY_' || l_retry_count,
                          'CONNECTION', C_WARNING, l_start_time, p_error_msg => SQLERRM);
            custom_sleep(2); -- Пауза перед повтором
          END IF;
      END;
    END LOOP;

    COMMIT;
    
    
    DELETE FROM ad_users WHERE sync_status = C_INACTIVE;
    COMMIT;

    -- Финальное логирование
    log_sync_event(l_session_id, 'USERS', 'SYNC_COMPLETE', 'BULK',
                   CASE WHEN l_errors = 0 THEN C_SUCCESS ELSE C_WARNING END,
                   l_start_time, p_records_proc => l_processed,
                   p_records_succ => l_success, p_records_err => l_errors);

  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      log_sync_event(l_session_id, 'USERS', 'SYNC_FAILED', 'BULK',
                     C_ERROR, l_start_time, p_error_msg => SQLERRM);
      RAISE;
  END sync_users_only;

END PKG_AD_SYNC;
/
```

-- ============================================================================
-- УДОБНЫЕ ПРЕДСТАВЛЕНИЯ ДЛЯ РАБОТЫ С ДАННЫМИ
-- ============================================================================

-- Основное представление
CREATE OR REPLACE VIEW v_ad_users AS
SELECT 
  user_id,
  sam_account_name as login,
  display_name as full_name,
  email_address as email,
  phone_number as phone,
  job_title as position,
  department_name as department,
  department_code as dept_code,
  manager_name as manager,
  city_location as city,
  company_name as company,
  employee_id as emp_id,
  street_address as address,
  TO_CHAR(last_sync_date, 'DD.MM.YYYY HH24:MI') as last_sync,
  sync_status
FROM ad_users
WHERE sync_status = 'ACTIVE'
ORDER BY display_name;

-- Представление для быстрого поиска
CREATE OR REPLACE VIEW v_user_search AS
SELECT 
  sam_account_name as login,
  display_name as name,
  email_address as email,
  department_name as dept,
  job_title as position,
  phone_number as phone
FROM ad_users
WHERE sync_status = 'ACTIVE';
```

---





SELECT object_name, object_type, status,
       TO_CHAR(last_ddl_time, 'DD.MM.YYYY HH24:MI:SS') as compiled_time
FROM user_objects 
WHERE object_name = 'PKG_AD_SYNC'
ORDER BY object_type;

-- Результат должен показать STATUS = 'VALID'
```

### 4.3 
BEGIN
  AD_SYNC_SERVICE.PKG_AD_SYNC.test_ldap_connection;
END;
/

-- 
```sql
-- Смотрим атрибуты первого найденного пользователя
BEGIN
  AD_SYNC_SERVICE.PKG_AD_SYNC.show_user_attributes;
END;
/

-- Смотрим атрибуты конкретного пользователя
BEGIN
  AD_SYNC_SERVICE.PKG_AD_SYNC.show_user_attributes('логин.пользователя');
END;
/
```

### 5.1 Первый запуск

```sql
-- Запуск 
BEGIN
  DBMS_OUTPUT.ENABLE(1000000);
  DBMS_OUTPUT.PUT_LINE('=== ЗАПУСК СИНХРОНИЗАЦИИ  ===');
  
  AD_SYNC_SERVICE.PKG_AD_SYNC.sync_users_only;
  
  DBMS_OUTPUT.PUT_LINE('=== СИНХРОНИЗАЦИЯ ЗАВЕРШЕНА ===');
END;
/
```

### 5.2 Проверка результатов

```sql
-- Проверяем синхронизированных 
SELECT COUNT(*) as total_users, 
       COUNT(CASE WHEN sync_status = 'ACTIVE' THEN 1 END) as active_users
FROM ad_users;

-- Смотрим первых
SELECT login, full_name, email, phone, position, department
FROM v_ad_users
WHERE ROWNUM <= 10;

-- Проверяем логи синхронизации
SELECT sync_operation, sync_status, records_success, records_error,
       TO_CHAR(created_date, 'DD.MM.YYYY HH24:MI:SS') as sync_time,
       SUBSTR(error_message, 1, 100) as error_preview
FROM ad_sync_log
ORDER BY created_date DESC
FETCH FIRST 5 ROWS ONLY;
```

---

## 🔧 УСТРАНЕНИЕ ПРОБЛЕМ

### Проблема: Internal Server Error
```sql
-- Уменьшите batch_size в конфигурации:
-- l_config.batch_size := 20;  -- вместо 50
```

### Проблема: Не находит 
```sql
-- Проверьте фильтр и base DN:
BEGIN
  AD_SYNC_SERVICE.PKG_AD_SYNC.show_user_attributes;
END;
/
```

### Проблема: Ошибка 
```sql
-- Проверьте credentials:
BEGIN
  AD_SYNC_SERVICE.PKG_AD_SYNC.test_ldap_connection;
END;
/
```

### Проблема: Некорректные атрибуты
```sql
-- Посмотрите какие атрибуты реально доступны:
BEGIN
  AD_SYNC_SERVICE.PKG_AD_SYNC.show_user_attributes('тестовый.логин');
END;
/
```

---

## 📋 

### Ручной запуск:
```sql
BEGIN
  AD_SYNC_SERVICE.PKG_AD_SYNC.sync_users_only;
END;
/
```

### Автоматический запуск (через DBMS_SCHEDULER):
```sql
-- Создание джоба для ежедневной синхронизации в 6:00
BEGIN
  DBMS_SCHEDULER.create_job (
    job_name        => 'AD_SYNC_DAILY',
    job_type        => 'PLSQL_BLOCK',
    job_action      => 'BEGIN AD_SYNC_SERVICE.PKG_AD_SYNC.sync_users_only; END;',
    start_date      => SYSTIMESTAMP,
    repeat_interval => 'FREQ=DAILY; BYHOUR=6; BYMINUTE=0; BYSECOND=0',
    enabled         => TRUE
  );
END;
/
```

---


1. **Добавьте в функцию `get_required_user_attributes()`:**
   ```sql
   l_attrs(26) := 'новый_атрибут';
   ```

2. **Если нужна отдельная колонка, добавьте в таблицу:**
   ```sql
   ALTER TABLE ad_users ADD new_field VARCHAR2(256);
   ```

3. **Обновите процедуру `sync_users_only`:**
   ```sql
   l_new_field := get_ldap_attribute_value(l_session, l_entry, 'новый_атрибут');
   -- И добавьте в MERGE операцию
   ```

---



```sql
-- Финальная проверка системы:
SELECT 'Users synced: ' || COUNT(*) as status FROM ad_users WHERE sync_status = 'ACTIVE'
UNION ALL
SELECT 'Last sync: ' || TO_CHAR(MAX(last_sync_date), 'DD.MM.YYYY HH24:MI:SS') FROM ad_users
UNION ALL  
SELECT 'Package status: ' || status FROM user_objects WHERE object_name = 'PKG_AD_SYNC' AND object_type = 'PACKAGE BODY';
```

--
