
**1. Создание родительской таблицы журнала:**
```sql
CREATE TABLE audit_log (
    audit_id NUMBER GENERATED BY DEFAULT AS IDENTITY,
    table_name VARCHAR2(128) NOT NULL,
    record_id VARCHAR2(100) NOT NULL,
    record_name VARCHAR2(500),
    event_type VARCHAR2(20) NOT NULL,
    event_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    user_name VARCHAR2(100) DEFAULT USER,
    session_id NUMBER DEFAULT SYS_CONTEXT('USERENV', 'SESSIONID'),
    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT audit_log_pk PRIMARY KEY (audit_id)
);
```

**2. Создание детальной таблицы изменений:**
```sql
CREATE TABLE audit_log_details (
    detail_id NUMBER GENERATED BY DEFAULT AS IDENTITY,
    audit_id NUMBER NOT NULL,
    column_name VARCHAR2(128) NOT NULL,
    old_value CLOB,
    new_value CLOB,
    data_type VARCHAR2(50),
    change_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    user_name VARCHAR2(100) DEFAULT USER,
    CONSTRAINT audit_details_pk PRIMARY KEY (detail_id)
);
```

**3. Добавление внешнего ключа:**
```sql
ALTER TABLE audit_log_details 
ADD CONSTRAINT fk_audit_details_log 
FOREIGN KEY (audit_id) REFERENCES audit_log(audit_id);
```

**4. Создание индексов:**
```sql
CREATE INDEX idx_audit_log_table_date ON audit_log(table_name, event_date);
```

```sql
CREATE INDEX idx_audit_log_record_id ON audit_log(record_id);
```

```sql
CREATE INDEX idx_audit_details_audit_id ON audit_log_details(audit_id);
```

## Ключевые изменения для совместимости

### 1. Убраны проблемные элементы[1][2][3][4]

- Удален `APEX_APPLICATION.G_USER` (заменен на `USER`)
- Упрощен синтаксис IDENTITY колонок
- Разделены команды создания ограничений

### 2. Правильный синтаксис IDENTITY для Oracle Database 23ai[5][6][7]

В Oracle Database 23ai рекомендуется использовать:
- `GENERATED BY DEFAULT AS IDENTITY` вместо `GENERATED ALWAYS AS IDENTITY`
- Это позволяет избежать ошибок при работе с триггерами аудита

### 3. Упрощенные DEFAULT значения

Вместо сложных выражений с APEX используются стандартные функции Oracle:
- `USER` вместо `APEX_APPLICATION.G_USER`
- `CURRENT_TIMESTAMP` вместо сложных выражений

## Создание пакета аудита

После успешного создания таблиц, создайте пакет через **SQL Workshop → Object Browser → Create Package**:

```sql
CREATE OR REPLACE PACKAGE audit_pkg AS
    PROCEDURE log_audit_event(
        p_table_name IN VARCHAR2,
        p_record_id IN VARCHAR2,
        p_record_name IN VARCHAR2,
        p_event_type IN VARCHAR2,
        p_audit_id OUT NUMBER
    );
    
    PROCEDURE log_column_change(
        p_audit_id IN NUMBER,
        p_column_name IN VARCHAR2,
        p_old_value IN CLOB,
        p_new_value IN CLOB,
        p_data_type IN VARCHAR2 DEFAULT 'VARCHAR2'
    );
    
    PROCEDURE apply_audit_to_table(
        p_table_name IN VARCHAR2,
        p_key_column IN VARCHAR2,
        p_name_column IN VARCHAR2 DEFAULT NULL
    );
END audit_pkg;
/
```

**Тело пакета:**
```sql
CREATE OR REPLACE PACKAGE BODY audit_pkg AS
    
    PROCEDURE log_audit_event(
        p_table_name IN VARCHAR2,
        p_record_id IN VARCHAR2,
        p_record_name IN VARCHAR2,
        p_event_type IN VARCHAR2,
        p_audit_id OUT NUMBER
    ) AS
        PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
        INSERT INTO audit_log (
            table_name,
            record_id, 
            record_name, 
            event_type
        ) VALUES (
            UPPER(p_table_name),
            p_record_id,
            p_record_name,
            UPPER(p_event_type)
        ) RETURNING audit_id INTO p_audit_id;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END log_audit_event;
    
    PROCEDURE log_column_change(
        p_audit_id IN NUMBER,
        p_column_name IN VARCHAR2,
        p_old_value IN CLOB,
        p_new_value IN CLOB,
        p_data_type IN VARCHAR2 DEFAULT 'VARCHAR2'
    ) AS
        PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
        IF (p_old_value IS NULL AND p_new_value IS NOT NULL) OR
           (p_old_value IS NOT NULL AND p_new_value IS NULL) OR
           (p_old_value != p_new_value) THEN
            
            INSERT INTO audit_log_details (
                audit_id,
                column_name,
                old_value,
                new_value,
                data_type
            ) VALUES (
                p_audit_id,
                UPPER(p_column_name),
                p_old_value,
                p_new_value,
                p_data_type
            );
        END IF;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END log_column_change;
    
    PROCEDURE apply_audit_to_table(
        p_table_name IN VARCHAR2,
        p_key_column IN VARCHAR2,
        p_name_column IN VARCHAR2 DEFAULT NULL
    ) AS
        l_trigger_sql CLOB;
    BEGIN
        l_trigger_sql := 'CREATE OR REPLACE TRIGGER trg_audit_' || LOWER(p_table_name) || '
    AFTER INSERT OR UPDATE OR DELETE ON ' || p_table_name || '
    FOR EACH ROW
DECLARE
    v_audit_id NUMBER;
    v_record_id VARCHAR2(100);
    v_record_name VARCHAR2(500);
    v_event_type VARCHAR2(20);
BEGIN
    IF INSERTING THEN
        v_event_type := ''INSERT'';
        v_record_id := TO_CHAR(:NEW.' || p_key_column || ');
        v_record_name := ' || CASE WHEN p_name_column IS NOT NULL 
                                    THEN 'TO_CHAR(:NEW.' || p_name_column || ')' 
                                    ELSE 'NULL' END || ';
    ELSIF UPDATING THEN
        v_event_type := ''UPDATE'';
        v_record_id := TO_CHAR(:NEW.' || p_key_column || ');
        v_record_name := ' || CASE WHEN p_name_column IS NOT NULL 
                                    THEN 'TO_CHAR(:NEW.' || p_name_column || ')' 
                                    ELSE 'NULL' END || ';
    ELSIF DELETING THEN
        v_event_type := ''DELETE'';
        v_record_id := TO_CHAR(:OLD.' || p_key_column || ');
        v_record_name := ' || CASE WHEN p_name_column IS NOT NULL 
                                    THEN 'TO_CHAR(:OLD.' || p_name_column || ')' 
                                    ELSE 'NULL' END || ';
    END IF;
    
    audit_pkg.log_audit_event(
        p_table_name => ''' || p_table_name || ''',
        p_record_id => v_record_id,
        p_record_name => v_record_name,
        p_event_type => v_event_type,
        p_audit_id => v_audit_id
    );
    
    -- Простой пример для основных колонок
    IF INSERTING THEN
        audit_pkg.log_column_change(v_audit_id, ''' || p_key_column || ''', NULL, TO_CLOB(:NEW.' || p_key_column || '), ''NUMBER'');
    ELSIF UPDATING THEN
        audit_pkg.log_column_change(v_audit_id, ''' || p_key_column || ''', TO_CLOB(:OLD.' || p_key_column || '), TO_CLOB(:NEW.' || p_key_column || '), ''NUMBER'');
    ELSIF DELETING THEN
        audit_pkg.log_column_change(v_audit_id, ''' || p_key_column || ''', TO_CLOB(:OLD.' || p_key_column || '), NULL, ''NUMBER'');
    END IF;
END;';
        
        EXECUTE IMMEDIATE l_trigger_sql;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE;
    END apply_audit_to_table;
    
END audit_pkg;
/
```

## Применение аудита к таблице

После создания пакета примените аудит к вашей таблице:

```sql
BEGIN
    audit_pkg.apply_audit_to_table(
        p_table_name => 'EMPLOYEES',
        p_key_column => 'EMPLOYEE_ID',
        p_name_column => 'LAST_NAME'
    );
END;
/
```

## 