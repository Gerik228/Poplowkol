
```sql
-- Удаляем триггеры аудита
BEGIN
  FOR t IN (SELECT trigger_name FROM user_triggers WHERE trigger_name LIKE 'TRG_AUDIT_%') LOOP
    EXECUTE IMMEDIATE 'DROP TRIGGER ' || t.trigger_name;
  END LOOP;
END;
/

-- Удаляем пакет аудита, если был
BEGIN
  EXECUTE IMMEDIATE 'DROP PACKAGE audit_pkg';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

-- Удаляем таблицы аудита
BEGIN
  EXECUTE IMMEDIATE 'DROP TABLE audit_log_details CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/
BEGIN
  EXECUTE IMMEDIATE 'DROP TABLE audit_log CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

-- Удаляем представления аудита
BEGIN
  EXECUTE IMMEDIATE 'DROP VIEW v_audit_full';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/
BEGIN
  EXECUTE IMMEDIATE 'DROP VIEW v_audit_summary';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/
```

## 2. Создаём новые таблицы аудита

```sql
CREATE TABLE audit_log (
    audit_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    table_name VARCHAR2(128) NOT NULL,
    record_id VARCHAR2(100) NOT NULL,
    record_name VARCHAR2(500),
    event_type VARCHAR2(20) NOT NULL,
    event_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    user_name VARCHAR2(100) DEFAULT USER,
    session_id NUMBER DEFAULT SYS_CONTEXT('USERENV', 'SESSIONID'),
    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
/
CREATE TABLE audit_log_details (
    detail_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    audit_id NUMBER NOT NULL,
    column_name VARCHAR2(128) NOT NULL,
    old_value CLOB,
    new_value CLOB,
    data_type VARCHAR2(50),
    change_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    user_name VARCHAR2(100) DEFAULT USER
);
/
ALTER TABLE audit_log_details 
ADD CONSTRAINT fk_audit_details_log FOREIGN KEY (audit_id) REFERENCES audit_log(audit_id);
/
```

## 3. Универсальный пакет для генерации триггеров

### Спецификация

```sql
CREATE OR REPLACE PACKAGE audit_pkg AS
  PROCEDURE create_audit_trigger(
    p_table_name   IN VARCHAR2,
    p_pk_column    IN VARCHAR2,
    p_title_column IN VARCHAR2 DEFAULT NULL
  );
END audit_pkg;
/
```

### Тело

```sql
CREATE OR REPLACE PACKAGE BODY audit_pkg AS
  PROCEDURE create_audit_trigger(
    p_table_name   IN VARCHAR2,
    p_pk_column    IN VARCHAR2,
    p_title_column IN VARCHAR2 DEFAULT NULL
  ) AS
    l_trigger_sql CLOB;
    l_cols        VARCHAR2(32767);
    cursor_cols   SYS_REFCURSOR;
    l_column_name VARCHAR2(128);
    l_data_type   VARCHAR2(128);
  BEGIN
    -- Собираем список всех столбцов таблицы, кроме PK и virtual/identity columns
    l_cols := '';
    OPEN cursor_cols FOR
      SELECT column_name, data_type
        FROM user_tab_columns
       WHERE table_name = UPPER(p_table_name)
         AND column_name <> UPPER(p_pk_column)
         AND identity_column = 'NO'
         AND virtual_column = 'NO';
    
    -- Начинаем формировать триггер
    l_trigger_sql := 'CREATE OR REPLACE TRIGGER TRG_AUDIT_' || p_table_name ||
      '
AFTER INSERT OR UPDATE OR DELETE ON ' || p_table_name || '
FOR EACH ROW
DECLARE
  v_audit_id NUMBER;
  v_pk_val VARCHAR2(100);
  v_title_val VARCHAR2(500);
  v_event_type VARCHAR2(20);
BEGIN
  IF INSERTING THEN
    v_event_type := ''INSERT'';
    v_pk_val := TO_CHAR(:NEW.' || p_pk_column || ');
    v_title_val := ' || CASE WHEN p_title_column IS NOT NULL
                              THEN 'TO_CHAR(:NEW.' || p_title_column || ')'
                              ELSE 'NULL' END || ';
  ELSIF UPDATING THEN
    v_event_type := ''UPDATE'';
    v_pk_val := TO_CHAR(:NEW.' || p_pk_column || ');
    v_title_val := ' || CASE WHEN p_title_column IS NOT NULL
                              THEN 'TO_CHAR(:NEW.' || p_title_column || ')'
                              ELSE 'NULL' END || ';
  ELSIF DELETING THEN
    v_event_type := ''DELETE'';
    v_pk_val := TO_CHAR(:OLD.' || p_pk_column || ');
    v_title_val := ' || CASE WHEN p_title_column IS NOT NULL
                              THEN 'TO_CHAR(:OLD.' || p_title_column || ')'
                              ELSE 'NULL' END || ';
  END IF;

  INSERT INTO audit_log(table_name, record_id, record_name, event_type)
    VALUES (
      ''' || UPPER(p_table_name) || ''',
      v_pk_val,
      v_title_val,
      v_event_type
    ) RETURNING audit_id INTO v_audit_id;
';

    -- Для каждого столбца добавляем обработку INSERT/UPDATE/DELETE
    LOOP
      FETCH cursor_cols INTO l_column_name, l_data_type;
      EXIT WHEN cursor_cols%NOTFOUND;
      
      l_trigger_sql := l_trigger_sql ||
        '
  -- ' || l_column_name || '
  IF INSERTING THEN
    INSERT INTO audit_log_details(audit_id, column_name, old_value, new_value, data_type)
      VALUES(
        v_audit_id, 
        ''' || l_column_name || ''', 
        NULL, 
        TO_CLOB(:NEW.' || l_column_name || '), 
        ''' || l_data_type || '''
      );
  ELSIF UPDATING THEN
    IF NVL(TO_CHAR(:NEW.' || l_column_name || '),''$$NULL$$'') != NVL(TO_CHAR(:OLD.' || l_column_name || '),''$$NULL$$'') THEN
      INSERT INTO audit_log_details(audit_id, column_name, old_value, new_value, data_type)
        VALUES(
          v_audit_id, 
          ''' || l_column_name || ''',
          TO_CLOB(:OLD.' || l_column_name || '),
          TO_CLOB(:NEW.' || l_column_name || '),
          ''' || l_data_type || '''
        );
    END IF;
  ELSIF DELETING THEN
    INSERT INTO audit_log_details(audit_id, column_name, old_value, new_value, data_type)
      VALUES(
        v_audit_id,
        ''' || l_column_name || ''',
        TO_CLOB(:OLD.' || l_column_name || '),
        NULL,
        ''' || l_data_type || '''
      );
  END IF;';
    END LOOP;
    CLOSE cursor_cols;

    l_trigger_sql := l_trigger_sql || '
EXCEPTION WHEN OTHERS THEN NULL;
END;
';

    -- Удаляем старый триггер если есть
    BEGIN
      EXECUTE IMMEDIATE 'DROP TRIGGER TRG_AUDIT_' || p_table_name;
    EXCEPTION WHEN OTHERS THEN NULL;
    END;
    -- Создаём новый триггер
    EXECUTE IMMEDIATE l_trigger_sql;
  END create_audit_trigger;
END audit_pkg;
/
```

## 4. Применяем аудит (создаём триггер для вашей таблицы)

### Пример для таблицы EMPLOYEES:

```sql
BEGIN
  audit_pkg.create_audit_trigger(
    p_table_name   => 'EMPLOYEES',   -- имя таблицы БЕЗ кавычек
    p_pk_column    => 'EMPLOYEE_ID', -- имя PK
    p_title_column => 'LAST_NAME'    -- если нужно отображать "человеческое" имя, иначе NULL
  );
END;
/
```

Если у таблицы нет названия (title column), пишите `NULL`.

## 5. Использование с другими таблицами

Создайте аудит для каждой нужной таблицы, просто вызвав ту же процедуру с нужными параметрами столбцов. Столбцы таблицы автоматически найдутся, и все изменения будут логироваться.

## 6. Проверка результата

Измените любую таблицу, для которой вы создали триггер, и затем выполните:

```sql
-- Родительский журнал
SELECT * FROM audit_log ORDER BY event_date DESC;
-- Детализация изменений
SELECT * FROM audit_log_details ORDER BY change_date DESC;
```



