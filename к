теперь напиши развернутую документацию

# Развернутая документация по автоматической синхронизации таблиц в Oracle APEX 23.1

## Введение

Данная документация описывает комплексное решение для автоматической синхронизации таблиц между удаленными базами данных и локальной базой данных в среде Oracle APEX 23.1 с использованием Oracle Database 19c через database link (dblink)[1][2]. Система обеспечивает надежное дублирование критически важных данных с полным мониторингом и обработкой ошибок.

## Архитектура решения

### Компоненты системы

Система состоит из следующих основных компонентов:

1. **Процедуры валидации и синхронизации**
   - `validate_sync_environment` - комплексная проверка окружения
   - `sync_single_table_advanced` - основная процедура синхронизации
   - `create_smart_sync_job` - создание автоматических заданий

2. **Система мониторинга**
   - Таблица `sync_log` для детального логирования
   - Представление `v_sync_dashboard` для визуального контроля
   - Процедура `manage_sync_jobs` для управления заданиями

3. **Планировщик заданий**
   - Использование DBMS_SCHEDULER для автоматизации[3][4]
   - Гибкая настройка расписания синхронизации
   - Система оповещений и мониторинга

### Архитектурная схема

```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  Удаленная БД   │    │   Database Link  │    │   Локальная БД  │
│  (Источник)     │◄───┤                  ├────►│  (Назначение)   │
│                 │    │                  │    │                 │
└─────────────────┘    └──────────────────┘    └─────────────────┘
         │                       │                       │
         │              ┌────────▼────────┐              │
         │              │  APEX 23.1      │              │
         │              │  SQL Workshop   │              │
         │              └─────────────────┘              │
         │                                               │
    ┌────▼────┐                                    ┌─────▼─────┐
    │ Таблицы │                                    │ Локальные │
    │ данных  │                                    │ копии     │
    └─────────┘                                    └───────────┘
```

## Технические требования

### Системные требования

- **Oracle APEX**: Версия 23.1 или выше[5][6]
- **Oracle Database**: Версия 19c или выше[5]
- **Права доступа**: 
  - `CREATE JOB` для DBMS_SCHEDULER[7]
  - `CREATE TABLE`, `DROP TABLE`
  - `CREATE PROCEDURE`, `CREATE VIEW`

### Настройка database link

Database link должен быть предварительно настроен и протестирован[1][8]:

```sql
-- Проверка существующих dblink
SELECT db_link, username, host FROM user_db_links;

-- Тестирование подключения
SELECT * FROM dual@YOUR_DBLINK;
```

## Структура данных

### Таблица мониторинга sync_log

Основная таблица для хранения истории синхронизации[9]:

```sql
CREATE TABLE sync_log (
    id NUMBER GENERATED ALWAYS AS IDENTITY,
    table_name VARCHAR2(128) NOT NULL,
    sync_date DATE NOT NULL,
    sync_type VARCHAR2(20) NOT NULL DEFAULT 'FULL',
    status VARCHAR2(15) NOT NULL,
    source_row_count NUMBER DEFAULT 0,
    target_row_count NUMBER DEFAULT 0,
    duration_seconds NUMBER,
    validation_result VARCHAR2(4000),
    error_msg VARCHAR2(4000),
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP,
    CONSTRAINT pk_sync_log PRIMARY KEY (id),
    CONSTRAINT chk_sync_status CHECK (status IN ('SUCCESS', 'ERROR', 'WARNING', 'EMPTY_SOURCE')),
    CONSTRAINT chk_sync_type CHECK (sync_type IN ('FULL', 'INCREMENTAL'))
);
```

### Представление для мониторинга

```sql
CREATE OR REPLACE VIEW v_sync_dashboard AS
SELECT 
    table_name,
    sync_type,
    status,
    sync_date,
    source_row_count,
    target_row_count,
    ROUND(duration_seconds, 2) as duration_sec,
    CASE 
        WHEN status = 'SUCCESS' AND sync_date > SYSDATE - 1 THEN 'HEALTHY'
        WHEN status = 'EMPTY_SOURCE' THEN 'EMPTY_SOURCE'
        WHEN status = 'WARNING' THEN 'WARNING'
        WHEN sync_date < SYSDATE - 2 THEN 'OUTDATED'
        ELSE 'ERROR'
    END as health_status,
    SUBSTR(validation_result, 1, 100) as validation_short,
    SUBSTR(error_msg, 1, 200) as error_short,
    created_at
FROM (
    SELECT *,
           ROW_NUMBER() OVER (PARTITION BY table_name ORDER BY sync_date DESC) as rn
    FROM sync_log
) WHERE rn = 1
ORDER BY 
    CASE health_status 
        WHEN 'ERROR' THEN 1 
        WHEN 'WARNING' THEN 2 
        WHEN 'OUTDATED' THEN 3 
        WHEN 'EMPTY_SOURCE' THEN 4 
        ELSE 5 
    END,
    sync_date DESC;
```

## Основные процедуры

### Процедура валидации окружения

Процедура `validate_sync_environment` выполняет комплексную проверку готовности к синхронизации:

```sql
CREATE OR REPLACE PROCEDURE validate_sync_environment(
    p_table_name VARCHAR2,
    p_dblink_name VARCHAR2,
    p_validation_result OUT VARCHAR2,
    p_source_count OUT NUMBER,
    p_is_valid OUT BOOLEAN
) IS
    v_count NUMBER;
    v_dblink_valid BOOLEAN := FALSE;
    v_table_exists NUMBER := 0;
    v_full_table_name VARCHAR2(256);
    v_source_schema VARCHAR2(128);
    v_base_table_name VARCHAR2(128);
BEGIN
    p_is_valid := FALSE;
    p_validation_result := '';
    p_source_count := 0;
    
    -- Парсинг имени таблицы
    v_full_table_name := UPPER(TRIM(p_table_name));
    IF INSTR(v_full_table_name, '.') > 0 THEN
        v_source_schema := REGEXP_SUBSTR(v_full_table_name, '^[^.]+');
        v_base_table_name := REGEXP_SUBSTR(v_full_table_name, '[^.]+$');
    ELSE
        v_source_schema := NULL;
        v_base_table_name := v_full_table_name;
    END IF;
    
    -- Формируем полное имя для запроса
    IF v_source_schema IS NOT NULL THEN
        v_full_table_name := v_source_schema || '.' || v_base_table_name;
    ELSE
        v_full_table_name := v_base_table_name;
    END IF;
    
    -- 1. Проверка доступности dblink
    BEGIN
        EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM dual@' || p_dblink_name INTO v_count;
        v_dblink_valid := TRUE;
        p_validation_result := p_validation_result || 'DBLINK_OK; ';
    EXCEPTION
        WHEN OTHERS THEN
            p_validation_result := p_validation_result || 'DBLINK_ERROR: ' || SQLERRM || '; ';
            RETURN;
    END;
    
    -- 2. Проверка существования удаленной таблицы
    BEGIN
        EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM ' || v_full_table_name || '@' || p_dblink_name || ' WHERE ROWNUM = 1' INTO v_table_exists;
        p_validation_result := p_validation_result || 'TABLE_EXISTS; ';
    EXCEPTION
        WHEN OTHERS THEN
            IF SQLCODE = -942 THEN
                p_validation_result := p_validation_result || 'TABLE_NOT_EXISTS; ';
            ELSE
                p_validation_result := p_validation_result || 'TABLE_ACCESS_ERROR: ' || SQLERRM || '; ';
            END IF;
            RETURN;
    END;
    
    -- 3. Подсчет количества записей в источнике
    BEGIN
        EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM ' || v_full_table_name || '@' || p_dblink_name INTO p_source_count;
        p_validation_result := p_validation_result || 'SOURCE_COUNT: ' || p_source_count || '; ';
    EXCEPTION
        WHEN OTHERS THEN
            p_validation_result := p_validation_result || 'COUNT_ERROR: ' || SQLERRM || '; ';
            RETURN;
    END;
    
    -- Финальная оценка
    IF v_dblink_valid AND v_table_exists >= 0 THEN
        p_is_valid := TRUE;
        p_validation_result := p_validation_result || 'VALIDATION_PASSED';
    END IF;
    
EXCEPTION
    WHEN OTHERS THEN
        p_validation_result := 'VALIDATION_FATAL_ERROR: ' || SQLERRM;
        p_is_valid := FALSE;
END validate_sync_environment;
/
```

### Основная процедура синхронизации

Процедура `sync_single_table_advanced` выполняет полную синхронизацию таблицы с обработкой всех возможных сценариев[10]:

```sql
CREATE OR REPLACE PROCEDURE sync_single_table_advanced(
    p_table_name VARCHAR2,
    p_dblink_name VARCHAR2,
    p_sync_type VARCHAR2 DEFAULT 'FULL',
    p_min_row_threshold NUMBER DEFAULT 0
) IS
    -- Переменные для парсинга имени таблицы
    v_full_table_name VARCHAR2(256);
    v_source_schema VARCHAR2(128);
    v_base_table_name VARCHAR2(128);
    v_select_from VARCHAR2(512);
    
    -- Переменные для локальных имен
    v_local_table_name VARCHAR2(128);
    v_backup_table_name VARCHAR2(128);
    
    -- Служебные переменные
    v_ddl_statement VARCHAR2(4000);
    v_error_msg VARCHAR2(4000);
    v_start_time TIMESTAMP;
    v_end_time TIMESTAMP;
    v_source_count NUMBER := 0;
    v_target_count NUMBER := 0;
    v_validation_result VARCHAR2(4000);
    v_is_environment_valid BOOLEAN;
    v_sync_status VARCHAR2(15) := 'ERROR';
    v_should_proceed BOOLEAN := FALSE;
BEGIN
    v_start_time := SYSTIMESTAMP;
    
    -- Парсинг входного параметра
    v_full_table_name := UPPER(TRIM(p_table_name));
    IF INSTR(v_full_table_name, '.') > 0 THEN
        v_source_schema := REGEXP_SUBSTR(v_full_table_name, '^[^.]+');
        v_base_table_name := REGEXP_SUBSTR(v_full_table_name, '[^.]+$');
    ELSE
        v_source_schema := NULL;
        v_base_table_name := v_full_table_name;
    END IF;
    
    -- Формируем имена локальных таблиц (всегда без схемы)
    v_local_table_name := 'LOCAL_' || v_base_table_name || '_BACKUP';
    v_backup_table_name := 'LOCAL_' || v_base_table_name || '_OLD';
    
    -- Формируем FROM-часть для запросов через dblink
    IF v_source_schema IS NOT NULL THEN
        v_select_from := v_source_schema || '.' || v_base_table_name || '@' || p_dblink_name;
    ELSE
        v_select_from := v_base_table_name || '@' || p_dblink_name;
    END IF;
    
    -- Всесторонняя проверка окружения
    validate_sync_environment(
        p_table_name => p_table_name,
        p_dblink_name => p_dblink_name,
        p_validation_result => v_validation_result,
        p_source_count => v_source_count,
        p_is_valid => v_is_environment_valid
    );
    
    -- Принятие решения о продолжении синхронизации
    IF NOT v_is_environment_valid THEN
        v_sync_status := 'ERROR';
        v_error_msg := 'Environment validation failed: ' || v_validation_result;
    ELSIF v_source_count < p_min_row_threshold THEN
        v_sync_status := 'EMPTY_SOURCE';
        v_error_msg := 'Source table has insufficient data (' || v_source_count || ' rows, threshold: ' || p_min_row_threshold || ')';
    ELSE
        v_should_proceed := TRUE;
    END IF;
    
    -- Выполнение синхронизации при прохождении всех проверок
    IF v_should_proceed THEN
        BEGIN
            -- Создание резервной копии существующей таблицы
            BEGIN
                EXECUTE IMMEDIATE 'ALTER TABLE ' || v_local_table_name || 
                                 ' RENAME TO ' || v_backup_table_name;
            EXCEPTION
                WHEN OTHERS THEN 
                    DBMS_OUTPUT.PUT_LINE('Предыдущая версия таблицы отсутствует - создаем новую');
            END;
            
            -- Создание новой таблицы
            v_ddl_statement := 'CREATE TABLE ' || v_local_table_name || 
                              ' AS SELECT * FROM ' || v_select_from;
            
            EXECUTE IMMEDIATE v_ddl_statement;
            
            -- Подсчет результата
            EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM ' || v_local_table_name INTO v_target_count;
            
            -- Валидация результата
            IF v_target_count = v_source_count THEN
                v_sync_status := 'SUCCESS';
                
                -- Удаление старой резервной копии
                BEGIN
                    EXECUTE IMMEDIATE 'DROP TABLE ' || v_backup_table_name;
                EXCEPTION
                    WHEN OTHERS THEN NULL;
                END;
                
                -- Обновление статистики
                BEGIN
                    DBMS_STATS.GATHER_TABLE_STATS(USER, v_local_table_name);
                EXCEPTION
                    WHEN OTHERS THEN NULL;
                END;
                
            ELSE
                v_sync_status := 'WARNING';
                v_error_msg := 'Row count mismatch: source=' || v_source_count || ', target=' || v_target_count;
            END IF;
            
        EXCEPTION
            WHEN OTHERS THEN
                v_error_msg := SQLERRM;
                v_sync_status := 'ERROR';
                
                -- Восстановление предыдущей версии при ошибке
                BEGIN
                    EXECUTE IMMEDIATE 'DROP TABLE ' || v_local_table_name;
                EXCEPTION
                    WHEN OTHERS THEN NULL;
                END;
                
                BEGIN
                    EXECUTE IMMEDIATE 'ALTER TABLE ' || v_backup_table_name || 
                                     ' RENAME TO ' || v_local_table_name;
                    DBMS_OUTPUT.PUT_LINE('Восстановлена предыдущая версия таблицы');
                EXCEPTION
                    WHEN OTHERS THEN NULL;
                END;
        END;
    END IF;
    
    -- Логирование результата
    v_end_time := SYSTIMESTAMP;
    INSERT INTO sync_log (
        table_name, sync_date, sync_type, status, 
        source_row_count, target_row_count, duration_seconds,
        validation_result, error_msg
    ) VALUES (
        p_table_name, SYSDATE, p_sync_type, v_sync_status,
        v_source_count, v_target_count, 
        EXTRACT(SECOND FROM (v_end_time - v_start_time)),
        v_validation_result, v_error_msg
    );
    COMMIT;
    
    -- Информативный вывод
    DBMS_OUTPUT.PUT_LINE('=== ОТЧЕТ СИНХРОНИЗАЦИИ ДЛЯ ' || p_table_name || ' ===');
    DBMS_OUTPUT.PUT_LINE('Статус: ' || v_sync_status);
    DBMS_OUTPUT.PUT_LINE('Строк в источнике: ' || v_source_count);
    DBMS_OUTPUT.PUT_LINE('Строк в локальной копии: ' || v_target_count);
    DBMS_OUTPUT.PUT_LINE('Локальная таблица: ' || v_local_table_name);
    DBMS_OUTPUT.PUT_LINE('Валидация: ' || v_validation_result);
    IF v_error_msg IS NOT NULL THEN
        DBMS_OUTPUT.PUT_LINE('Ошибка: ' || v_error_msg);
    END IF;
    
END sync_single_table_advanced;
/
```

## Управление заданиями планировщика

### Создание автоматических заданий

Процедура `create_smart_sync_job` создает задания DBMS_SCHEDULER с предварительным тестированием[3][11]:

```sql
CREATE OR REPLACE PROCEDURE create_smart_sync_job(
    p_table_name VARCHAR2,
    p_schedule_interval VARCHAR2 DEFAULT 'FREQ=DAILY;BYHOUR=20',
    p_dblink_name VARCHAR2,
    p_sync_type VARCHAR2 DEFAULT 'FULL',
    p_min_row_threshold NUMBER DEFAULT 1,
    p_test_run BOOLEAN DEFAULT TRUE
) IS
    v_job_name VARCHAR2(128);
    v_test_result VARCHAR2(4000);
    v_source_count NUMBER;
    v_is_valid BOOLEAN;
    v_base_table_name VARCHAR2(128);
BEGIN
    -- Извлекаем базовое имя таблицы для job_name
    IF INSTR(p_table_name, '.') > 0 THEN
        v_base_table_name := REGEXP_SUBSTR(UPPER(TRIM(p_table_name)), '[^.]+$');
    ELSE
        v_base_table_name := UPPER(TRIM(p_table_name));
    END IF;
    
    v_job_name := 'SYNC_' || v_base_table_name || '_JOB';
    
    -- Обязательный тестовый запуск
    IF p_test_run THEN
        DBMS_OUTPUT.PUT_LINE('=== ВЫПОЛНЕНИЕ ТЕСТОВОГО ЗАПУСКА ===');
        validate_sync_environment(
            p_table_name => p_table_name,
            p_dblink_name => p_dblink_name,
            p_validation_result => v_test_result,
            p_source_count => v_source_count,
            p_is_valid => v_is_valid
        );
        
        DBMS_OUTPUT.PUT_LINE('Результат тестовой валидации: ' || v_test_result);
        
        IF NOT v_is_valid THEN
            RAISE_APPLICATION_ERROR(-20001, 'Тестовая валидация не пройдена: ' || v_test_result);
        END IF;
        
        IF v_source_count < p_min_row_threshold THEN
            RAISE_APPLICATION_ERROR(-20002, 'В исходной таблице недостаточно данных (' || 
                v_source_count || ' строк, минимум требуется: ' || p_min_row_threshold || ')');
        END IF;
        
        DBMS_OUTPUT.PUT_LINE('Тестирование прошло успешно. Найдено строк: ' || v_source_count);
    END IF;
    
    -- Удаление существующего задания
    BEGIN
        DBMS_SCHEDULER.DROP_JOB(job_name => v_job_name, force => TRUE);
        DBMS_OUTPUT.PUT_LINE('Удалено существующее задание: ' || v_job_name);
    EXCEPTION
        WHEN OTHERS THEN 
            DBMS_OUTPUT.PUT_LINE('Предыдущего задания не найдено');
    END;
    
    -- Создание нового задания
    DBMS_SCHEDULER.CREATE_JOB(
        job_name        => v_job_name,
        job_type        => 'PLSQL_BLOCK',
        job_action      => 'BEGIN sync_single_table_advanced(''' || p_table_name || ''', ''' || 
                          p_dblink_name || ''', ''' || p_sync_type || ''', ' || 
                          p_min_row_threshold || '); END;',
        start_date      => SYSTIMESTAMP + INTERVAL '5' MINUTE,
        repeat_interval => p_schedule_interval,
        enabled         => TRUE,
        comments        => 'Автоматическая синхронизация таблицы ' || p_table_name || ' (тип: ' || p_sync_type || ')'
    );
    
    DBMS_OUTPUT.PUT_LINE('=== ЗАДАНИЕ СОЗДАНО УСПЕШНО ===');
    DBMS_OUTPUT.PUT_LINE('Имя задания: ' || v_job_name);
    DBMS_OUTPUT.PUT_LINE('Расписание: ' || p_schedule_interval);
    DBMS_OUTPUT.PUT_LINE('Тип синхронизации: ' || p_sync_type);
    DBMS_OUTPUT.PUT_LINE('Минимальный порог строк: ' || p_min_row_threshold);
    DBMS_OUTPUT.PUT_LINE('Первый запуск: через 5 минут');
    
END create_smart_sync_job;
/
```

### Управление заданиями

Процедура для комплексного управления заданиями синхронизации[12][13]:

```sql
CREATE OR REPLACE PROCEDURE manage_sync_jobs(
    p_action VARCHAR2, -- 'ENABLE', 'DISABLE', 'DROP', 'STATUS'
    p_table_name VARCHAR2 DEFAULT NULL -- NULL = все задания
) IS
    v_job_pattern VARCHAR2(128);
    v_count NUMBER := 0;
BEGIN
    -- Определяем паттерн поиска заданий
    IF p_table_name IS NOT NULL THEN
        -- Извлекаем базовое имя таблицы
        IF INSTR(p_table_name, '.') > 0 THEN
            v_job_pattern := 'SYNC_' || REGEXP_SUBSTR(UPPER(TRIM(p_table_name)), '[^.]+$') || '_JOB';
        ELSE
            v_job_pattern := 'SYNC_' || UPPER(TRIM(p_table_name)) || '_JOB';
        END IF;
    END IF;
    
    DBMS_OUTPUT.PUT_LINE('=== УПРАВЛЕНИЕ ЗАДАНИЯМИ СИНХРОНИЗАЦИИ ===');
    DBMS_OUTPUT.PUT_LINE('Действие: ' || UPPER(p_action));
    IF p_table_name IS NOT NULL THEN
        DBMS_OUTPUT.PUT_LINE('Таблица: ' || p_table_name);
    ELSE
        DBMS_OUTPUT.PUT_LINE('Область: все задания синхронизации');
    END IF;
    DBMS_OUTPUT.PUT_LINE('');
    
    FOR job_rec IN (
        SELECT job_name, enabled, state
        FROM user_scheduler_jobs 
        WHERE job_name LIKE 'SYNC_%_JOB'
        AND (p_table_name IS NULL OR job_name = v_job_pattern)
        ORDER BY job_name
    ) LOOP
        v_count := v_count + 1;
        
        CASE UPPER(p_action)
            WHEN 'ENABLE' THEN
                BEGIN
                    DBMS_SCHEDULER.ENABLE(job_rec.job_name);
                    DBMS_OUTPUT.PUT_LINE('✓ Включено: ' || job_rec.job_name);
                EXCEPTION
                    WHEN OTHERS THEN
                        DBMS_OUTPUT.PUT_LINE('✗ Ошибка включения ' || job_rec.job_name || ': ' || SQLERRM);
                END;
                
            WHEN 'DISABLE' THEN
                BEGIN
                    DBMS_SCHEDULER.DISABLE(job_rec.job_name);
                    DBMS_OUTPUT.PUT_LINE('✓ Отключено: ' || job_rec.job_name);
                EXCEPTION
                    WHEN OTHERS THEN
                        DBMS_OUTPUT.PUT_LINE('✗ Ошибка отключения ' || job_rec.job_name || ': ' || SQLERRM);
                END;
                
            WHEN 'DROP' THEN
                BEGIN
                    DBMS_SCHEDULER.DROP_JOB(job_rec.job_name, force => TRUE);
                    DBMS_OUTPUT.PUT_LINE('✓ Удалено: ' || job_rec.job_name);
                EXCEPTION
                    WHEN OTHERS THEN
                        DBMS_OUTPUT.PUT_LINE('✗ Ошибка удаления ' || job_rec.job_name || ': ' || SQLERRM);
                END;
                
            WHEN 'STATUS' THEN
                DBMS_OUTPUT.PUT_LINE('📋 ' || job_rec.job_name || 
                    ' | Включено: ' || job_rec.enabled || 
                    ' | Состояние: ' || NVL(job_rec.state, 'N/A'));
            ELSE
                DBMS_OUTPUT.PUT_LINE('❌ Неизвестное действие: ' || p_action);
        END CASE;
    END LOOP;
    
    IF v_count = 0 THEN
        DBMS_OUTPUT.PUT_LINE('Задания не найдены');
    ELSE
        DBMS_OUTPUT.PUT_LINE('');
        DBMS_OUTPUT.PUT_LINE('Обработано заданий: ' || v_count);
    END IF;
    
END manage_sync_jobs;
/
```

## Система мониторинга и диагностики

### Дашборд мониторинга

Система предоставляет комплексный дашборд для контроля состояния синхронизации[14]:

**Основные метрики:**
- Статус последней синхронизации каждой таблицы
- Количество обработанных записей
- Время выполнения операций
- История ошибок и предупреждений

**Запросы для мониторинга:**

```sql
-- Общий статус всех синхронизаций
SELECT * FROM v_sync_dashboard;

-- Детальная история синхронизации
SELECT 
    table_name,
    sync_date,
    status,
    source_row_count,
    target_row_count,
    duration_seconds,
    SUBSTR(error_msg, 1, 100) as error_summary
FROM sync_log 
WHERE sync_date > SYSDATE - 7 
ORDER BY sync_date DESC;

-- Статус активных заданий планировщика
SELECT 
    job_name,
    enabled,
    state,
    next_run_date,
    last_start_date
FROM user_scheduler_jobs 
WHERE job_name LIKE 'SYNC_%_JOB'
ORDER BY job_name;
```

### Диагностические запросы

**Проверка работоспособности системы:**

```sql
-- Проверка dblink
SELECT 'DBLINK_OK' as status FROM dual@YOUR_DBLINK;

-- Список доступных таблиц через dblink
SELECT owner, table_name 
FROM all_tables@YOUR_DBLINK 
WHERE owner = 'YOUR_SCHEMA'
ORDER BY table_name;

-- Статистика выполнения заданий
SELECT 
    job_name,
    status,
    actual_start_date,
    run_duration,
    error#,
    additional_info
FROM user_scheduler_job_run_details
WHERE job_name LIKE 'SYNC_%_JOB'
ORDER BY actual_start_date DESC;
```

## Примеры использования

### Настройка синхронизации новой таблицы

**Шаг 1: Создание задания синхронизации**

```sql
-- Включаем вывод сообщений
SET SERVEROUTPUT ON;

-- Создание задания для ежедневной синхронизации в 20:00
BEGIN
    create_smart_sync_job(
        p_table_name        => 'HR.EMPLOYEES',          -- Полное имя таблицы
        p_schedule_interval => 'FREQ=DAILY;BYHOUR=20',  -- Каждый день в 20:00
        p_dblink_name       => 'PROD_LINK',             -- Имя dblink
        p_sync_type         => 'FULL',                  -- Полное копирование
        p_min_row_threshold => 1,                       -- Минимум 1 строка
        p_test_run          => TRUE                     -- С тестированием
    );
END;
/
```

**Шаг 2: Проверка созданного задания**

```sql
-- Просмотр статуса задания
BEGIN
    manage_sync_jobs('STATUS', 'HR.EMPLOYEES');
END;
/

-- Ручной запуск для проверки
BEGIN
    DBMS_SCHEDULER.RUN_JOB('SYNC_EMPLOYEES_JOB', TRUE);
END;
/
```

### Массовая настройка синхронизации

```sql
-- Создание нескольких заданий одновременно
DECLARE
    TYPE t_tables IS TABLE OF VARCHAR2(100);
    v_tables t_tables := t_tables('HR.EMPLOYEES', 'SALES.ORDERS', 'INVENTORY.PRODUCTS');
BEGIN
    FOR i IN 1..v_tables.COUNT LOOP
        create_smart_sync_job(
            p_table_name        => v_tables(i),
            p_schedule_interval => 'FREQ=DAILY;BYHOUR=20',
            p_dblink_name       => 'PROD_LINK',
            p_sync_type         => 'FULL',
            p_min_row_threshold => 1,
            p_test_run          => TRUE
        );
    END LOOP;
END;
/
```

### Мониторинг и обслуживание

**Ежедневные проверки:**

```sql
-- Проверка статуса всех синхронизаций
SELECT 
    table_name,
    health_status,
    sync_date,
    source_row_count,
    target_row_count
FROM v_sync_dashboard
ORDER BY 
    CASE health_status 
        WHEN 'ERROR' THEN 1 
        WHEN 'WARNING' THEN 2 
        ELSE 3 
    END;

-- Отчет об ошибках за последние 24 часа
SELECT 
    table_name,
    sync_date,
    error_short
FROM v_sync_dashboard
WHERE health_status IN ('ERROR', 'WARNING')
AND sync_date > SYSDATE - 1;
```

**Еженедельное обслуживание:**

```sql
-- Очистка старых логов (старше 30 дней)
DELETE FROM sync_log 
WHERE sync_date < SYSDATE - 30;
COMMIT;

-- Обновление статистики таблиц
BEGIN
    DBMS_STATS.GATHER_SCHEMA_STATS(USER);
END;
/
```

## Безопасность и лучшие практики

### Управление правами доступа

**Необходимые привилегии для пользователя:**

```sql
-- Основные права на создание объектов
GRANT CREATE TABLE TO sync_user;
GRANT CREATE PROCEDURE TO sync_user;
GRANT CREATE VIEW TO sync_user;

-- Права на планировщик заданий
GRANT CREATE JOB TO sync_user;
GRANT MANAGE SCHEDULER TO sync_user;

-- Права на статистику
GRANT ANALYZE ANY TO sync_user;
```

### Рекомендации по безопасности

1. **Шифрование соединений**: Используйте зашифрованные соединения для dblink в производственной среде
2. **Мониторинг доступа**: Регулярно проверяйте логи доступа к системе синхронизации
3. **Резервное копирование**: Создавайте резервные копии конфигурации синхронизации
4. **Тестирование**: Регулярно тестируйте процедуры восстановления

### Оптимизация производительности

**Настройки параллелизма:**

```sql
-- Настройка количества параллельных заданий
ALTER SYSTEM SET job_queue_processes = 10;

-- Оптимизация памяти для больших таблиц
ALTER SESSION SET sort_area_size = 104857600;
ALTER SESSION SET hash_area_size = 104857600;
```

**Индексирование локальных таблиц:**

```sql
-- Создание индексов на часто используемых колонках
-- (выполнять после первой синхронизации)
CREATE INDEX idx_local_employees_dept 
ON local_employees_backup(department_id);

CREATE INDEX idx_local_orders_date 
ON local_orders_backup(order_date);
```

## Обработка ошибок и восстановление

### Типичные ошибки и их решения

**1. Ошибка ORA-02019: connection description for remote database not found**
- **Причина**: Неправильно настроен или недоступен dblink
- **Решение**: Проверить настройки dblink, сетевое подключение

**2. Ошибка ORA-27486: insufficient privileges**  
- **Причина**: Недостаточно прав для создания заданий планировщика
- **Решение**: Предоставить права CREATE JOB и MANAGE SCHEDULER

**3. Ошибка ORA-01918: user does not exist**
- **Причина**: Попытка создать таблицу с именем схемы, которая не существует
- **Решение**: Использовать только имена таблиц без схемы для локальных копий

### Процедуры восстановления

**Восстановление после сбоя синхронизации:**

```sql
-- Ручное восстановление локальной таблицы
DECLARE
    v_table_exists NUMBER;
BEGIN
    -- Проверяем существование backup таблицы
    SELECT COUNT(*) INTO v_table_exists
    FROM user_tables 
    WHERE table_name = 'LOCAL_EMPLOYEES_OLD';
    
    IF v_table_exists > 0 THEN
        -- Восстанавливаем из backup
        EXECUTE IMMEDIATE 'DROP TABLE LOCAL_EMPLOYEES_BACKUP';
        EXECUTE IMMEDIATE 'ALTER TABLE LOCAL_EMPLOYEES_OLD RENAME TO LOCAL_EMPLOYEES_BACKUP';
        DBMS_OUTPUT.PUT_LINE('Таблица восстановлена из резервной копии');
    ELSE
        DBMS_OUTPUT.PUT_LINE('Резервная копия не найдена');
    END IF;
END;
/
```

## Расширенные возможности

### Инкрементальная синхронизация

Для больших таблиц можно реализовать инкрементальную синхронизацию на основе временных меток:

```sql
-- Пример процедуры инкрементальной синхронизации
CREATE OR REPLACE PROCEDURE sync_incremental(
    p_table_name VARCHAR2,
    p_dblink_name VARCHAR2,
    p_timestamp_column VARCHAR2
) IS
    v_last_sync_time TIMESTAMP;
    v_sql VARCHAR2(4000);
BEGIN
    -- Получаем время последней синхронизации
    SELECT MAX(sync_date) INTO v_last_sync_time
    FROM sync_log 
    WHERE table_name = p_table_name 
    AND status = 'SUCCESS';
    
    -- Формируем SQL для инкрементальной выборки
    v_sql := 'INSERT INTO LOCAL_' || p_table_name || '_BACKUP 
              SELECT * FROM ' || p_table_name || '@' || p_dblink_name ||
              ' WHERE ' || p_timestamp_column || ' > :last_sync';
              
    EXECUTE IMMEDIATE v_sql USING v_last_sync_time;
    
    DBMS_OUTPUT.PUT_LINE('Инкрементальная синхронизация завершена');
END;
/
```

### Мониторинг в реальном времени

Создание представления для мониторинга активных синхронизаций:

```sql
CREATE OR REPLACE VIEW v_active_sync_jobs AS
SELECT 
    srj.job_name,
    srj.session_id,
    srj.running_instance,
    srj.elapsed_time,
    srj.cpu_used,
    s.sql_text
FROM user_scheduler_running_jobs srj
LEFT JOIN v$session s ON s.serial# = srj.session_id
WHERE srj.job_name LIKE 'SYNC_%_JOB';
```

## Интеграция с Oracle APEX

### Создание страницы мониторинга в APEX

**1. Создание региона с интерактивным отчетом:**

```sql
-- SQL для интерактивного отчета
SELECT 
    table_name as "Таблица",
    CASE health_status
        WHEN 'HEALTHY' THEN '<span class="t-Icon t-Icon--success fa fa-check-circle"></span> Исправно'
        WHEN 'ERROR' THEN '<span class="t-Icon t-Icon--danger fa fa-exclamation-circle"></span> Ошибка'  
        WHEN 'WARNING' THEN '<span class="t-Icon t-Icon--warning fa fa-warning"></span> Предупреждение'
        ELSE health_status
    END as "Статус",
    sync_date as "Последняя синхронизация",
    source_row_count as "Строк в источнике",
    target_row_count as "Строк локально",
    duration_sec as "Время выполнения (сек)",
    error_short as "Ошибка"
FROM v_sync_dashboard
ORDER BY 
    CASE health_status 
        WHEN 'ERROR' THEN 1 
        WHEN 'WARNING' THEN 2 
        ELSE 3 
    END;
```

**2. Процесс для ручного запуска синхронизации:**

```sql
-- PL/SQL процесс для кнопки "Синхронизировать"
DECLARE
    v_table_name VARCHAR2(128) := :P1_TABLE_NAME;
BEGIN
    sync_single_table_advanced(
        p_table_name => v_table_name,
        p_dblink_name => 'PROD_LINK',
        p_sync_type => 'FULL'
    );
    
    apex_application.g_print_success_message := 'Синхронизация таблицы ' || v_table_name || ' завершена';
EXCEPTION
    WHEN OTHERS THEN
        apex_application.g_print_error_message := 'Ошибка синхронизации: ' || SQLERRM;
END;
```

## Заключение

Представленное решение обеспечивает надежную и масштабируемую систему синхронизации данных между удаленными и локальными базами данных в среде Oracle APEX 23.1[6]. Система включает:

- **Комплексную проверку окружения** перед выполнением синхронизации
- **Автоматическое создание локальных копий** таблиц с сохранением структуры
- **Гибкую систему планирования** с использованием DBMS_SCHEDULER[15]
- **Детальное логирование и мониторинг** всех операций
- **Механизмы восстановления** при сбоях
- **Интеграцию с Oracle APEX** для визуального управления

Данная архитектура подходит как для небольших проектов с несколькими таблицами, так и для крупных корпоративных систем с сотнями синхронизируемых объектов. Система легко расширяется и модифицируется под специфические требования проекта[16][17].

Цитаты:
[1] 17.7 Accessing Data with Database Links - APEX - Oracle Help Center https://docs.oracle.com/en/database/oracle/apex/23.1/htmdb/accessing-data-with-database-links.html
[2] [PDF] Oracle® APEX - SQL Workshop Guide https://docs.oracle.com/en/database/oracle/apex/23.1/aeutl/oracle-apex-sql-workshop-guide.pdf
[3] Scheduling Jobs with DBMS_SCHEDULER - DBA Genesis Docs https://support.dbagenesis.com/oracle-database/scheduling-jobs-with-dbms_scheduler
[4] Scheduling Jobs with Oracle Scheduler - Oracle Help Center https://docs.oracle.com/en/database/oracle/oracle-database/18/admin/scheduling-jobs-with-oracle-scheduler.html
[5] [PDF] Oracle® APEX - Installation Guide https://docs.oracle.com/en/database/oracle/apex/23.1/htmig/oracle-apex-installation-guide.pdf
[6] Oracle APEX Release 23.1 https://docs.oracle.com/en/database/oracle/apex/23.1
[7] DBMS_SCHEDULER Jobs https://docs.oracle.com/database/apex-18.1/AEADM/dbms_scheduler-jobs.htm
[8] How to create a DB link between two oracle instances - Stack Overflow https://stackoverflow.com/questions/13267218/how-to-create-a-db-link-between-two-oracle-instances
[9] How to Document Stored Procedures and Functions in Database https://dataedo.com/blog/how-to-document-stored-procedures-and-functions-in-database
[10] Oracle 12c - PL/SQL Tables Replication Between Databases - Scribd https://fr.scribd.com/document/478182379/OracleReplication
[11] DBMS_SCHEDULER - Bright DBA https://www.br8dba.com/dbms_scheduler/
[12] Monitoring Jobs https://docs.oracle.com/cd/E18283_01/server.112/e17120/scheduse008.htm
[13] Monitoring and Managing the Scheduler https://www.devdoc.net/database/OracleDoc_11gR2/server.112/e25494/schedadmin002.htm
[14] Mastering Database Health with 4i's Oracle APEX-Powered Solution https://www.4iapps.com/mastering-database-health-with-4is-oracle-apex-powered-solution/
[15] DBMS_SCHEDULER - Oracle Help Center https://docs.oracle.com/database/121/ARPLS/d_sched.htm
[16] PL/SQL Best Practices - Implementation Guide https://docs.oracle.com/en/industries/retail/retail-analytics-planning/24.1.201.0/rapig/pl-sql-best-practice.htm
[17] Oracle PL/SQL Best Practices - LinkedIn https://www.linkedin.com/pulse/oracle-plsql-best-practices-randall-fadler-v0g8c
[18] selected_image_6026985047775450996.jpg https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/images/72242679/11aad4cd-6f88-4d80-bf77-4720c859b46c/selected_image_6026985047775450996.jpg?AWSAccessKeyId=ASIA2F3EMEYE5FANEI72&Signature=udYLWtUtuJleScg%2BRkLPceuc%2Fa4%3D&x-amz-security-token=IQoJb3JpZ2luX2VjEHAaCXVzLWVhc3QtMSJHMEUCIQCUY5gwPtpVjnovlIeUJhH3YlmTmI%2BQfXcJsv8YrkZ5sgIgVVm93vMWgYJjssvIrAF3V3yZNp3MDFTepO5WZWKcmpIq%2BgQImf%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARABGgw2OTk3NTMzMDk3MDUiDIC6y3dd5gu1bVHDhirOBDObDlgLKvqPtAA5TO7JP1Sym4nkXFvCkMH%2FDu%2BO9OnM%2FXxG2DXG%2FI81hSpGusrOqTjZ5PmwH5AAZ5AkNYKbYD%2BePCYbuov3%2FWnivAieza9u1h7S1RnLYk4ES8ufjTHmBA9%2Bb1F9L%2BddSU5SQ3NSifBNTcNk3BYbLinC0dpWBYpJgp74C6Ei%2Bjqb9VeX9xmYz2vSC%2BnqYE1kowYzxFH78MkUhK1clN4kga6sLhgbNg2veDFJwgbr3DQi6emCsX6uMG5lp5JeTWkudGnYDICu0O6Dzd9iXGU%2BWtBNaGMUapb0%2FZv%2FVQ5AVppZulfygDFegqZlpUpykg55gXhlUxDYVr%2FAFsbR%2FSQww8JoFppuw7rOdTB4zdliPXx%2F6H5%2ByiVZTn2BwEiqy7l2IgaKLg7wJPZM1h7XNOb6Jcro0QhY457JhzyFlpw%2BhpxrazzpzpytJe4E2A%2BbcIT4Pz5kzPM22jTtfv7OvoIh6CvQ2BzvDGtygvO17%2BuSgdrzWkk%2FfIi1zIgZjNWc6Fd6P31a8dDa9Ux5eu%2BfIWhYVjc5hhaxG5HOjcI8RoMAPXoANCqC1oa8xEP7vru%2BlBhV%2BKrZYVVDc2SoGyTh0A9HMN9LIIiYiBB8e8JfFFDzmtwtb4zpM4CXivObcJvDScqz7mWzQQd0VU6WY4svaluCkFyArog5ohE6wt6pzxRGcpXTaRa9hwGLOlnx3v6uISWXyf4Bi0L7BZDVBbmoeZA1ig7W11w7aLUnjwPQfvyEns8i8u5zcJJ5deErXD8Q0gpkFFAuMc0MMKWdoMQGOpoBJ6LKKfWF9n%2BMluuhnDEQMcrgpkLZ9aQeevsFrLVZzFfMskzzcCqpjwYWn85RvCOrd1HmSCG9v4d9wuDA9TtaKboTqNU8QS0kkKw%2FI9YUl%2BGIZIWDKnCizCIoFrn%2FlJFTeORwbQqXOryim%2FmG5FAvjdrWigsKj%2Fazu3rWdfywLs%2BjkaCqya78k%2F5pZWrSGvRbKcrOkEU6K9peDA%3D%3D&Expires=1753748001
[19] Oracle APEX: Dynamic REST Source Sync Parameters https://blog.cloudnueva.com/dynamic-parameters-in-oracle-apex-rest-data-source-synchronizations
[20] Oracle DBMS_SCHEDULER and PostgreSQL scheduled Lambda https://docs.aws.amazon.com/dms/latest/oracle-to-aurora-postgresql-migration-playbook/chap-oracle-aurora-pg.special.scheduler.html
[21] 2.16 Managing Database Links https://docs.oracle.com/database/apex-5.1/AEUTL/managing-db-links.htm
[22] Synchronizing Data from REST Services to Local Table - YouTube https://www.youtube.com/watch?v=9ZZBXI6y0QU
[23] 18.4.10 Managing Data Synchronization - App Builder User's Guide https://docs.oracle.com/en/database/oracle/apex/24.2/htmdb/managing-data-synchronization.html
[24] Comments Style - PL/SQL & SQL Coding Guidelines https://insum-labs.github.io/plsql-and-sql-coding-guidelines/v1.1/3-coding-style/02-coding-style-comments/
[25] REST Synchronization in Oracle APEX | Sync Remote and Local ... https://www.youtube.com/watch?v=m-2Rn_4OS8k
[26] DBMS_SCHEDULER - Oracle Help Center https://docs.oracle.com/cd/B19306_01/appdev.102/b14258/d_sched.htm
[27] [PDF] Oracle PLSQL Coding Guidelines 1. Overview 2. Standards https://www.topcoder.com/i/development/uml/Oracle_PLSQL_Coding_Guidelines.pdf
[28] 17.4.7 Managing Data Synchronization - APEX - Oracle Help Center https://docs.oracle.com/en/database/oracle/apex/22.2/htmdb/managing-data-synchronization.html
[29] A.1 List of DBMS_SCHEDULER Jobs https://docs.oracle.com/cd/E59726_01/doc.50/e39151/dbms_jobs001.htm
[30] Style Guide - Oracle SQL and PL/SQL Optimization for Developers https://oracle.readthedocs.io/en/latest/sql/basics/style-guide.html
[31] Oracle APEX Limitations on Autonomous Database https://docs.public.content.oci.oraclecloud.com/en-us/iaas/autonomous-database-serverless/doc/apex-notes-autonomous.html
[32] 157 dbms_scheduler - PL/SQL Packages and Types Reference https://docs.oracle.com/en/database/oracle/oracle-database/21/arpls/DBMS_SCHEDULER.html
[33] Database Links (Oracle) | SAP Help Portal https://help.sap.com/docs/EAD_CLOUD/c50a2057f35a4731838910588f247f4a/c7ce10036e1b10148d45a5a097d921f9.html
[34] 6. Executing PL/SQL - node-oracledb's documentation https://node-oracledb.readthedocs.io/en/latest/user_guide/plsql_execution.html
[35] How to Create a DBLink in Oracle - Process Street https://www.process.st/how-to/creating-a-dblink-in-oracle/
[36] How to Back Up Oracle APEX Applications (2025 Guide) - Revion https://revion.com/how-to-back-up-oracle-apex-applications-2025-guide/
[37] 6. Executing PL/SQL - python-oracledb's documentation https://python-oracledb.readthedocs.io/en/latest/user_guide/plsql_execution.html
[38] DB-Links, JOINS - Technical Documentation For IFS Cloud https://docs.ifs.com/techdocs/21r2/045_administration_aurena/260_data_management/050_data_migration/070_references/020_tips_and_tricks/tipsandtricksjoinstolus/
[39] 2.3. Creating and Maintaining Database Links | Administration Guide https://docs.redhat.com/en/documentation/red_hat_directory_server/11/html/administration_guide/configuring_directory_databases-creating_and_maintaining_database_links
[40] Backup and Recovery User's Guide - Database - Oracle Help Center https://docs.oracle.com/en/database/oracle/oracle-database/23/bradv/book-index.html
[41] PLSQL Stored Procedure Examples | PDF | Pl/Sql - Scribd https://www.scribd.com/document/15841882/PLSQL-Stored-Procedure-Examples
[42] The New Create Database Link Table Form - Data Masker for Oracle 5 https://documentation.red-gate.com/dmo/data-masker-for-oracle-help/major-data-masker-application-components/the-new-create-database-link-table-form
[43] PL/SQL Procedures and Functions - Oracle Help Center https://docs.oracle.com/en/database/other-databases/timesten/22.1/plsql-developer/pl-sql-procedures-and-functions.html
[44] CREATE PUBLIC DATABASE LINK v17 - EDB https://www.enterprisedb.com/docs/epas/latest/reference/oracle_compatibility_reference/epas_compat_sql/21_create_public_database_link/
[45] Index - Oracle Help Center https://docs.oracle.com/en/database/oracle/apex/23.1/htmdb/book-index.html
[46] Sample PL/SQL Programs https://docs.oracle.com/cd/B10500_01/appdev.920/a96624/a_samps.htm
[47] What's New in Oracle APEX 23.1 https://apex.oracle.com/en/platform/features/whats-new-231/
[48] Create DB Link To From Apex To Another Oracle Database - База ... https://www.apexhostingservices.com/clients/index.php?rp=%2Fknowledgebase%2F20%2FCreate-DB-Link-To-From-Apex-To-Another-Oracle-Database.html&language=ukranian
[49] Sync Framework Tutorial - Documentation - Devart https://docs.devart.com/dotconnect/oracle/SyncFramework.html
[50] 3 Synchronization - Oracle Help Center https://docs.oracle.com/cd/B19188_01/doc/B15920/sync.htm
[51] 26.1 Available Parameter Values - API Reference https://docs.oracle.com/en/database/oracle/apex/23.1/aeapi/Available-Parameter-Values.html
[52] 4 Replicating Data Using Oracle Streams http://www.asktheway.org/official-documents/oracle/E11882_01/server.112/e17516/tdpii_repcont.htm
[53] Monitoring and Mana ging the Scheduler - filibeto.org https://www.filibeto.org/sun/lib/nonsun/oracle/11.1.0.6.0/B28359_01/server.111/b28310/schedadmin002.htm
[54] Oracle Application Express for Amazon RDS for Oracle demystified https://aws.amazon.com/blogs/database/oracle-application-express-for-amazon-rds-for-oracle-demystified/
[55] 2 Synchronization - Oracle Help Center https://docs.oracle.com/cd/E12095_01/doc.10303/e12090/sync.htm
[56] DBMS_SCHEDULER in Oracle Database - Complete Guide https://dev.to/mrcaption49/dbmsscheduler-complete-guide-2025-4lf1
[57] Index - APEX - Oracle Help Center https://docs.oracle.com/en/database/oracle/apex/23.1/aeadm/book-index.html
[58] Synchronisation of PL/SQL procedure. How to guaranty execution of ... https://stackoverflow.com/questions/17321687/synchronisation-of-pl-sql-procedure-how-to-guaranty-execution-of-procedure-only
[59] Creating, Running, and Managing Jobs http://suporte.universalrh.com.br/oradoc/server.112/e25494/scheduse002.htm
[60] Administration Guide - Oracle Help Center https://docs.oracle.com/en/database/oracle/apex/23.1/aeadm/toc.htm
[61] plsql - How to synchronize threads in Oracle? - Stack Overflow https://stackoverflow.com/questions/63114257/how-to-synchronize-threads-in-oracle
[62] oracle synchronize 2 tables - Stack Overflow https://stackoverflow.com/questions/45034788/oracle-synchronize-2-tables
[63] Documentation - Oracle APEX https://apex.oracle.com/en/learn/documentation/
[64] PL/SQL Packages - GeeksforGeeks https://www.geeksforgeeks.org/plsql/plsql-packages/
[65] Synchronization Oracle RDB - WinCC OA Portal https://www.winccoa.com/documentation/WinCCOA/3.18/en_US/HDB_RDB_Parallel/HDB_RDB_Parallel-05.html
[66] Creating stored procedures in a PL/SQL package - IBM https://www.ibm.com/docs/en/data-studio/4.1.1?topic=procedures-creating-stored-in-plsql-package
[67] Historical Synchronization - WinCC OA Portal https://www.winccoa.com/documentation/WinCCOA/3.19/en_US/RDB/RDB-25.html
[68] Oracle APEX new features – the low-code platform keeps evolving https://pretius.com/blog/oracle-apex-new-features
[69] 9 Using PL/SQL Packages - filibeto.org https://www.filibeto.org/sun/lib/nonsun/oracle/10.2.0.1.0/B19306_01/appdev.102/b14261/packages.htm
[70] Synchronize data from a self-managed Oracle database to an ... https://www.alibabacloud.com/help/id/dts/user-guide/synchronize-data-from-a-self-managed-oracle-database-to-an-analyticdb-for-postgresql-instance
[71] Oracle SQLcl 23.1 Enhanced APEX functionality https://mattmulvaney.hashnode.dev/oracle-sqlcl-231-enhanced-apex-functionality
[72] Sample PLSQL Packages | PDF - Scribd https://www.scribd.com/doc/270556480/Sample-Plsql-Packages
[73] Synchronize data from a self-managed Oracle database to a ... https://www.alibabacloud.com/help/en/dts/user-guide/synchronize-data-from-a-self-managed-oracle-database-to-a-datahub-project-1
[74] Oracle APEX Release 23.1 - Develop Apps https://docs.oracle.com/en/database/oracle/apex/23.1/buildapplications.html
[75] 10 PL/SQL Packages https://docs.oracle.com/cd/E11882_01/appdev.112/e25519/packages.htm
[76] Oracle Apex 23.1 - a deep dive into the biggest new features https://www.youtube.com/watch?v=Hi4KVHYdPBU
[77] Sample Variable for PL/SQL Procedure Source Type https://docs.oracle.com/cd/E18727-01/doc.121/e13459/T256665T498436.htm
[78] How to sync tables and views between two oracle database ? : r/SQL https://www.reddit.com/r/SQL/comments/xnlh05/how_to_sync_tables_and_views_between_two_oracle/
