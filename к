

```sql
-- Родительская таблица журнала
CREATE TABLE audit_log (
    audit_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    record_id VARCHAR2(100) NOT NULL,
    record_name VARCHAR2(500),
    table_name VARCHAR2(128) NOT NULL,
    event_type VARCHAR2(20) NOT NULL, -- INSERT, UPDATE, DELETE
    event_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    user_name VARCHAR2(100) DEFAULT COALESCE(V('APP_USER'), USER),
    session_id NUMBER DEFAULT SYS_CONTEXT('USERENV', 'SESSIONID'),
    created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Детальная таблица изменений
CREATE TABLE audit_log_details (
    detail_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    audit_id NUMBER NOT NULL,
    column_name VARCHAR2(128) NOT NULL,
    old_value CLOB,
    new_value CLOB,
    data_type VARCHAR2(50),
    change_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    user_name VARCHAR2(100) DEFAULT COALESCE(V('APP_USER'), USER),
    CONSTRAINT fk_audit_details_log 
        FOREIGN KEY (audit_id) REFERENCES audit_log(audit_id)
);

-- Индексы для оптимизации производительности
CREATE INDEX idx_audit_log_table_date ON audit_log(table_name, event_date);
CREATE INDEX idx_audit_log_record_id ON audit_log(record_id);
CREATE INDEX idx_audit_details_audit_id ON audit_log_details(audit_id);
```

### Пакет для управления аудитом

```sql
CREATE OR REPLACE PACKAGE audit_pkg AS
    -- Процедура для записи основного события аудита
    PROCEDURE log_audit_event(
        p_table_name IN VARCHAR2,
        p_record_id IN VARCHAR2,
        p_record_name IN VARCHAR2,
        p_event_type IN VARCHAR2,
        p_audit_id OUT NUMBER
    );
    
    -- Процедура для записи детальных изменений
    PROCEDURE log_column_change(
        p_audit_id IN NUMBER,
        p_column_name IN VARCHAR2,
        p_old_value IN CLOB,
        p_new_value IN CLOB,
        p_data_type IN VARCHAR2 DEFAULT 'VARCHAR2'
    );
    
    -- Функция генерации триггера аудита
    FUNCTION generate_audit_trigger(
        p_table_name IN VARCHAR2,
        p_key_column IN VARCHAR2,
        p_name_column IN VARCHAR2 DEFAULT NULL
    ) RETURN CLOB;
    
END audit_pkg;
/

CREATE OR REPLACE PACKAGE BODY audit_pkg AS
    
    PROCEDURE log_audit_event(
        p_table_name IN VARCHAR2,
        p_record_id IN VARCHAR2,
        p_record_name IN VARCHAR2,
        p_event_type IN VARCHAR2,
        p_audit_id OUT NUMBER
    ) AS
        PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
        INSERT INTO audit_log (
            record_id, 
            record_name, 
            table_name, 
            event_type
        ) VALUES (
            p_record_id,
            p_record_name,
            UPPER(p_table_name),
            UPPER(p_event_type)
        ) RETURNING audit_id INTO p_audit_id;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END log_audit_event;
    
    PROCEDURE log_column_change(
        p_audit_id IN NUMBER,
        p_column_name IN VARCHAR2,
        p_old_value IN CLOB,
        p_new_value IN CLOB,
        p_data_type IN VARCHAR2 DEFAULT 'VARCHAR2'
    ) AS
        PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
        -- Записываем изменение только если значения различаются
        IF (p_old_value IS NULL AND p_new_value IS NOT NULL) OR
           (p_old_value IS NOT NULL AND p_new_value IS NULL) OR
           (p_old_value != p_new_value) THEN
            
            INSERT INTO audit_log_details (
                audit_id,
                column_name,
                old_value,
                new_value,
                data_type
            ) VALUES (
                p_audit_id,
                UPPER(p_column_name),
                p_old_value,
                p_new_value,
                p_data_type
            );
        END IF;
        
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            RAISE;
    END log_column_change;
    
    FUNCTION generate_audit_trigger(
        p_table_name IN VARCHAR2,
        p_key_column IN VARCHAR2,
        p_name_column IN VARCHAR2 DEFAULT NULL
    ) RETURN CLOB AS
        l_trigger_code CLOB;
        l_columns_cursor SYS_REFCURSOR;
        l_column_name VARCHAR2(128);
        l_data_type VARCHAR2(128);
        l_name_expr VARCHAR2(500);
    BEGIN
        l_name_expr := COALESCE(p_name_column, 'NULL');
        
        l_trigger_code := 'CREATE OR REPLACE TRIGGER trg_audit_' || LOWER(p_table_name) || '
    AFTER INSERT OR UPDATE OR DELETE ON ' || p_table_name || '
    FOR EACH ROW
DECLARE
    v_audit_id NUMBER;
    v_record_id VARCHAR2(100);
    v_record_name VARCHAR2(500);
    v_event_type VARCHAR2(20);
BEGIN
    -- Определяем тип операции и ключевые значения
    IF INSERTING THEN
        v_event_type := ''INSERT'';
        v_record_id := TO_CHAR(:NEW.' || p_key_column || ');
        v_record_name := ' || CASE WHEN p_name_column IS NOT NULL 
                                    THEN ':NEW.' || p_name_column 
                                    ELSE 'NULL' END || ';
    ELSIF UPDATING THEN
        v_event_type := ''UPDATE'';
        v_record_id := TO_CHAR(:NEW.' || p_key_column || ');
        v_record_name := ' || CASE WHEN p_name_column IS NOT NULL 
                                    THEN ':NEW.' || p_name_column 
                                    ELSE 'NULL' END || ';
    ELSIF DELETING THEN
        v_event_type := ''DELETE'';
        v_record_id := TO_CHAR(:OLD.' || p_key_column || ');
        v_record_name := ' || CASE WHEN p_name_column IS NOT NULL 
                                    THEN ':OLD.' || p_name_column 
                                    ELSE 'NULL' END || ';
    END IF;
    
    -- Записываем основное событие аудита
    audit_pkg.log_audit_event(
        p_table_name => ''' || p_table_name || ''',
        p_record_id => v_record_id,
        p_record_name => v_record_name,
        p_event_type => v_event_type,
        p_audit_id => v_audit_id
    );
    
    -- Записываем детальные изменения';

        -- Добавляем проверки для каждого столбца
        OPEN l_columns_cursor FOR
            SELECT column_name, data_type
            FROM user_tab_columns
            WHERE table_name = UPPER(p_table_name)
            ORDER BY column_id;
        
        LOOP
            FETCH l_columns_cursor INTO l_column_name, l_data_type;
            EXIT WHEN l_columns_cursor%NOTFOUND;
            
            l_trigger_code := l_trigger_code || '
    
    -- Проверка изменений в столбце ' || l_column_name || '
    IF INSERTING THEN
        audit_pkg.log_column_change(
            p_audit_id => v_audit_id,
            p_column_name => ''' || l_column_name || ''',
            p_old_value => NULL,
            p_new_value => TO_CLOB(:NEW.' || l_column_name || '),
            p_data_type => ''' || l_data_type || '''
        );
    ELSIF UPDATING THEN
        audit_pkg.log_column_change(
            p_audit_id => v_audit_id,
            p_column_name => ''' || l_column_name || ''',
            p_old_value => TO_CLOB(:OLD.' || l_column_name || '),
            p_new_value => TO_CLOB(:NEW.' || l_column_name || '),
            p_data_type => ''' || l_data_type || '''
        );
    ELSIF DELETING THEN
        audit_pkg.log_column_change(
            p_audit_id => v_audit_id,
            p_column_name => ''' || l_column_name || ''',
            p_old_value => TO_CLOB(:OLD.' || l_column_name || '),
            p_new_value => NULL,
            p_data_type => ''' || l_data_type || '''
        );
    END IF;';
        END LOOP;
        
        CLOSE l_columns_cursor;
        
        l_trigger_code := l_trigger_code || '
        
EXCEPTION
    WHEN OTHERS THEN
        -- Логируем ошибку, но не прерываем основную транзакцию
        NULL;
END;';
        
        RETURN l_trigger_code;
    END generate_audit_trigger;
    
END audit_pkg;
/
```

### Представления для удобной работы с аудитом

```sql
-- Представление для полной информации об изменениях
CREATE OR REPLACE VIEW v_audit_full AS
SELECT 
    al.audit_id,
    al.table_name,
    al.record_id,
    al.record_name,
    al.event_type,
    al.event_date,
    al.user_name as event_user,
    ald.detail_id,
    ald.column_name,
    ald.old_value,
    ald.new_value,
    ald.data_type,
    ald.change_date
FROM audit_log al
LEFT JOIN audit_log_details ald ON al.audit_id = ald.audit_id
ORDER BY al.event_date DESC, ald.detail_id;

-- Представление для сводки изменений по таблицам
CREATE OR REPLACE VIEW v_audit_summary AS
SELECT 
    table_name,
    event_type,
    COUNT(*) as event_count,
    MIN(event_date) as first_event,
    MAX(event_date) as last_event,
    COUNT(DISTINCT user_name) as unique_users
FROM audit_log
GROUP BY table_name, event_type
ORDER BY table_name, event_type;
```

### Пример использования

```sql
-- Создание триггера для таблицы EMPLOYEES
-- Предполагаем, что у таблицы есть столбцы EMPLOYEE_ID и LAST_NAME
DECLARE
    l_trigger_sql CLOB;
BEGIN
    l_trigger_sql := audit_pkg.generate_audit_trigger(
        p_table_name => 'EMPLOYEES',
        p_key_column => 'EMPLOYEE_ID',
        p_name_column => 'LAST_NAME'
    );
    
    -- Выводим сгенерированный код триггера
    DBMS_OUTPUT.PUT_LINE(l_trigger_sql);
    
    -- Выполняем создание триггера
    EXECUTE IMMEDIATE l_trigger_sql;
END;
/
```


**1. Партиционирование таблиц аудита по датам:**
```sql
-- Для больших объемов данных рекомендуется партиционирование
ALTER TABLE audit_log 
PARTITION BY RANGE (event_date) 
INTERVAL (NUMTOYMINTERVAL(1, 'MONTH'));
```

**2. Процедура очистки старых записей:**
```sql
CREATE OR REPLACE PROCEDURE cleanup_audit_data(
    p_retention_days IN NUMBER DEFAULT 365
) AS
BEGIN
    DELETE FROM audit_log_details 
    WHERE audit_id IN (
        SELECT audit_id FROM audit_log 
        WHERE event_date < SYSDATE - p_retention_days
    );
    
    DELETE FROM audit_log 
    WHERE event_date < SYSDATE - p_retention_days;
    
    COMMIT;
END;
/
```

### Дополнительные возможности

**1. Уведомления о критических изменениях:**
