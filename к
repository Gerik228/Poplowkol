
```sql
-- Создание расширенной таблицы мониторинга
CREATE TABLE sync_log (
    id NUMBER GENERATED ALWAYS AS IDENTITY,
    table_name VARCHAR2(128) NOT NULL,
    sync_date DATE NOT NULL,
    sync_type VARCHAR2(20) NOT NULL, -- 'FULL' или 'INCREMENTAL'
    status VARCHAR2(10) NOT NULL,
    source_row_count NUMBER DEFAULT 0,
    target_row_count NUMBER DEFAULT 0,
    duration_seconds NUMBER,
    validation_result VARCHAR2(4000),
    error_msg VARCHAR2(4000),
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP,
    CONSTRAINT pk_sync_log PRIMARY KEY (id),
    CONSTRAINT chk_sync_status CHECK (status IN ('SUCCESS', 'ERROR', 'WARNING', 'EMPTY_SOURCE')),
    CONSTRAINT chk_sync_type CHECK (sync_type IN ('FULL', 'INCREMENTAL'))
);

-- Индексы
CREATE INDEX idx_sync_log_table_date ON sync_log(table_name, sync_date);
CREATE INDEX idx_sync_log_status ON sync_log(status);
```

### 2. Процедура всесторонней проверки

```sql
CREATE OR REPLACE PROCEDURE validate_sync_environment(
    p_table_name VARCHAR2,
    p_dblink_name VARCHAR2,
    p_validation_result OUT VARCHAR2,
    p_source_count OUT NUMBER,
    p_is_valid OUT BOOLEAN
) IS
    v_count NUMBER;
    v_dblink_valid BOOLEAN := FALSE;
    v_table_exists NUMBER := 0;
    v_structure_check VARCHAR2(4000);
    v_error_msg VARCHAR2(4000);
BEGIN
    p_is_valid := FALSE;
    p_validation_result := '';
    p_source_count := 0;
    
    -- 1. Проверка доступности dblink
    BEGIN
        EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM dual@' || p_dblink_name INTO v_count;
        v_dblink_valid := TRUE;
        p_validation_result := p_validation_result || 'DBLINK_OK; ';
    EXCEPTION
        WHEN OTHERS THEN
            p_validation_result := p_validation_result || 'DBLINK_ERROR: ' || SQLERRM || '; ';
            RETURN;
    END;
    
    -- 2. Проверка существования удаленной таблицы
    BEGIN
        EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM ' || p_table_name || '@' || p_dblink_name || ' WHERE ROWNUM = 1' INTO v_table_exists;
        p_validation_result := p_validation_result || 'TABLE_EXISTS; ';
    EXCEPTION
        WHEN OTHERS THEN
            IF SQLCODE = -942 THEN -- table or view does not exist
                p_validation_result := p_validation_result || 'TABLE_NOT_EXISTS; ';
            ELSE
                p_validation_result := p_validation_result || 'TABLE_ACCESS_ERROR: ' || SQLERRM || '; ';
            END IF;
            RETURN;
    END;
    
    -- 3. Подсчет количества записей в источнике
    BEGIN
        EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM ' || p_table_name || '@' || p_dblink_name INTO p_source_count;
        p_validation_result := p_validation_result || 'SOURCE_COUNT: ' || p_source_count || '; ';
    EXCEPTION
        WHEN OTHERS THEN
            p_validation_result := p_validation_result || 'COUNT_ERROR: ' || SQLERRM || '; ';
            RETURN;
    END;
    
    -- 4. Проверка структуры таблицы (базовая)
    BEGIN
        EXECUTE IMMEDIATE 'SELECT column_name FROM user_tab_columns@' || p_dblink_name || 
                         ' WHERE table_name = ''' || UPPER(p_table_name) || ''' AND ROWNUM = 1' INTO v_structure_check;
        p_validation_result := p_validation_result || 'STRUCTURE_OK; ';
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            p_validation_result := p_validation_result || 'NO_COLUMNS_INFO; ';
        WHEN OTHERS THEN
            p_validation_result := p_validation_result || 'STRUCTURE_CHECK_ERROR: ' || SQLERRM || '; ';
    END;
    
    -- Финальная оценка
    IF v_dblink_valid AND v_table_exists >= 0 THEN
        p_is_valid := TRUE;
        p_validation_result := p_validation_result || 'VALIDATION_PASSED';
    END IF;
    
EXCEPTION
    WHEN OTHERS THEN
        p_validation_result := 'VALIDATION_FATAL_ERROR: ' || SQLERRM;
        p_is_valid := FALSE;
END validate_sync_environment;
/
```

### 3. Усовершенствованная процедура синхронизации

```sql
CREATE OR REPLACE PROCEDURE sync_single_table_advanced(
    p_table_name VARCHAR2,
    p_dblink_name VARCHAR2,
    p_sync_type VARCHAR2 DEFAULT 'FULL', -- 'FULL' или 'INCREMENTAL'
    p_min_row_threshold NUMBER DEFAULT 0 -- минимальное количество строк для синхронизации
) IS
    v_local_table_name VARCHAR2(128);
    v_backup_table_name VARCHAR2(128);
    v_ddl_statement VARCHAR2(4000);
    v_error_msg VARCHAR2(4000);
    v_start_time TIMESTAMP;
    v_end_time TIMESTAMP;
    v_source_count NUMBER := 0;
    v_target_count NUMBER := 0;
    v_validation_result VARCHAR2(4000);
    v_is_environment_valid BOOLEAN;
    v_sync_status VARCHAR2(10) := 'ERROR';
    v_should_proceed BOOLEAN := FALSE;
BEGIN
    v_start_time := SYSTIMESTAMP;
    v_local_table_name := 'LOCAL_' || p_table_name || '_BACKUP';
    v_backup_table_name := 'LOCAL_' || p_table_name || '_OLD';
    
    -- Всесторонняя проверка окружения
    validate_sync_environment(
        p_table_name => p_table_name,
        p_dblink_name => p_dblink_name,
        p_validation_result => v_validation_result,
        p_source_count => v_source_count,
        p_is_valid => v_is_environment_valid
    );
    
    -- Принятие решения о продолжении синхронизации
    IF NOT v_is_environment_valid THEN
        v_sync_status := 'ERROR';
        v_error_msg := 'Environment validation failed: ' || v_validation_result;
    ELSIF v_source_count < p_min_row_threshold THEN
        v_sync_status := 'EMPTY_SOURCE';
        v_error_msg := 'Source table has insufficient data (' || v_source_count || ' rows, threshold: ' || p_min_row_threshold || ')';
        -- При пустом источнике не выполняем синхронизацию, но это не ошибка
    ELSE
        v_should_proceed := TRUE;
    END IF;
    
    -- Выполнение синхронизации при прохождении всех проверок
    IF v_should_proceed THEN
        BEGIN
            -- Создание резервной копии существующей таблицы
            BEGIN
                EXECUTE IMMEDIATE 'ALTER TABLE ' || v_local_table_name || 
                                 ' RENAME TO ' || v_backup_table_name;
            EXCEPTION
                WHEN OTHERS THEN 
                    NULL; -- Таблица не существует - это нормально
            END;
            
            -- Создание новой таблицы
            v_ddl_statement := 'CREATE TABLE ' || v_local_table_name || 
                              ' AS SELECT * FROM ' || p_table_name || '@' || p_dblink_name;
            
            EXECUTE IMMEDIATE v_ddl_statement;
            
            -- Подсчет результата
            EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM ' || v_local_table_name INTO v_target_count;
            
            -- Валидация результата
            IF v_target_count = v_source_count THEN
                v_sync_status := 'SUCCESS';
                
                -- Удаление старой резервной копии
                BEGIN
                    EXECUTE IMMEDIATE 'DROP TABLE ' || v_backup_table_name;
                EXCEPTION
                    WHEN OTHERS THEN NULL;
                END;
                
                -- Обновление статистики
                DBMS_STATS.GATHER_TABLE_STATS(USER, v_local_table_name);
                
            ELSE
                v_sync_status := 'WARNING';
                v_error_msg := 'Row count mismatch: source=' || v_source_count || ', target=' || v_target_count;
            END IF;
            
        EXCEPTION
            WHEN OTHERS THEN
                v_error_msg := SQLERRM;
                v_sync_status := 'ERROR';
                
                -- Восстановление предыдущей версии при ошибке
                BEGIN
                    EXECUTE IMMEDIATE 'DROP TABLE ' || v_local_table_name;
                EXCEPTION
                    WHEN OTHERS THEN NULL;
                END;
                
                BEGIN
                    EXECUTE IMMEDIATE 'ALTER TABLE ' || v_backup_table_name || 
                                     ' RENAME TO ' || v_local_table_name;
                EXCEPTION
                    WHEN OTHERS THEN NULL;
                END;
        END;
    END IF;
    
    -- Логирование результата
    v_end_time := SYSTIMESTAMP;
    INSERT INTO sync_log (
        table_name, sync_date, sync_type, status, 
        source_row_count, target_row_count, duration_seconds,
        validation_result, error_msg
    ) VALUES (
        p_table_name, SYSDATE, p_sync_type, v_sync_status,
        v_source_count, v_target_count, 
        EXTRACT(SECOND FROM (v_end_time - v_start_time)),
        v_validation_result, v_error_msg
    );
    COMMIT;
    
    -- Информативный вывод
    DBMS_OUTPUT.PUT_LINE('=== SYNC REPORT FOR ' || p_table_name || ' ===');
    DBMS_OUTPUT.PUT_LINE('Status: ' || v_sync_status);
    DBMS_OUTPUT.PUT_LINE('Source rows: ' || v_source_count);
    DBMS_OUTPUT.PUT_LINE('Target rows: ' || v_target_count);
    DBMS_OUTPUT.PUT_LINE('Validation: ' || v_validation_result);
    IF v_error_msg IS NOT NULL THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || v_error_msg);
    END IF;
    
END sync_single_table_advanced;
/
```

### 4. Интеллектуальная процедура создания заданий

```sql
CREATE OR REPLACE PROCEDURE create_smart_sync_job(
    p_table_name VARCHAR2,
    p_schedule_interval VARCHAR2 DEFAULT 'FREQ=DAILY;BYHOUR=20',
    p_dblink_name VARCHAR2 DEFAULT 'your_dblink',
    p_sync_type VARCHAR2 DEFAULT 'FULL',
    p_min_row_threshold NUMBER DEFAULT 1,
    p_test_run BOOLEAN DEFAULT TRUE
) IS
    v_job_name VARCHAR2(128);
    v_test_result VARCHAR2(4000);
    v_source_count NUMBER;
    v_is_valid BOOLEAN;
BEGIN
    v_job_name := 'SYNC_' || p_table_name || '_JOB';
    
    -- Обязательный тестовый запуск
    IF p_test_run THEN
        DBMS_OUTPUT.PUT_LINE('=== PERFORMING TEST RUN ===');
        validate_sync_environment(
            p_table_name => p_table_name,
            p_dblink_name => p_dblink_name,
            p_validation_result => v_test_result,
            p_source_count => v_source_count,
            p_is_valid => v_is_valid
        );
        
        DBMS_OUTPUT.PUT_LINE('Test validation result: ' || v_test_result);
        
        IF NOT v_is_valid THEN
            RAISE_APPLICATION_ERROR(-20001, 'Test validation failed: ' || v_test_result);
        END IF;
        
        IF v_source_count < p_min_row_threshold THEN
            RAISE_APPLICATION_ERROR(-20002, 'Source table has insufficient data (' || 
                v_source_count || ' rows, minimum required: ' || p_min_row_threshold || ')');
        END IF;
    END IF;
    
    -- Удаление существующего задания
    BEGIN
        DBMS_SCHEDULER.DROP_JOB(job_name => v_job_name, force => TRUE);
    EXCEPTION
        WHEN OTHERS THEN NULL;
    END;
    
    -- Создание нового задания
    DBMS_SCHEDULER.CREATE_JOB(
        job_name        => v_job_name,
        job_type        => 'PLSQL_BLOCK',
        job_action      => 'BEGIN sync_single_table_advanced(''' || p_table_name || ''', ''' || 
                          p_dblink_name || ''', ''' || p_sync_type || ''', ' || 
                          p_min_row_threshold || '); END;',
        start_date      => SYSTIMESTAMP + INTERVAL '5' MINUTE,
        repeat_interval => p_schedule_interval,
        enabled         => TRUE,
        comments        => 'Smart sync for ' || p_table_name || ' (type: ' || p_sync_type || ')'
    );
    
    DBMS_OUTPUT.PUT_LINE('Job created successfully: ' || v_job_name);
    DBMS_OUTPUT.PUT_LINE('Schedule: ' || p_schedule_interval);
    DBMS_OUTPUT.PUT_LINE('Sync type: ' || p_sync_type);
    DBMS_OUTPUT.PUT_LINE('Row threshold: ' || p_min_row_threshold);
    
END create_smart_sync_job;
/
```

## Выбор между полным и инкрементальным 

### Создание задания с проверками:
```sql
-- Включаем вывод сообщений
SET SERVEROUTPUT ON;

-- Создание задания с тестированием
BEGIN
    create_smart_sync_job(
        p_table_name => 'REMOTE_ORDERS',
        p_schedule_interval => 'FREQ=DAILY;BYHOUR=20',
        p_dblink_name => 'production_link',
        p_sync_type => 'FULL',
        p_min_row_threshold => 10, -- минимум 10 записей
        p_test_run => TRUE
    );
END;
/
```

### Ручная синхронизация с проверками:
```sql
-- Ручной запуск синхронизации
BEGIN
    sync_single_table_advanced(
        p_table_name => 'CUSTOMERS',
        p_dblink_name => 'production_link',
        p_sync_type => 'FULL',
        p_min_row_threshold => 5
    );
END;
/
```

## Мониторинг и управление

### Представление для контроля:
```sql
CREATE OR REPLACE VIEW v_sync_dashboard AS
SELECT 
    table_name,
    sync_type,
    status,
    sync_date,
    source_row_count,
    target_row_count,
    ROUND(duration_seconds, 2) as duration_sec,
    CASE 
        WHEN status = 'SUCCESS' AND sync_date > SYSDATE - 1 THEN 'HEALTHY'
        WHEN status = 'EMPTY_SOURCE' THEN 'EMPTY_SOURCE'
        WHEN status = 'WARNING' THEN 'WARNING'
        WHEN sync_date < SYSDATE - 2 THEN 'OUTDATED'
        ELSE 'ERROR'
    END as health_status,
    validation_result,
    error_msg
FROM (
    SELECT *,
           ROW_NUMBER() OVER (PARTITION BY table_name ORDER BY sync_date DESC) as rn
    FROM sync_log
) WHERE rn = 1
ORDER BY health_status DESC, sync_date DESC;
```

## 
