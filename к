давай ты напишешь полную корректную инструкцию по регистрации нажатий на карточки .
с учетом всех особенностей данной платформы. .oracle apex 23.1
мне нужно передавать какая карточка была нажата каким пользователем

## Полная инструкция по регистрации нажатий на карточки в Oracle APEX 23.1

Ниже приведена пошаговая инструкция, оптимизированная для платформы Oracle APEX 23.1, по надёжному логированию факта нажатия пользователем на карточку в статическом контенте с учетом всех практических особенностей.

### 1. Структура вашей логики

- **Лог хранения:** отдельная таблица в БД для фиксации событий
- **Фиксация события:** REST-модуль APEX (RESTful Web сервис)
- **Транспорт данных:** Beacon API (гарантированная отправка даже при уходе пользователя)
- **Инициация:** обработчик на JavaScript — передает данные о клике

### 2. Шаг 1: Создайте таблицу логов

```sql
CREATE TABLE CARD_CLICK_LOG (
    ID         NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    USERNAME   VARCHAR2(255),
    CLICK_TIME TIMESTAMP DEFAULT SYSTIMESTAMP,
    CARD_ID    VARCHAR2(255),
    SESSION_ID NUMBER,
    PAGE_ID    NUMBER,
    USER_AGENT VARCHAR2(512)
);
```

### 3. Шаг 2: Настройте REST-модуль в APEX

#### 3.1. Создайте REST-модуль

- **Shared Components → RESTful Web Services → Modules → Create**
- **Module Name:** card_logging
- **Base Path:** `/card_logging/`
- **Поставьте Published**

#### 3.2. Создайте REST Resource Template

- **URI Template:** `log`
- **Priority:** 0
- **HTTP Entity Tag Type:** None

#### 3.3. Создайте Resource Handler

- **HTTP Method:** POST
- **Source Type:** PL/SQL
- **Mime Types Allowed:** application/json (или пусто)
- **Code для Source:**

```plsql
DECLARE
    l_body CLOB := :body_text;
    l_card_id VARCHAR2(255);
    l_username VARCHAR2(255);
    l_session_id NUMBER;
    l_page_id NUMBER;
    l_json_obj JSON_OBJECT_T;
BEGIN
    l_json_obj := JSON_OBJECT_T.parse(l_body);
    l_card_id    := l_json_obj.get_string('cardId');
    l_username   := l_json_obj.get_string('username');
    l_session_id := l_json_obj.get_number('sessionId');
    l_page_id    := l_json_obj.get_number('pageId');

    INSERT INTO CARD_CLICK_LOG (
        USERNAME, CARD_ID, SESSION_ID, PAGE_ID, USER_AGENT
    ) VALUES (
        l_username,
        l_card_id,
        l_session_id,
        l_page_id,
        OWA_UTIL.get_cgi_env('HTTP_USER_AGENT')
    );
    COMMIT;
    :status := 204;
END;
```

### 4. Шаг 3: Сделайте карточки с уникальным идентификатором

```html
<a href="f?p=&APP_ID.:5:&APP_SESSION." class="card-link" data-card-id="DASHBOARD">...</a>
<a href="f?p=&APP_ID.:6:&APP_SESSION." class="card-link" data-card-id="REPORTS">...</a>
```

### 5. Шаг 4: Вставьте JavaScript для отправки события через Beacon API

Добавьте код на страницу или в Shared Components → JavaScript → Function and Global Variable Declaration:

```javascript
document.querySelectorAll('.card-link').forEach(function(link){
  link.addEventListener('click', function(e){
    try {
      var cardId = link.dataset.cardId;
      var username = $v('APP_USER');
      var sessionId = $v('APP_SESSION');
      var pageId = $v('APP_PAGE_ID') || $v('APP_PAGE_ID');
      var beaconUrl = '/ords/<ВАШ_СКИМА>/card_logging/log';

      // Подготовим JSON с данными
      var payload = JSON.stringify({
        cardId   : cardId,
        username : username,
        sessionId: sessionId,
        pageId   : pageId
      });

      // Отправим Beacon-запрос
      navigator.sendBeacon(beaconUrl, payload);

      // Можно не отменять переход, т.к. Beacon гарантирует отправку "в фоне"
      // e.preventDefault(); // Не надо ставить!
    } catch(ex) {
      // Для отладки
      console.error('Ошибка логирования клика:', ex);
    }
  });
});
```
**Важно!**  
- Подставьте реальный скима в `beaconUrl` (например, `/ords/myws/card_logging/log`).
- Не используйте `preventDefault()`, иначе переход на страницу не произойдет.
- При необходимости используйте апекс-переменные через `$v('APP_USER')`.

### 6. Шаг 5: Тест и проверка

- Откройте Chrome DevTools (F12), вкладка Network.
- Кликните по карточке — появится POST-запрос на ваш endpoint.
- В базе (или в интерактивном отчете на таблицу логов) должны появиться новые строки с нужной информацией.

### 7. Возможные проблемы и их решения

| Проблема                             | Причина/Решение                             |
|--------------------------------------|---------------------------------------------|
| В базе пусто                         | Проверьте PL/SQL-код, права и таблицу       |
| В Network нет POST на REST-URL       | Проверьте JS-код, селектор, правильный URL  |
| Нет имени пользователя               | Переменная `$v('APP_USER')` пуста/ошибка   |
| Код ошибки 401/403                   | Не опубликован модуль, нет доступа          |
| Не сохраняется user_agent            | Проверьте поле, перепроверьте PL/SQL        |

### Итог

- Гарантированно, быстро, минимально влияет на UX.
- Работает во всех современных браузерах.
- Не требует сложных блокировок AJAX или дополнительных call-back-обработчиков.
- Основа для расширения (можно фиксировать user agent, page ID, сессию, дополнительные параметры).

**Реализация через Beacon API — наилучшее решение для целей мониторинга поведения пользователя в APEX 23.1.**

Цитаты:
[1] 1000006968.jpg https://pplx-res.cloudinary.com/image/upload/v1752705456/user_uploads/72242679/43455e94-0dd0-4661-b073-e0349d39b83f/1000006968.jpg
[2] 1000006967.jpg https://pplx-res.cloudinary.com/image/upload/v1752705456/user_uploads/72242679/d9126733-1b72-47b5-a675-faa9f972eeff/1000006967.jpg
[3] 1000006966.jpg https://pplx-res.cloudinary.com/image/upload/v1752705456/user_uploads/72242679/1ac06571-216c-4276-8895-8b78e9f31d17/1000006966.jpg
