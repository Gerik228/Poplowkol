
Данная система предназначена для полного автоматизированного аудита любых пользовательских таблиц в приложениях Oracle APEX. Аудит регистрирует факты изменений (INSERT/UPDATE/DELETE) с детальной фиксацией по каждому полю, а также корректно сохраняет имя настоящего пользователя APEX.

## Архитектура решения

### Основные компоненты

- **Родительская таблица журнала (`audit_log`)**
    - Фиксирует сведения о событии: тип операции, объект, дата, пользователь, ID записи.
- **Детальная таблица (`audit_log_details`)**
    - Содержит историю изменений по каждому полю: старое/новое значение, тип, имя колонки.
- **Пакет `audit_pkg`**
    - Автоматически создаёт аудит-триггер для любой таблицы, не требуя ручного кода для списка полей.

## Схема базы данных

### Родительский журнал (`audit_log`)

| Столбец     | Тип            | Описание                              |
|-------------|----------------|---------------------------------------|
| audit_id    | NUMBER         | PK, autoincrement                     |
| table_name  | VARCHAR2(128)  | Имя таблицы, в которой было изменение |
| record_id   | NUMBER         | PK изменённой строки                  |
| record_name | VARCHAR2(500)  | Человекочитаемый текст (опционально)  |
| event_type  | VARCHAR2(20)   | Тип события (INSERT, UPDATE, DELETE)  |
| event_date  | TIMESTAMP      | Дата и время события                  |
| user_name   | VARCHAR2(100)  | Логин пользователя APEX               |
| session_id  | NUMBER         | Идентификатор сессии Oracle           |
| created_date| TIMESTAMP      | Тех. поле для сортировки              |

### Детальная таблица (`audit_log_details`)

| Столбец     | Тип            | Описание                                  |
|-------------|----------------|-------------------------------------------|
| detail_id   | NUMBER         | PK, autoincrement                         |
| audit_id    | NUMBER         | FK на audit_log.audit_id                  |
| column_name | VARCHAR2(128)  | Имя изменённого поля                      |
| old_value   | CLOB           | Старое значение                           |
| new_value   | CLOB           | Новое значение                            |
| data_type   | VARCHAR2(50)   | Тип данных поля                           |
| change_date | TIMESTAMP      | Время изменения (фиксация изменения поля) |

## Автоматизация логирования

### Принцип работы

- Для каждой таблицы создаётся специализированный триггер средствами пакета `audit_pkg`.
- Триггер работает по всем операциям DML без ручного обновления при изменении структуры таблицы (нужно только пересоздать триггер).
- Фиксируются все поля, кроме PK и identity.

## Быстрый старт: шаги внедрения

### 1. Очистка старых объектов

Выполните последовательно:

```sql
BEGIN
  FOR t IN (SELECT trigger_name FROM user_triggers WHERE trigger_name LIKE 'TRG_AUDIT_%') LOOP
    EXECUTE IMMEDIATE 'DROP TRIGGER '||t.trigger_name;
  END LOOP;
END;
/
BEGIN
  EXECUTE IMMEDIATE 'DROP PACKAGE audit_pkg';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/
BEGIN
  EXECUTE IMMEDIATE 'DROP TABLE audit_log_details CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/
BEGIN
  EXECUTE IMMEDIATE 'DROP TABLE audit_log CASCADE CONSTRAINTS';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/
BEGIN
  EXECUTE IMMEDIATE 'DROP VIEW v_audit_full';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/
BEGIN
  EXECUTE IMMEDIATE 'DROP VIEW v_audit_summary';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/
```

### 2. Создание таблиц

```sql
CREATE TABLE audit_log (
  audit_id     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  table_name   VARCHAR2(128) NOT NULL,
  record_id    NUMBER NOT NULL,
  record_name  VARCHAR2(500),
  event_type   VARCHAR2(20) NOT NULL,
  event_date   TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  user_name    VARCHAR2(100) DEFAULT NVL(
      SYS_CONTEXT('APEX$SESSION','APP_USER'),
      SYS_CONTEXT('USERENV','SESSION_USER')
  ),
  session_id   NUMBER DEFAULT SYS_CONTEXT('USERENV','SESSIONID'),
  created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
/
CREATE TABLE audit_log_details (
  detail_id   NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  audit_id    NUMBER NOT NULL,
  column_name VARCHAR2(128) NOT NULL,
  old_value   CLOB,
  new_value   CLOB,
  data_type   VARCHAR2(50),
  change_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
/
ALTER TABLE audit_log_details
  ADD CONSTRAINT fk_audit_details_log
  FOREIGN KEY(audit_id) REFERENCES audit_log(audit_id);
/
```

### 3. Создание пакета для генерации триггеров

**Спецификация:**

```sql
CREATE OR REPLACE PACKAGE audit_pkg AS
  PROCEDURE create_audit_trigger(
    p_table_name   IN VARCHAR2,
    p_pk_column    IN VARCHAR2,
    p_title_column IN VARCHAR2 DEFAULT NULL
  );
END audit_pkg;
/
```

**Тело:**

```sql
CREATE OR REPLACE PACKAGE BODY audit_pkg AS

  PROCEDURE create_audit_trigger(
    p_table_name   IN VARCHAR2,
    p_pk_column    IN VARCHAR2,
    p_title_column IN VARCHAR2 DEFAULT NULL
  ) AS
    l_sql       CLOB;
    c_cols      SYS_REFCURSOR;
    l_col_name  VARCHAR2(128);
    l_data_type VARCHAR2(128);
  BEGIN
    OPEN c_cols FOR
      SELECT column_name, data_type
        FROM user_tab_columns
       WHERE table_name      = UPPER(p_table_name)
         AND column_name    <> UPPER(p_pk_column)
         AND identity_column = 'NO'
       ORDER BY column_id;

    l_sql := 'CREATE OR REPLACE TRIGGER TRG_AUDIT_' || UPPER(p_table_name) || '
    AFTER INSERT OR UPDATE OR DELETE ON ' || p_table_name || '
    FOR EACH ROW
    DECLARE
      v_audit_id   NUMBER;
      v_rec_id     NUMBER;
      v_rec_name   VARCHAR2(500);
      v_event_type VARCHAR2(20);
    BEGIN
      IF INSERTING THEN
        v_event_type := ''INSERT'';
        v_rec_id     := :NEW.' || p_pk_column || ';
        v_rec_name   := ' || CASE
                             WHEN p_title_column IS NOT NULL
                             THEN ':NEW.' || p_title_column
                             ELSE 'NULL' END || ';
      ELSIF UPDATING THEN
        v_event_type := ''UPDATE'';
        v_rec_id     := :NEW.' || p_pk_column || ';
        v_rec_name   := ' || CASE
                             WHEN p_title_column IS NOT NULL
                             THEN ':NEW.' || p_title_column
                             ELSE 'NULL' END || ';
      ELSIF DELETING THEN
        v_event_type := ''DELETE'';
        v_rec_id     := :OLD.' || p_pk_column || ';
        v_rec_name   := ' || CASE
                             WHEN p_title_column IS NOT NULL
                             THEN ':OLD.' || p_title_column
                             ELSE 'NULL' END || ';
      END IF;

      INSERT INTO audit_log(
        table_name, record_id, record_name, event_type
      ) VALUES (
        ''' || UPPER(p_table_name) || ''',
        v_rec_id, v_rec_name, v_event_type
      ) RETURNING audit_id INTO v_audit_id;';

    LOOP
      FETCH c_cols INTO l_col_name, l_data_type;
      EXIT WHEN c_cols%NOTFOUND;
      l_sql := l_sql || '
      IF INSERTING THEN
        INSERT INTO audit_log_details(
          audit_id, column_name, old_value, new_value, data_type
        ) VALUES (
          v_audit_id, ''' || l_col_name || ''', NULL,
          TO_CLOB(:NEW.' || l_col_name || '), ''' || l_data_type || '''
        );
      ELSIF UPDATING THEN
        IF NVL(TO_CHAR(:OLD.' || l_col_name || '),''$$NULL$$'')
         <> NVL(TO_CHAR(:NEW.' || l_col_name || '),''$$NULL$$'') THEN
          INSERT INTO audit_log_details(
            audit_id, column_name, old_value, new_value, data_type
          ) VALUES (
            v_audit_id, ''' || l_col_name || ''',
            TO_CLOB(:OLD.' || l_col_name || '),
            TO_CLOB(:NEW.' || l_col_name || '),
            ''' || l_data_type || '''
          );
        END IF;
      ELSIF DELETING THEN
        INSERT INTO audit_log_details(
          audit_id, column_name, old_value, new_value, data_type
        ) VALUES (
          v_audit_id, ''' || l_col_name || ''',
          TO_CLOB(:OLD.' || l_col_name || '), NULL, ''' || l_data_type || '''
        );
      END IF;';
    END LOOP;
    CLOSE c_cols;

    l_sql := l_sql || '
    EXCEPTION WHEN OTHERS THEN NULL;
    END;';

    BEGIN
      EXECUTE IMMEDIATE 'DROP TRIGGER TRG_AUDIT_' || UPPER(p_table_name);
    EXCEPTION WHEN OTHERS THEN NULL;
    END;

    EXECUTE IMMEDIATE l_sql;
  END create_audit_trigger;

END audit_pkg;
/
```

## 4. Применение аудита к любой таблице

Пример для внедрения в таблицу `EMPLOYEES`, где PK — `EMPLOYEE_ID`, а имя пользователя — `LAST_NAME`:

```sql
BEGIN
  audit_pkg.create_audit_trigger(
    p_table_name   => 'EMPLOYEES',
    p_pk_column    => 'EMPLOYEE_ID',
    p_title_column => 'LAST_NAME'
  );
END;
/
```

Аналогично для других таблиц (корректируйте имена полей).

## 5. Представления для отчетов

**v_audit_full** — вся история по полям:
```sql
CREATE OR REPLACE VIEW v_audit_full AS
SELECT
  al.audit_id,
  al.table_name,
  al.record_id,
  al.record_name,
  al.event_type,
  al.event_date,
  al.user_name   AS event_user,
  ald.detail_id,
  ald.column_name,
  ald.old_value,
  ald.new_value,
  ald.data_type,
  ald.change_date
FROM audit_log al
LEFT JOIN audit_log_details ald ON al.audit_id = ald.audit_id
ORDER BY al.event_date DESC, ald.detail_id;
/
```

**v_audit_summary** — сводка по объектам:
```sql
CREATE OR REPLACE VIEW v_audit_summary AS
SELECT
  table_name,
  event_type,
  COUNT(*) AS event_count,
  MIN(event_date) AS first_event,
  MAX(event_date) AS last_event,
  COUNT(DISTINCT user_name) AS unique_users
FROM audit_log
GROUP BY table_name, event_type
ORDER BY table_name, event_type;
/
```

## 6. Проверка работы и операции

После создания и применения:

- Все действия INSERT/UPDATE/DELETE через интерфейс APEX будут логироваться с автором APEX-пользователя (APP_USER).
- Поле record_id будет строго NUMBER.
- В деталях user_name не дублируется.

### Примеры запросов

**Проверить события по таблице:**
```sql
SELECT * FROM audit_log WHERE table_name='EMPLOYEES' ORDER BY event_date DESC;
```
**Отчет по всем изменённым колонкам:**
```sql
SELECT * FROM v_audit_full WHERE table_name='EMPLOYEES' ORDER BY event_date DESC, column_name;
```

## Визуализация в APEX

- Создайте Interactive Report на основе `v_audit_full` для детализации и drill-down.
- На главной странице используйте `v_audit_summary` для быстрой навигации по ключевым таблицам и типам событий.

## Важные нюансы и рекомендации

- Для новых/изменённых таблиц всегда пересоздавайте триггер вызовом процедуры пакета — поля будут подхвачены автоматически.
- Если требуется строковый PK — необходимо вернуть тип record_id к VARCHAR2 и модифицировать код записи PK в триггер.
- Для cover-кейса, когда аудит нужен только по выбранным колонкам, адаптируйте запрос в пакете.

## Краткое резюме

- **Настоящий пользователь** приложения будет записан в user_name (через APEX).
- Вся детализация изменений присутствует по каждому полю без ручного кода.
- Универсальность: решение сразу работает для всей схемы, поддерживает гибкое расширение и отчёты.
- Опережающее соответствие современным требованиям безопасности, контроля и анализа данных.

